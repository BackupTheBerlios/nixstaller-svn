\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename nixstaller.info
@settitle Nixstaller Manual
@c %**end of header

@c @include macros.texi

@ifhtml
    @include macros-html.texi
@end ifhtml

@ifnothtml
    @include macros-default.texi
@end ifnothtml

@titlepage
@title Nixstaller 0.2 Manual
@author Rick Helmus
@end titlepage

@c Output the table of the contents at the beginning.
@contents

@ifnottex
    @node Top
    @top About
@end ifnottex

This document describes how to use Nixstaller to create installers for UNIX like systems.

Here is a short description for what you can find in this document:
@menu
* Features:: What Nixstaller can do.
* Installing:: How to install Nixstaller.
* Quickstart:: If you're in a hurry or want a quick reference.
* Basics:: Explains the basics behind Nixstaller.
* Lua Guide:: Explains the Lua scripting language.
* Index:: Complete Index
@end menu

@node Features
@chapter Features

@section Main Features
Here is a list with the main features. Read further for more info to see what they do and how to use them.

@itemize @bullet
@item 2 different frontends used for the installer: @uref{http://www.fltk.org,FLTK} and @uref{http://www.gnu.org/software/ncurses/ncurses.html,ncurses}.
@item Support for most common UNIX like systems: NetBSD(x86 and amd64), Linux(x86 and amd64), FreeBSD(x86 and amd64) and Solaris 10/Nexenta(x86).
@item A installer itself has the following features:
@itemize
@item Can be fully translated (no UTF yet). Translations for English and Dutch are supplied by default.
@item Different kind of installer screens:
@itemize
@item A screen where the user can select a language.
@item An introduction screen with an optional image and text.
@item A screen where the user can read/accept a provided license.
@item A screen where the user can select a destination directory to put the installation files.
@item A screen which shows the progress of the installation.
@item A screen which can show text after the installation.
@item A generic screen which can be made with a script.
@end itemize
Most screens are optional and can be shown in any particalur order.
@end itemize
@item Frontends are build in a way that they can be used on many different systems by linking less common libraries staticly.
@item The files can be packed with gzip-, bzip2 and lzma compression.
@item Installation files can be extracted to various directories; a temporary directory (usefull for @samp{./configure && make && make install} like installers), a directory which can be selected by the user and a default directory.
@item @uref{http://www.lua.org,Lua} support is provided to configure the installer and to program the installation procedure. This allows very flexible configurations.
@end itemize

@section Changelog
@subsection 0.1 --> 0.2
@itemize
@item Lua support.
@item Support for Nexenta/Solaris 10 and AMD64 support for Linux, FreeBSD an NetBSD.
@item New manuals created by @uref{http://www.gnu.org/software/texinfo,GNU's Texinfo}.
@end itemize



@node Installing
@chapter Installing
Installing Nixstaller is easy: just extract the files to a directory and your done. All the work (ie. calling scripts) is done inside this directory.


@node Quickstart
@chapter Quickstart
@itemize
@item @ref{Installing, Install} Nixstaller.
@item Go to a terminal and @command{cd} to the directory where you extracted Nixstaller.
@item @command{cp -R example/simple/ release/}
@item Edit @file{release/config.lua} and optionally @file{release/run.lua}
@item Put some files in @file{release/files_all/} and perhaps in @file{release/files_linux_all}, @file{release/files_freebsd_x86} etc.
@item @command{./geninstall.sh release/}
@item @command{./setup.sh}
@end itemize

@c UNDONE
Also read the tutorials.

@node Basics
@chapter Basics

@section Installation package
The final product of Nixstaller is a @emph{install package}. The package itself is simply a self-extracting archive in the form of a shell script. When the package(the shell script) is executed it will extract a few files to a temporary directory and will call another script. This second script will detect a usable frontend and will call it.
A install package itself contains the following files:
@itemize
@item One or more frontends. Depending on the configuration there can be multiple frontends for different systems.
@item One or two lua scripts which tell what the installer should do.
@item Translation files. (optional)
@item Some text files used for displaying a introduction text, license info and/or a finish message. (optional)
@item An archive file containing the files to be used for the installation.
@item A script that is called when the package is extracted.
@end itemize

In the following sections these items will be further explained.

@section Frontends
The @emph{frontend} is a program from which the user can interact. When the install package is executed by the user a suitable frontend will be launched. This is determined by if X is running and which frontends are included in the package for the user's system.

Currently there are 2 frontends for Nixstaller.
@ifhtml
One is powered by @uref{http://www.fltk.org,FLTK}:

@image{fltk,,,,png}

and the other by @uref{http://www.gnu.org/software/ncurses/ncurses.html,ncurses}:

@image{ncurs,,,,png}

@end ifhtml
@ifnothtml
The first is powered by FLTK and the second is powered by ncurses.
@end ifnothtml
You can select which frontend(s) you want to include.

@section Lua scripts
@c UNDONE
The installation is controlled by one or two lua scripts. In chapter X and chapter Y. This is in detail explained.

@section Translations
The text used by the frontends can be translated via @emph{translation files}. This file is simply called @file{strings} and will contain all (English) strings used by the installer with the translation beneath them. Any line that starts with a @samp{#} will be ignored.

Currently there are already 2 translations: Dutch and English. You can find these in the @file{lang/} directory. You can 'translate' the English @file{'strings'} file in order to modify the English texts used by the installer.

Here is a example taken from the file:
@codeblock{License agreement
Licentie overeenkomst}

@samp{Licentie overeenkomst} is dutch for @samp{License agreement}. It's very important that the English text (the first line) is exactly the same as used by the installer.
If you read further in this file you will see the following sentence:
@codeblock{Installation of %s complete!
Installatie van %s gereed!}

Notice the @samp{%s}? The @samp{%s} will be replaced by the installer with another string. This can be all kind of things, in this case it is the program name. What will be replaced is usually commented in the @file{strings} file itself.


@strong{IMPORTANT}: Currently there is no UTF support yet. This means that you can't use any 'special' characters yet (such as accented characters).

@subsection Multiline translations
Some translations need more than one line. If this is the case the text should be put between 2 square brackets.
For example:
@codeblock{[
Directory does not exist
Do you want to create it?
]
[
Directory bestaat niet
Wilt u het aanmaken?
]}

If you want to put a @samp{]} in the translation itself you should put a backslash before it: @samp{\]}.

@subsection Other things that can be translated
There are other things to be translated as well:
@itemize
@item The welcome message 
@item The license agreement 
@item The 'finish message' 
@item Text used by Lua scripts
@end itemize

@c UNDONE
The first 3 items will be explained in the next section. Lua scripts will be handled in chapter X.

@section Welcome message, license agreement and the @samp{finish message}
@table @strong
@item Welcome message
This is the message that is displayed on the @samp{Introduction installscreen}.
@item License agreement
This is the text used to display the License Agreement.
@item Finish message
This is the message that is displayed after the installation has (succesfully) finished.
@end table

Each of these items are stored in plain text files. The @emph{welcome message} is in the file @file{welcome}, the @emph{license agreement} is in a file called @file{license} and the @emph{finish message} is in the file @file{finish}.
@c UNDONE
For translations of any of these texts there should be a copy of the file put in a seperate directory. Chapter X describes the file layout and mentions where to put all the files.

@node Lua Guide
@chapter Lua Guide
@section Introduction
Lua (@url{http://www.lua.org}) is used for configuring properties of the @emph{Install Package} and to control the installation process. Lua is a simple and easy to learn scripting language. In the next section a brief guide is given about Lua. Another good resource is the @uref{http://www.lua.org/pil,Lua Book}. Note that the online version describes version @emph{5.0} while Nixstaller uses @emph{5.1}. Though not much has been changed, especially not the basics.

@section Lua Basics
@subsection Comments
Lua files can contain @emph{comments}. Comments are for example used to describe pieces of code or to quickly 'disable' some code.

Some examples:
@codeblock{-- This is a comment line, comment lines always start with @samp{--}
a = b + 5     -- Comment can be after a code line aswell
-- b = b + 1   -- A 'disabled' line}

There can also be @emph{comment blocks}:
@codeblock{--[
Text between the two square brackets is comment.
This is usefull if you want to write a few lines or disable multiple code lines.
--]}

@subsection Variabeles
To store data @emph{variables} are used. A variable name is a combination of letters, underscores and/or numbers. Note that the variable name cannot start with a number.
To create a variable you simply assign data to it. To remove a variable you assign @code{nil} to it.

@subsubsection Types
Variabeles are not bound to a single type(typeless, languages as C are typed). There are various types in the Lua environment:
@table @strong
@item Numbers
Numbers can be both a decimal type or a integral type. Examples:
@codeblock{a = 15
b = 1.5}
@item Strings
Strings are used to store an array of characters. The text used for a string should be either enclosed by single quotes ('') or double quotes (""). Example:
@codeblock{text1 = "Hello"}
@item Boolean
@c UNDONE
A Boolean is either @code{true} or @code{false}. They are used to enable/disable flags and test them in conditional lines. Example:
@codeblock{a = true
b = false}
@item Tables
@c UNDONE
Tables are a generic type and can be used in many different ways. See ... for a detailed explanation.
@item Functions
@c UNDONE
Functions can also be stored in variables. Section X is about functions.
@item @samp{@strong{nil}}
As said before, @code{nil} is used to delete a variable. @code{nil} is also sometimes used to indicate @samp{Nothing}. Example:
@codeblock{a = nil    -- a will now be collected by Lua's garbage collector}
@end table

@subsubsection Operators
Operators are used to operate on variables. For example to multiply 2 numbers or to add (concat) 2 strings to each other. The following table lists every operator and its function. The items are shown in order of priority.
@starttable{.25,.25,.25,.25}
@addtableheaderrow{Operator}
    @addtableheadercol{Used on}
    @addtableheadercol{Effect}
@endtablerow

@addtablerow{@code{^}}
    @addtablecol{Numbers}
    @addtablecol{Calculates the power}
@endtablerow

@c UNDONE
@addtablerow{@code{not}, -}
    @addtablecol{Numbers}
    @addtablecol{@code{not} returns @code{true} when a expression is false(see section X).@*
The minus in this case is the operator used for negative values.}
@endtablerow

@addtablerow{@code{/}, @code{*}}
    @addtablecol{Numbers}
    @addtablecol{Arithmetic operations (@abbr{resp.} divide, multiply)}
@endtablerow

@addtablerow{@code{+}, @code{-}}
    @addtablecol{Numbers}
    @addtablecol{Arithmetic operations (@abbr{resp.} add, substract)}
@endtablerow

@addtablerow{..}
    @addtablecol{Strings}
    @addtablecol{Concats 2 strings}
@endtablerow

@c UNDONE
@addtablerow{@code{>}, @code{<}, @code{>=}, @code{<=}, @code{==}, @code{~=}}
    @addtablecol{Strings, Numbers, Tables}
    @addtablecol{Used to compare values @*
See section X}
@endtablerow

@addtablerow{@code{and}}
    @addtablecol{Anything}
    @addtablecol{Checks if 2 expressions are @code{true} @*
See section X}
@endtablerow

@addtablerow{@code{or}}
    @addtablecol{Anything}
    @addtablecol{Checks if 1 of 2 expressions is @code{true} @*
See section X}
@endtablerow
@endtable

Parenthesis(@samp{()}) can be used to give an expression the highest priority.

Some examples:
@codeblock{a = 5 * 2       -- a = 10
b = 20 / 5      -- b = 4
c = (a + b) * 2 -- c = 28
d = 5^2         -- d = 25
txt1 = "Hello"
txt2 = "World"
txt = txt1 .. " ".. txt2    -- txt = "Hello World"}

@subsection Testing variables and values

@subsubsection Operators for testing
In lua there are a few operators to test variables and values:
@table @strong
@item <
Less than
@item >
More than
@item ==
Equal to (@strong{a single @samp{=} does not compare, just assign})
@item ~=
Unequal to
@item <=
Less or equal to
@item >=
More or equal to
@item and
Tests if 2 expressions are true
@item or
Tests if one of 2 expressions is true
@item not
Tests if a expression is not true
@end table

@c UNDONE
All of these work on @code{numbers} and @code{strings} and some might work on @code{tables} (see section X).

When a test succeeds @code{true} will be returned, when it fails @code{false} will be returned. Except for @code{or} and @code{and}. @code{or} will return the first expression if its true, otherwise the second. @code{and} will return the first expression if its false, otherwise the second.

Here are some examples:
@codeblock{a = 55
b = 100
c = a > b    -- c = false
@*
text1 = "Apple"
text2 = "Orange"
c = text1 < text2   -- c = true (alphabetical comparisation)
@*
c = 5 > 2 and "5" < "2"   -- false (second expression is false)}

As mentioned, the @code{or} and @code{and} operators will return one of the expressions. With that knowledge a nice trick can be made:
@codeblock{a = 5
b = 2
c = 6
d = 12
n = (a > b) and c or d   -- n = d(12)}
This might look a bit odd. If you're a C (or C++) programmer you may recognize this: it's similar to @code{(expr) ? a : b}. If you're not, here is what happens:
@itemize
@item @code{(a > b)}: this is false,
@item @code{... and c}: this is ignored since the previous expression was false. The first expression is returned (@code{false}).
@item @code{... or d}: The previous expression was @code{false}, so @code{or} will return @code{d} (12).
@item @code{n = ...}: @samp{12} was returned, so @code{n} is now @samp{12}.
@end itemize

@c UNDONE
If you find this confusing, you can use @code{if statements} (see section X) instead. This little trick is mainly used as a shortcut.

@subsubsection If statements
@code{if statements} are used to test some expression and if @code{true} it will execute some other code.
The general syntax is like this:
@codeblock{if expr1 then
    -- Code here for when expr1 is true
elseif expr2 then
    -- Code here for when expr2 is true and expr2 isn't
else
    -- Code here for when expr1 and expr2 are not true
end}

The @code{elseif} and @code{else} part is optional. The keyword @code{end} is used to end the @samp{if-then block}.
An expression is false when the value is @code{false} or @code{nil}. In any other case it's @code{true}.

@strong{NOTE}: In some other (scripting) languages zero (@samp{0}) and an empty @code{string} are @code{false}, however this is not the case in Lua.

Here are some examples (with comments) to illustrate some usage of if statements.
@c UNDONE
@codeblock{n = false
if n then
    -- Impossible
else
    -- Do something here
end
@*
-- This is the same as the 'and-or' trick of section X
if (a > b) then
    n = c
else
    n = d
end
@*
if (msg == "yes") and (not flag) then
    flag = true
elseif (msg == "no") and (flag) then
    flag = false
end}

@c UNDONE
@strong{Note}: I used parenthesis(@samp{()}) around some expressions and will in later examples. This is merely for clarity in most cases. In above examples the parenthesis don't have any effect. See section X for more details.

@subsection Loops
@emph{Loops} are used to execute some code lines more than once. In the following sections the different kind of loops available in Lua are explained.

@subsubsection @code{while} loops
The @code{while} loop looks like this:
@codeblock{while expr1 do
    -- Do some code
end}

As long as @samp{expr1} is not @code{false} it will execute the code in the @samp{while-do-end} block.
Here is a short example:
@codeblock
{n = 1
while (n <= 10) do
    -- Some code
@*
    n = n + 1
end}
In this example the @code{while} loop repeats itself until @code{n} is more than @samp{10}.

@subsubsection @code{repeat} loops
Another loop is the @samp{repeat-until} loop. This will repeat the code block @emph{until} some expression is @code{true}.
Example:
@codeblock
{n = 1
repeat
    -- Some code
@*
    n = n + 1
until n > 10}
This does exactly the same as the @code{while} example. So why choose @code{repeat} over @code{while}? A reason is when you want to execute the code in the block atleast once. With a @code{while} loop the expression has to be @code{true} before the loop can even begin. With the @code{repeat} - @code{until} statement however it will check the expression at the end of the block and therefore execute the code atleast once.

@subsubsection @code{for} loops
@c UNDONE
There are 2 kind of @code{for} loops: the @emph{numeric} and the @emph{generic}. We will discuss the first here, the @emph{generic} @code{for} loop will be explained in section X.

The @emph{numeric} @code{for} loop looks like this:
@codeblock
{for var=expr1,expr2,expr3 do
    -- Some code
end}

@table @emph
@item var=expr1
This will assign @emph{expr1} to the variable @code{var}. Note that this variable @strong{only} exists in the @code{for} loop.
@item expr2
As long as @emph{expr2} is unequal to @code{var} the loop repeats itself.
@item expr3
This is optional. @emph{expr3} is used to specify how much @code{var} should increment (or decrement incase a negative value is specified). If not specified it defaults to @samp{1}.
@end table

Now some examples:
@codeblock
{for n=1,10 do
    -- Some code here that will be executed 10 times
end
@*
for n=2,20,2 do
    -- Some code that will be executed 10 times. (n = incremented by 2 each time)
end}

Here are some points to remember with @code{for} loops:
@itemize
@item As been said the variable used for the loop only exists inside the loop. If you need the value outside the loop you should copy it to another variable.
@item All the three expressions are evaluated just once. This is important to know when you use functions (see section X) for an expression.
@item Do not modify the variable used by the @code{for} loop by hand.
@end itemize

@subsubsection @code{break}
@c UNDONE
To escape from a loop in Lua you can use @code{break} (or @code{return} which is handled in section X).
Here is an example:
@codeblock
{n = 1
while (true)  -- Infinite loop
    if (n == 50) then
        break -- Not infinite afterall
    end
    n = n + 1
end}
This will escape from the loop when n equals to @samp{50}.
Note that you can only use @code{break} at the end of a code block. In this case it was at the end of the @samp{if-then} block. If this wasn't the case Lua would throw an error.

@subsection Functions
@emph{Functions} are a way to create @samp{commands}. With functions a piece of code can be executed on all kinds of places.

@subsubsection Basics
Before a function can be used you have to @emph{declare} it:
@codeblock
{function funcname(args)
    -- Code
end}
@table @emph
@item funcname
This is how the function will be called.
@item args
Which @emph{arguments} or @emph{parameters} this function expects. More on this later.
@end table

@subsubsection Functions arguments
Some functions may need data from the caller. To pass this data @emph{function parameters} are used. These are variables which are @emph{local} (not exist outside the function) to this function. Here is an example to acclompish this:
@codeblock
{
counter = 0
@*
function increment(n) -- Function that increments @samp{counter} by @code{n}
    counter = counter + n
end
@*
@*
increment(5)
-- counter is now 5
increment(-2)
-- counter is now 3}
You can also specify multiple function arguments: just seperate them with a comma (@samp{,}).

@c UNDONE
Functions can also have a variable number of arguments. See section X for more info.

@subsubsection Return values
When a function is called it can also return data to the caller. Here is how it generally looks:
@codeblock
{function func()
    -- Code here
    return arg1, arg2, arg3 -- etc
end}

Lua has the feature that it can return multiple values. Here are some examples that show how it's used:
@codeblock
{function sum(a, b)
    return a + b
end
@*
function f()
    return "Hello", " ", "World"
end
@*
@*
n1 = 5
n2 = 10
n3 = sum(n1, n2)    -- n3 = 15
@*
str1, str2, str3 = f() -- str1 = "Hello", str2 = " ", str3 = "World"}

@subsection Local variables
For now mostly @emph{global} variables were used. There is another type of variable: the @emph{local} variable. The variable used in a numeric @code{for} loop is local, so are the function arguments. Local variables only exist in a code block (and the underlying code blocks). To create local variables you have to @emph{define} them with the @code{local} keyword. Local variables are mostly used inside functions, so that they don't corrupt the global environment.
As usual, here are some examples:
@codeblock
{function f()
    local a             -- a will only exist in this function
    local b, c          -- More variables can be defined at once
    local c, d = 5, 6   -- And can also be assigned: c = 5, d = 6
@*
    -- Some code
end
@*
count = 0    -- Global variable
@*
function g()
    local count     -- Overide count
    count = 1       -- Modify our own count
end
@*
-- count is still 0 here}

@section Advanced Lua

@subsection More About Functions

@subsubsection Closures

@subsubsection Local Functions


@subsection Tables

@subsubsection Table Seen As An Array

@subsubsection Table Seen As A Record

@subsubsection Table Seen As A Package


@subsection Generic @code{for}


@subsection

@section Lua Library
@subsection Functions That Interact With The OS

@subsection I/O Functions

@subsection Math Functions

@subsection Installation Functions

@subsection Other Functions


@node Index
@unnumbered Index

@printindex cp

@bye
