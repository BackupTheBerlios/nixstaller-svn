\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename nixstaller.info
@settitle Nixstaller Manual
@c %**end of header

@c @include macros.texi

@ifhtml
    @include macros-html.texi
@end ifhtml

@ifnothtml
    @include macros-default.texi
@end ifnothtml

@titlepage
@title Nixstaller 0.2 Manual
@author Rick Helmus
@end titlepage

@c Output the table of the contents at the beginning.
@contents

@ifnottex
    @node Top
    @top About
@end ifnottex

This document describes how to use Nixstaller to create installers for UNIX like systems.

Here is a short description for what you can find in this document:
@menu
* Features:: What Nixstaller can do.
* Installing:: How to install Nixstaller.
* Quickstart:: If you're in a hurry or want a quick reference.
* Basics:: Explains the basics behind Nixstaller.
* Lua Guide:: Explains the Lua scripting language.
* Index:: Complete Index
@end menu

@node Features
@chapter Features

@section Main Features
Here is a list with the main features. Read further for more info to see what they do and how to use them.

@itemize @bullet
@item 2 different frontends used for the installer: @uref{http://www.fltk.org,FLTK} and @uref{http://www.gnu.org/software/ncurses/ncurses.html,ncurses}.
@item Support for most common UNIX like systems: NetBSD(x86 and amd64), Linux(x86 and amd64), FreeBSD(x86 and amd64) and Solaris 10/Nexenta(x86).
@item An installer itself has the following features:
@itemize
@item Can be fully translated (no UTF yet). Translations for English and Dutch are supplied by default.
@item Different kind of installer screens:
@itemize
@item A screen where the user can select a language.
@item An introduction screen with an optional image and text.
@item A screen where the user can read/accept a provided license.
@item A screen where the user can select a destination directory to put the installation files.
@item A screen which shows the progress of the installation.
@item A screen which can show text after the installation.
@item A generic screen which can be made with a script.
@end itemize
Most screens are optional and can be shown in any particalur order.
@end itemize
@item Frontends are build in a way that they can be used on many different systems by linking less common libraries staticly.
@item The files can be packed with gzip-, bzip2 and lzma compression.
@item Installation files can be extracted to various directories; a temporary directory (useful for @samp{./configure && make && make install} like installers), a directory which can be selected by the user and a default directory.
@item @uref{http://www.lua.org,Lua} support is provided to configure the installer and to program the installation procedure. This allows very flexible configurations.
@end itemize

@section Changelog
@subsection 0.1 --> 0.2
@itemize
@item Lua support.
@item Support for Nexenta/Solaris 10 and AMD64 support for Linux, FreeBSD an NetBSD.
@item New manuals created by @uref{http://www.gnu.org/software/texinfo,GNU's Texinfo}.
@end itemize



@node Installing
@chapter Installing
Installing Nixstaller is easy: just extract the files to a directory and your done. All the work (ie. calling scripts) is done inside this directory.


@node Quickstart
@chapter Quickstart
@itemize
@item @ref{Installing, Install} Nixstaller.
@item Go to a terminal and @command{cd} to the directory where you extracted Nixstaller.
@item @command{cp -R example/simple/ release/}
@item Edit @file{release/config.lua} and optionally @file{release/run.lua}
@item Put some files in @file{release/files_all/} and perhaps in @file{release/files_linux_all}, @file{release/files_freebsd_x86} etc.
@item @command{./geninstall.sh release/}
@item @command{./setup.sh}
@end itemize

@c UNDONE
Also read the tutorials.

@node Basics
@chapter Basics

@section Installation package
The final product of Nixstaller is a @emph{install package}. The package itself is simply a self-extracting archive in the form of a shell script. When the package(the shell script) is executed it will extract a few files to a temporary directory and will call another script. This second script will detect a usable frontend and will call it.
A install package itself contains the following files:
@itemize
@item One or more frontends. Depending on the configuration there can be multiple frontends for different systems.
@item One or two lua scripts which tell what the installer should do.
@item Translation files. (optional)
@item Some text files used for displaying a introduction text, license info and/or a finish message. (optional)
@item An archive file containing the files to be used for the installation.
@item A script that is called when the package is extracted.
@end itemize

In the following sections these items will be further explained.

@section Frontends
The @emph{frontend} is a program from which the user can interact. When the install package is executed by the user a suitable frontend will be launched. This is determined by if X is running and which frontends are included in the package for the user's system.

Currently there are 2 frontends for Nixstaller.
@ifhtml
One is powered by @uref{http://www.fltk.org,FLTK}:

@image{fltk,,,,png}

and the other by @uref{http://www.gnu.org/software/ncurses/ncurses.html,ncurses}:

@image{ncurs,,,,png}

@end ifhtml
@ifnothtml
The first is powered by FLTK and the second is powered by ncurses.
@end ifnothtml
You can select which frontend(s) you want to include.

@section Lua scripts
@c UNDONE
The installation is controlled by one or two lua scripts. In chapter X and chapter Y. This is in detail explained.

@section Translations
The text used by the frontends can be translated via @emph{translation files}. This file is simply called @file{strings} and will contain all (English) strings used by the installer with the translation beneath them. Any line that starts with a @samp{#} will be ignored.

Currently there are already 2 translations: Dutch and English. You can find these in the @file{lang/} directory. You can 'translate' the English @file{'strings'} file in order to modify the English texts used by the installer.

Here is a example taken from the file:
@codeblock{License agreement
Licentie overeenkomst}

@samp{Licentie overeenkomst} is dutch for @samp{License agreement}. It's very important that the English text (the first line) is exactly the same as used by the installer.
If you read further in this file you will see the following sentence:
@codeblock{Installation of %s complete!
Installatie van %s gereed!}

Notice the @samp{%s}? The @samp{%s} will be replaced by the installer with another string. This can be all kind of things, in this case it is the program name. What will be replaced is usually commented in the @file{strings} file itself.


@strong{IMPORTANT}: Currently there is no UTF support yet. This means that you can't use any 'special' characters yet (such as accented characters).

@subsection Multiline translations
Some translations need more than one line. If this is the case the text should be put between 2 square brackets.
For example:
@codeblock{[
Directory does not exist
Do you want to create it?
]
[
Directory bestaat niet
Wilt u het aanmaken?
]}

If you want to put a @samp{]} in the translation itself you should put a backslash before it: @samp{\]}.

@subsection Other things that can be translated
There are other things to be translated as well:
@itemize
@item The welcome message 
@item The license agreement 
@item The 'finish message' 
@item Text used by Lua scripts
@end itemize

@c UNDONE
The first 3 items will be explained in the next section. Lua scripts will be handled in chapter X.

@section Welcome message, license agreement and the @samp{finish message}
@table @strong
@item Welcome message
This is the message that is displayed on the @samp{Introduction installscreen}.
@item License agreement
This is the text used to display the License Agreement.
@item Finish message
This is the message that is displayed after the installation has (succesfully) finished.
@end table

Each of these items are stored in plain text files. The @emph{welcome message} is in the file @file{welcome}, the @emph{license agreement} is in a file called @file{license} and the @emph{finish message} is in the file @file{finish}.
@c UNDONE
For translations of any of these texts there should be a copy of the file put in a seperate directory. Chapter X describes the file layout and mentions where to put all the files.

@node Lua Guide
@chapter Lua Guide
@section Introduction
Lua (@url{http://www.lua.org}) is used for configuring properties of the @emph{Install Package} and to control the installation process. Lua is a simple and easy to learn scripting language. In the next section a brief guide is given about Lua. Another good resource is the @uref{http://www.lua.org/pil,Lua Book}. Note that the online version describes version @emph{5.0} while Nixstaller uses @emph{5.1}. Though not much has been changed, especially not the basics.

@section Lua Basics
@subsection Comments
Lua files can contain @emph{comments}. Comments are for example used to describe pieces of code or to quickly 'disable' some code.

Some examples:
@codeblock{-- This is a comment line, comment lines always start with @samp{--}
a = b + 5     -- Comment can be after a code line aswell
-- b = b + 1   -- A 'disabled' line}

There can also be @emph{comment blocks}:
@codeblock{--[
Text between the two square brackets is comment.
This is useful if you want to write a few lines or disable multiple code lines.
--]}

@subsection Variables
To store data @emph{variables} are used. A variable name is a combination of letters, underscores and/or numbers. Note that the variable name cannot start with a number.
To create a variable you simply assign data to it. To remove a variable you assign @code{nil} to it.

@subsubsection Types
Variables are not bound to a single type(typeless, languages as C are typed). There are various types in the Lua environment:
@table @strong
@item Numbers
Numbers can be both a decimal type or a integral type. Examples:
@codeblock{a = 15
b = 1.5}
@item Strings
Strings are used to store an array of characters. The text used for a string should be either enclosed by single quotes ('') or double quotes (""). Example:
@codeblock{text1 = "Hello"}
@item Boolean
@c UNDONE
A Boolean is either @code{true} or @code{false}. They are used to enable/disable flags and test them in conditional lines. Example:
@codeblock{a = true
b = false}
@item Tables
@c UNDONE
Tables are a generic type and can be used in many different ways. See ... for a detailed explanation.
@item Functions
@c UNDONE
Functions can also be stored in variables. Section X is about functions.
@item @samp{@strong{nil}}
As said before, @code{nil} is used to delete a variable. @code{nil} is also sometimes used to indicate @samp{Nothing}. Example:
@codeblock{a = nil    -- a will now be collected by Lua's garbage collector}
@end table

@subsubsection Operators
Operators are used to operate on variables. For example to multiply 2 numbers or to add (concat) 2 strings to each other. The following table lists every operator and its function. The items are shown in order of priority.
@starttable{.25,.25,.25,.25}
@addtableheaderrow{Operator}
    @addtableheadercol{Used on}
    @addtableheadercol{Effect}
@endtablerow

@addtablerow{@code{^}}
    @addtablecol{Numbers}
    @addtablecol{Calculates the power}
@endtablerow

@c UNDONE
@addtablerow{@code{not}, @code{-}, @code{#}}
    @addtablecol{Numbers}
    @addtablecol{@code{not} returns @code{true} when a expression is false(see section X).@*
The minus in this case is the operator used for negative values.@*
The @samp{#} is used to retrieve the number of entries in a table (see section X) or the length of a string.}
@endtablerow

@addtablerow{@code{/}, @code{*}}
    @addtablecol{Numbers}
    @addtablecol{Arithmetic operations (@abbr{resp.} divide, multiply)}
@endtablerow

@addtablerow{@code{+}, @code{-}}
    @addtablecol{Numbers}
    @addtablecol{Arithmetic operations (@abbr{resp.} add, substract)}
@endtablerow

@addtablerow{..}
    @addtablecol{Strings}
    @addtablecol{Concats 2 strings}
@endtablerow

@c UNDONE
@addtablerow{@code{>}, @code{<}, @code{>=}, @code{<=}, @code{==}, @code{~=}}
    @addtablecol{Strings, Numbers, Tables}
    @addtablecol{Used to compare values @*
See section X}
@endtablerow

@addtablerow{@code{and}}
    @addtablecol{Anything}
    @addtablecol{Checks if 2 expressions are @code{true} @*
See section X}
@endtablerow

@addtablerow{@code{or}}
    @addtablecol{Anything}
    @addtablecol{Checks if 1 of 2 expressions is @code{true} @*
See section X}
@endtablerow
@endtable

Parenthesis(@samp{()}) can be used to give an expression the highest priority.

Some examples:
@codeblock{a = 5 * 2       -- a = 10
b = 20 / 5      -- b = 4
c = (a + b) * 2 -- c = 28
d = 5^2         -- d = 25
txt1 = "Hello"
txt2 = "World"
txt = txt1 .. " ".. txt2    -- txt = "Hello World"}
Note that the @samp{..} operator can convert numbers to strings aswell:
@codeblock
{n = 5
txt = "The number is: " .. n    -- txt = "The number is: 5"}

@subsection Testing variables and values

@subsubsection Operators for testing
In lua there are a few operators to test variables and values:
@table @strong
@item <
Less than
@item >
More than
@item ==
Equal to (@strong{a single @samp{=} does not compare, just assign})
@item ~=
Unequal to
@item <=
Less or equal to
@item >=
More or equal to
@item and
Tests if 2 expressions are true
@item or
Tests if one of 2 expressions is true
@item not
Tests if a expression is not true
@end table

@c UNDONE
All of these work on @code{numbers} and @code{strings} and some might work on @code{tables} (see section X).

When a test succeeds @code{true} will be returned, when it fails @code{false} will be returned. Except for @code{or} and @code{and}. @code{or} will return the first expression if its true, otherwise the second. @code{and} will return the first expression if its false, otherwise the second.

Here are some examples:
@codeblock{a = 55
b = 100
c = a > b    -- c = false
@*
text1 = "Apple"
text2 = "Orange"
c = text1 < text2   -- c = true (alphabetical comparisation)
@*
c = 5 > 2 and "5" < "2"   -- false (second expression is false)}

As mentioned, the @code{or} and @code{and} operators will return one of the expressions. With that knowledge a nice trick can be made:
@codeblock{a = 5
b = 2
c = 6
d = 12
n = (a > b) and c or d   -- n = d(12)}
This might look a bit odd. If you're a C (or C++) programmer you may recognize this: it's similar to @code{(expr) ? a : b}. If you're not, here is what happens:
@itemize
@item @code{(a > b)}: this is false,
@item @code{... and c}: this is ignored since the previous expression was false. The first expression is returned (@code{false}).
@item @code{... or d}: The previous expression was @code{false}, so @code{or} will return @code{d} (12).
@item @code{n = ...}: @samp{12} was returned, so @code{n} is now @samp{12}.
@end itemize

@c UNDONE
If you find this confusing, you can use @code{if statements} (see section X) instead. This little trick is mainly used as a shortcut.

@subsubsection If statements
@code{if statements} are used to test some expression and if @code{true} it will execute some other code.
The general syntax is like this:
@codeblock{if expr1 then
    -- Code here for when expr1 is true
elseif expr2 then
    -- Code here for when expr2 is true and expr2 isn't
else
    -- Code here for when expr1 and expr2 are not true
end}

The @code{elseif} and @code{else} part is optional. The keyword @code{end} is used to end the @samp{if-then block}.
An expression is false when the value is @code{false} or @code{nil}. In any other case it's @code{true}.

@strong{NOTE}: In some other (scripting) languages zero (@samp{0}) and an empty @code{string} are @code{false}, however this is not the case in Lua.

Here are some examples (with comments) to illustrate some usage of if statements.
@c UNDONE
@codeblock{n = false
if n then
    -- Impossible
else
    -- Do something here
end
@*
-- This is the same as the 'and-or' trick of section X
if (a > b) then
    n = c
else
    n = d
end
@*
if (msg == "yes") and (not flag) then
    flag = true
elseif (msg == "no") and (flag) then
    flag = false
end}

@c UNDONE
@strong{Note}: I used parenthesis(@samp{()}) around some expressions and will in later examples. This is merely for clarity in most cases. In above examples the parenthesis don't have any effect. See section X for more details.

@subsection Loops
@emph{Loops} are used to execute some code lines more than once. In the following sections the different kind of loops available in Lua are explained.

@subsubsection @code{while} loops
The @code{while} loop looks like this:
@codeblock{while expr1 do
    -- Do some code
end}

As long as @samp{expr1} is not @code{false} it will execute the code in the @samp{while-do-end} block.
Here is a short example:
@codeblock
{n = 1
while (n <= 10) do
    -- Some code
@*
    n = n + 1
end}
In this example the @code{while} loop repeats itself until @code{n} is more than @samp{10}.

@subsubsection @code{repeat} loops
Another loop is the @samp{repeat-until} loop. This will repeat the code block @emph{until} some expression is @code{true}.
Example:
@codeblock
{n = 1
repeat
    -- Some code
@*
    n = n + 1
until n > 10}
This does exactly the same as the @code{while} example. So why choose @code{repeat} over @code{while}? A reason is when you want to execute the code in the block atleast once. With a @code{while} loop the expression has to be @code{true} before the loop can even begin. With the @code{repeat} - @code{until} statement however it will check the expression at the end of the block and therefore execute the code atleast once.

@subsubsection @code{for} loops
@c UNDONE
There are 2 kind of @code{for} loops: the @emph{numeric} and the @emph{generic}. We will discuss the first here, the @emph{generic} @code{for} loop will be explained in section X.

The @emph{numeric} @code{for} loop looks like this:
@codeblock
{for var=expr1,expr2,expr3 do
    -- Some code
end}

@table @emph
@item var=expr1
This will assign @emph{expr1} to the variable @code{var}. Note that this variable @strong{only} exists in the @code{for} loop.
@item expr2
As long as @emph{expr2} is unequal to @code{var} the loop repeats itself.
@item expr3
This is optional. @emph{expr3} is used to specify how much @code{var} should increment (or decrement incase a negative value is specified). If not specified it defaults to @samp{1}.
@end table

Now some examples:
@codeblock
{for n=1,10 do
    -- Some code here that will be executed 10 times
end
@*
for n=2,20,2 do
    -- Some code that will be executed 10 times. (n = incremented by 2 each time)
end}

Here are some points to remember with @code{for} loops:
@itemize
@item As been said the variable used for the loop only exists inside the loop. If you need the value outside the loop you should copy it to another variable.
@item All the three expressions are evaluated just once. This is important to know when you use functions (see section X) for an expression.
@item Do not modify the variable used by the @code{for} loop by hand.
@end itemize

@subsubsection @code{break}
@c UNDONE
To escape from a loop in Lua you can use @code{break} (or @code{return} which is handled in section X).
Here is an example:
@codeblock
{n = 1
while (true)  -- Infinite loop
    if (n == 50) then
        break -- Not infinite afterall
    end
    n = n + 1
end}
This will escape from the loop when n equals to @samp{50}.
Note that you can only use @code{break} at the end of a code block. In this case it was at the end of the @samp{if-then} block. If this wasn't the case Lua would throw an error.

@subsection Functions
@emph{Functions} are a way to create @samp{commands}. With functions a piece of code can be executed on all kinds of places.

@subsubsection Basics
Before a function can be used you have to @emph{declare} it:
@codeblock
{function funcname(args)
    -- Code
end}
@table @emph
@item funcname
This is how the function will be called.
@item args
Which @emph{arguments} or @emph{parameters} this function expects.
@end table

@subsubsection Functions arguments
Some functions may need data from the caller. To pass this data @emph{function parameters} are used. These are variables which are @emph{local} (not exist outside the function) to this function. Here is an example to acclompish this:
@codeblock
{
counter = 0
@*
function increment(n) -- Function that increments @samp{counter} by @code{n}
    counter = counter + n
end
@*
@*
increment(5)
-- counter is now 5
increment(-2)
-- counter is now 3}
You can also specify multiple function arguments: just seperate them with a comma (@samp{,}).

@c UNDONE
Functions can also have a variable number of arguments. See section X for more info.

@subsubsection Return values
When a function is called it can also return data to the caller. Here is how it generally looks:
@codeblock
{function func()
    -- Code here
    return arg1, arg2, arg3 -- etc
end}

Unlike some other language, lua has the feature to return multiple values. Here are some examples about returning values:
@codeblock
{function sum(a, b)
    return a + b
end
@*
function f()
    return "Hello", " ", "World"
end
@*
@*
n1 = 5
n2 = 10
n3 = sum(n1, n2)    -- n3 = 15
@*
str1, str2, str3 = f() -- str1 = "Hello", str2 = " ", str3 = "World"}

@subsection Local variables
For now mostly @emph{global} variables were used. There is another type of variable: the @emph{local} variable. The variable used in a numeric @code{for} loop is local, so are the function arguments. Local variables only exist in a code block (and the underlying code blocks). To create local variables you have to @emph{define} them with the @code{local} keyword. Local variables are mostly used inside functions, so that they don't corrupt the global environment.
As usual, here are some examples:
@codeblock
{function f()
    local a             -- a will only exist in this function
    local b, c          -- More variables can be defined at once
    local c, d = 5, 6   -- And can also be assigned: c = 5, d = 6
@*
    -- Some code
end
@*
count = 0    -- Global variable
@*
function g()
    local count     -- Overide count
    count = 1       -- Modify our own count
end
@*
-- count is still 0 here}
As shown above @code{local} variables can have the same name as a existing global variable. In such cases @code{local} variables have a higher priority then underlying global variables.

@section Advanced Lua
@c UNDONE
In this section some of the more advanced features of Lua will be shown. Atleast the first 2 sections of tables is important. For less advanced installers these might be enough for now.

@subsection Functions As Variables
@c UNDONE
As said before in section X, functions are a variable type. The way we did to create functions so far is actually a shortcut to assign a function to a (global) variable:
@codeblock
{function f()
    -- ...
end}
Is essentially the same as:
@codeblock
{f = function()
    -- ...
end}

With that knowledge some interesting things can be made. @*
For example, a function can be passed to another function:
@codeblock
{function sum(a, b)
    return a + b
end
@*
x = 0
@*
function modifyx(func, val1, val2)
    x = func(val1, val2)
end
@*
modifyx(sum, 1, 1)
-- x is now 2}

Another example is to use @emph{anonymous functions}. These are, as the name suggests, functions without a name. A good reason to use them is when you want to pass (a simple) function like we did above. Here is the anonymous version:
@codeblock
{x = 0
@*
function modifyx(func, val1, val2)
    x = func(val1, val2)
end
@*
modifyx(function(a, b)
            return a + b
        end, 1, 1)
-- x is now 2}
This does essentially the same, just with a anonymous function.

@subsection Tables
Tables are generic types also called @emph{objects}. Tables can be used to create new datatypes, store blocks of data (arrays) and even for OOP(Object Orientated Programming). Not all features of tables are described. Just the few that are in the authors opinion important to know for now. A good reference for lua tables is the @uref{http://www.lua.org,Lua Book}.

@subsubsection Creating A table
Before we go in to details, lets start with how to create a table. Unlike other types, you have to @emph{construct} tables. The simplest way of doing this is like this:
@codeblock{t = @{ @}}
The 2 curley braces are the key to construct a new table. There are other ways to construct a table, these will be handled in the next sections.
@*
Another thing to remember is that variables can only @emph{point} to a table. The following example shows an error:
@codeblock
{t = @{ @}   -- Construct a new table
t2 = t    -- Copy table (ERROR)}
In this example, @code{t2} will @strong{not} be a copy of @code{t}. Instead @code{t2} will @emph{point} to the same table as @code{t} does. @*
When all references to a table are gone, for example by setting @code{t} and @code{t2} to @code{nil}, the table will be removed by Lua's garbage collector.

@subsubsection Tables Seen As An Array
As been said, tables can be used in many ways. Lets start with the @emph{array} like feature. You can see an array like a datablock. This block can expanded, indexed and traversed. Here are the usual examples:
@codeblock
{
t = @{ @} -- Construct new table
-- Create 3 table entries
t[1] = 5
t[2] = 6
t[3] = 7}
In this example the table referenced by @code{t} has 3 entries. Each are @emph{indexed} by numbers: @code{t[1]} points to 5, @code{t[2]} to 6 and @code{t[3]} to 7. Unlike languages such as C the arrays from Lua can be indexed with any type (except @code{nil}). And as usual, the data can be from any type and @code{nil} can be used to remove the data. Some more examples:
@codeblock
{t = @{ @}
t["Name"] = "Rick"
t["Phone"] = 123456789
t["Country"] = "The Netherlands"}
This time we used @code{string}s to index a table. Mixes of types can be used for indexing aswell.
@*
Usually though we use numbers only as indexes. Records (see below) are mainly used for strings. When you use numbers to index an array it's recommended to start with @samp{1} instead of @samp{0} like some other languages do. A reason for this is that most Lua functions that operate on tables (or arrays) expect that @samp{1} is the first index.

@subsubsection Table Seen As A Record
As explained in the previous section tables can be @emph{indexed}. Another way to assign data to a table is by using @emph{records}. This is the general syntax:
@codeblock{tablename.fieldname}
And an example:
@codeblock
{t = @{ @}
t.Name = "Rick"
t.Phone = 123456789
t.Country = "The Netherlands"}
Looks familiar? It's infact the same as the example shown with the array indexed by strings. In other words
@codeblock{t["field"] = 1}
is the same as
@codeblock{t.field = 1}
The reason for this alternative syntax is to have a shortcut specifically for records

@subsubsection Table Seen As A Package
Another popular way is to use tables for @emph{packages} or @emph{modules}. A good example are the Lua libraries discussed later. 
@c UNDONE
A package is basicly a record which is defined somewhere else. This record contains mostly functions and sometimes other variables. Section X describes that functions are variable types. Using that knowledge we can create a package like this:
@codeblock
{mypackage = @{ @}
mypackage.f = function()
                -- Some code
              end
mypackage.v = "Hello World"
@*
mypackage.f()    -- Call f() from mypackage}
For functions in packages Lua has a shortcut:
@codeblock
{-- Same as above
function mypackage.f()
    -- Some code
end}

@subsubsection Table Seen As A Class
Tables can also be threaded as @emph{classes}. Simply put, these are data types much like records; they have their own variables, called @emph{members} and their own functions, called @emph{methods}. Each class has to be created, mostly through another function.@*
@*
In this guide we'll skip the details about defining new classes and terms such as inheritance. Instead the only thing that is discussed is how to use them, since a few functions from the Lua Library deal with classes.@*
@*
Usually calling function methods from a class is slightly different than that from packages: with packages you used the @samp{.} operator, with classes you use the @samp{:} operator instead.@*
@*
@c UNDONE
Here follows an example using the @code{io} package from the Lua library. In section X all the IO functionality is discussed.
@codeblock
{-- The following line opens the file 'myfile.txt' for reading (specified by "r"). The io.open function returns a class that can be used to operate on the opened file.
file = io.open("myfile.txt", "r")
@*
-- One of the methods of the class is read(), using this function we can read everything from the file to a string:
text = file:read("*all")
@*
-- And when we're done, we use the close method to close the file and free the used resources:
file:close()}

@subsubsection Traversing Tables
To traverse a table we can use the @emph{generic} @code{for} loop combined with a @emph{iterator function}. The syntax looks like this:
@codeblock
{for vars in expression do
    -- Code
end}
@table @emph
@item vars
These are 1 or more variables (depending on the used iterator). Multiple variables are as usual seperated with a comma.
@item expression
Normally the iterator function
@end table
So what is a iterator function? To say it easy: when you call it, it will return the next entry of a table. It can do so because it will store its current state by each call.
@*
@c UNDONE
There are different kinds of iterators in Lua. We'll discuss 2 types here and some others are explained in section X.
@*
The first we discuss is the @code{pairs} function. This function, combined with a (generic) @code{for} loop, can traverse @emph{any} table. Here is a example:
@codeblock
{t = @{ @}
t[1] = 55
t[2] = 105
t.name = "Rick"
@*
for i,v in pairs(t) do
    print("Table entry: " .. i)
    print("Contains: " .. v)
end}
@c UNDONE
You might be wondering where @code{print} comes from. It's a Lua function which prints text to the standard output (usually a terminal). This function is discussed further in section X@*
Running the program it produces the following output:
@codeblock
{Table entry: 1
Contains: 55
Table entry: 2
Contains: 105
Table entry: name
Contains: Rick}
As you can see the first variable (@code{i}) is used to store the current index of the table. The second variable (@code{v}) is used to store the value of the current entry.
@*
The second iterator function is @code{ipairs}. This function is almost identical to @code{pairs}. The only difference is that it will @emph{only} list numeric indexes. This is useful for arrays. If we change the above example to use @code{ipairs} instead of @code{pairs} it will produce the following output:
@codeblock
{Table entry: 1
Contains: 55
Table entry: 2
Contains: 105}
As you can see it omits the @code{"name"} index. Note that, as other Lua functions, @code{ipairs} expects that @samp{1} is used as the first index for an array.

@subsubsection Table Constructers
For now we only used one way to construct tables. Another way is to assign data right away when the table is constructed. For this you can use different ways to acclompish this.
@*
The first way is specifically for arrays indexed by numbers, example:
@codeblock
{array = @{ 5, 10, "Hello World" @}}
This is equivalent to
@codeblock
{array = @{ @}
array[1] = 5
array[2] = 10
array[3] = "Hello World"}
As you see, it starts with index @samp{1}.
@*
Another way is handy for records and such:
@codeblock
{record = @{ Name="Rick", Country="The Netherlands" @}
-- or like this:
record2 = @{ "Name"="Rick", "Country"="The Netherlands" @}}
which would be equivalent to
@codeblock
{record = @{ @}
record.Name = "Rick"
record.Country = "The Netherlands"
-- or like this:
record2["Name"] = "Rick"
record2["Country"] = "The Netherlands"}
@*
Table constructors can be nested, like this:
@codeblock
{table = @{ @{5, 10@}, @{15, 20@} @}
print(table[1][1], table[1][2])   -- prints @samp{5     10}
print(table[2][1], table[2][2])   -- prints @samp{15    20}}

@subsubsection The @samp{#} operator
There is one special operator for Lua tables: the @samp{#} operator. This operator return the number of entries with a numeric index in a table. It stops counting if the next index has no value (@code{nil}).@*
Example:
@codeblock
{t = @{ 5, 10, 15 @}
print("t got " .. #t .. " elements")    -- Prints "t got 3 elements"
t[5] = 25
print("t got " .. #t .. " elements")    -- Prints "t got 3 elements", because index 4 is nil}

@subsection Variadic Functions
@emph{Variadic functions} are functions with a @emph{variable} number of arguments. Here is a example that displays how to use them:
@codeblock
{function f(...)
    for i, v in pairs(arg) do
        print("Arg " .. i .. " contains " .. v)
    end
end
@*
f("Hello", " ", "World")}
When executed, the following output is produced:
@codeblock
{Arg 1 contains Hello
Arg 2 contains
Arg 3 contains World
Arg n contains 3}
@table @emph
@item @samp{...}
This is a way to say to Lua that you don't know which arguments are to be expected.
@item arg
In variadic functions this variable is an array with all passed arguments.
@item n
As you may have noticed from the output there is also an entry called @samp{n}. This holds the total number of arguments in the array.
@end table
@*
You can also pass the arguments to another function:
@codeblock
{function f(...)
    -- Do some stuff
    @*
    print(...)    -- The print function is also variadic
end}

@section Lua Library
@c UNDONE
Now we discussed the basics of Lua we start with the Lua library. The Lua library contains many different functions. Most are inside modules (see section X). A special note for people who already know Lua: Nixstaller has lots of additional functions added to existing modules, so this section is handy to read for everyone.@*
@*
For each function a definition will be given with a description beneath. In the definition the expected arguments for this function are given aswell. Optional arguments are between square brackets, three dots (@samp{...}) means that it is a variadic function. If an argument has a default value it will be shown with @samp{=val} right next to the argument.

@subsection String Functions
In this section functions will be discussed that can modify strings, get info from strings, format strings, search strings etc. All these functions are in the @code{string} package. @*
@*
Note that strings itself are @emph{immutable}. This means that once a string is created, you cannot modify it (well you can delete it by reassigning the variable to @code{nil}). For this reason every function that will operate on strings will return a new (sub)string. Some functions use @emph{string indexes}. A string starts always at index @samp{1}. A negative index is used to start counting backwards, meaning that @samp{-1} equals to the string length, @samp{-2} equals to the string length-1 etc.

@subsubsection Basic String Functions
We start with the more easy and common functions.

@deffn Function string.byte (s [, i=1 [, j=i]])
This will return the byte codes (such as ASCII values) used from string @code{s} starting with index @code{i} till @code{j}. Byte codes can differ from platform to platform.
@end deffn

@deffn Function string.char (...)
Expects numeric arguments which are byte values (for example returned from @code{string.byte}). It will return a string consisting of each argument converted to the correspending character.@*
Example:
@codeblock
{print (string.char(string.byte("Hello World", 1, -1)))   -- Prints Hello World}
@end deffn

@deffn Function string.len (s)
Returns the length of the string @code{s}. The @samp{#} operator does the same.
@end deffn

@deffn Function string.lower (s)
Returns a lowercased version of string @code{s}. Characters that don't have a lowercased version are left alone.
@end deffn

@deffn Function string.upper (s)
Returns a uppercased version of string @code{s}. Characters that don't have an uppercased version are left alone.@*
Example:
@codeblock
{
s = "Hello World!"
print(string.lower(s))    -- Prints hello world!
print(string.upper(s))    -- Prints HELLO WORLD!}
@end deffn

@deffn Function string.rep (s, n)
Returns a string that is a copy of string @code{s} replicated @code{n} times.@*
Example:
@codeblock
{print(string.rep("A", 5))    -- Prints AAAAA}
@end deffn

@deffn Function string.reverse (s)
Returns a reversed version of string @code{s}.
@end deffn

@deffn Function string.sub (s, i [, j=-1])
Returns a @emph{substring} from string @code{s} starting at index @code{i} till index @code{j}. When @code{i} is negative it will start at the end.@*
Examples:
@codeblock
{s = "Hello World"
print(string.sub(s, 2))    -- Prints ello World
print(string.sub(s, 1, 2)) -- Prints He
print(string.sub(s, -5))   -- Prints World}
@end deffn

@deffn Function string.format (s, ...)
This functions returns a string that is formatted according to rules similar to the C functions from the @code{printf} family. The first argument should be a string which can be formatted according to some rules. These rules are specified in the form of @emph{modifiers}. These modifiers have the following syntax:
@codeblock{%[flags][width][.precision]type}

@table @samp
@item %
The first token should always be a percent sign (@samp{%}).
@item [flags]
Optional. For numeric types only. Can be one of these:
@table @samp
@item +
Used to force the usage of the @samp{+} or @samp{-} character in numbers.
@item -
When a width is given (see below) uses left alignment instead of right alignment.
@item #
Alternate form. In the authors opinion not really important. See the man pages of @code{printf} if you're interested.
@item 0
(as in zero) If a width is given (see below), it will use zeros instead of blanks for padding.
@end table
@item [width]
Optional. If a number is given it will make the converted text atleast @samp{n} wide by filling it with spaces if necessary.
@item [.precision]
Optional. Should be a number. The meaning depends on the type and is given below for each one.
@item type
This specifies what the control modifier should do and can be one of the following:
@table @samp
@item %s
Will be replaced by a string. If a precision is given it will use that as a max string length.
@item %d
@item %i
@item %u
Will be replaced by a round number. If a precision is given it will use that as a minimum digit count (adding zeros if necessary).
@item %o
Will be replaced with an octal number. If a precision is given it will use that as a minimum digit count (adding zeros if necessary).
@item %x
@item %X
Will be replaced with a hexadecimal number. Use @samp{%X} for capital characters. If a precision is given it will use that as a minimum digit count (adding zeros if necessary).
@item %e
@item %E
Will be replaced with a number with scientific notation. @samp{%E} is for a capital exponent character (@samp{E}). If a precision is specified it will use as a maximum of numbers to appear after the decimal point.
@item %f
Will be replaced by a @emph{floating point} or @emph{real} number. That is simply said a number which can contain a decimal point. If a precision is specified it will use as a maximum of numbers to appear after the decimal point.
@item %g
@item %G
The same as @samp{%e} and @samp{%E} or @samp{%f}. This depends on the given precision, which is 6 by default. If the exponent of the number is below -4 or above the precision @samp{%e} (or @samp{%E}) is used. Otherwise @samp{%f} will be used.
@item %q
Will produce a string that is @samp{safe} for Lua. This means that special characters such as newlines, quotes, backslashes etc are properly escaped.
@end table
@end table
The returned string from @code{string.format} will contain all the result(s) from the control modifier(s), at the place where the control modifier(s) orginally were placed. Each control modifier will use the next given function argument.@*
@*
To clear things up, here are some examples:
@codeblock
{name = "Rick"
age = 21
print(string.format("Hello you are %s and %d years old.", name, age))    -- Prints "Hello you are Rick and 21 years old."
f = 12.25/5.55
-- The first %f will be replaced with @samp{2.207207}, the second with @samp{2.21})
print(string.format("The result of 12.25 / 5.55 = %f or shortened: %.2f", f, f))
print(string.format("An aligned number: %3d", 5))    -- Prints "An aligned number:   5"}

@end deffn

@subsubsection Advanced String Functions
Lua has a few advanced functions to find and replace (sub)strings. For now I will skip these and just point you to the right sections: @uref{http://www.lua.org/pil/20.html,This chapter in the Lua book} and parts of the @uref{http://www.lua.org/manual/5.1/,Lua Manual}.

@subsection Table Functions
Lua has a few functions to help you when working with tables. These functions are all in the @emph{table} module.

@deffn Function table.concat (t, [, sep=""[, i=1[, j=#t]]])
Returns a string that has all elements of table @code{t} next to eachother. Each entry can be seperated by the string @code{sep}. The @code{i} and @code{j} variables are used to indicate a starting and ending index.
Examples:
@codeblock
{t = @{ "Hello", "World", "!" @}
t2 = @{ 5, 10, 15 @}
s = table.concat(t)    -- s = "HelloWorld!"
s2 = table.concat(t, " ")    -- s2 = "Hello World !"
s3 = table.concat(t2, ", ", 2)    -- s3 = "10, 15"}
@end deffn

@deffn Function table.insert (t[, p], x)
This function only works with arrays with numeric indexes. The function will insert variable @code{x} into table @code{t} at position @code{p}. When only 2 function arguments are given the second will be used as value to insert and the position will be at the end of the table.
Examples:
@codeblock
{t = @{ "Apples", "Oranges" @}
table.insert(t, 1, "Bananas")    -- t = @{ "Bananas", "Apples", "Oranges" @}
table.insert(t, "Melons")        -- t = @{ "Bananas", "Apples", "Oranges", "Melons" @}}
@end deffn

@deffn Function table.maxn (t)
This function only works with arrays that have numeric indexes. The function loops through the whole table to find the highest used index.
@end deffn

@deffn Function table.remove (t[, p=#t])
Removes the entry from table @code{t} at position @code{p}. The entry that is removed is used as return value.
Example:
@codeblock
{t = @{ 5, 10, 15 @}
table.remove(t, 1)    -- t = @{ 10, 15 @}
table.remove(t)       -- t = @{ 10 @}}
@end deffn

@deffn Function table.sort (t[, c])
Only works with arrays with numeric indexes. This function will sort all the entries from the table @code{t}. The optional argument @code{c} can be used to specify a function that is a replacement of the @samp{<} operator. This function is called to check if one table entry is smaller than another. The function recieves 2 arguments, the first and second entry, and should return @code{true} if the first entry is less than the second.
Examples:
@codeblock
{fruits = @{ "Lemon", "Apple", "Orange" @}
table.sort(fruits)    -- fruits = @{ "Apple", "Lemon", "Orange" @}
@*
function comp(e1, e2)
    return e1 > e2    -- Reversed sorting
end
@*
table.sort(fruits, comp)    -- fruits = @{ "Orange", "Lemon", "Apple" @}}
@end deffn

@subsection Math Functions
Lua supports many different math related functions through the @code{math} module. Since not many of these functions are important for Nixstaller only a few will be discussed.

@deffn Function math.abs (n)
Returns the absolute value of @code{n}
@end deffn

@deffn Function math.fmod (x, y)
Returns the modulus (remainder) of x and y.
@end deffn

@deffn Function math.max (n, ...)
Returns the biggest value from the given arguments.
@end deffn

@deffn Function math.min (n, ...)
Returns the smallest value from the given arguments.
@end deffn

@deffn Function math.random ([l[, h]])
If no arguments are given returns a @samp{random} number between 0 and 1. If @code{l} is given it will return a random number (rounded) between 1 and @code{l}. If both @code{l} and @code{h} are given it will return a random number between these values.
@end deffn

@deffn Function math.randomseed (n)
@c UNDONE
Sets the @samp{seed} for the @code{math.random} function. For each seed an unique series of numbers will be returned by the @code{math.random} function. So if the seed is always the same (ie not changed) @code{math.random} will always return the same values. To get @samp{real} random numbers a way is to set the seed to the system time when the Lua script is started. The system time can be retrieved by the @code{os.time} function, which is discussed in section X.
@end deffn

@subsection Functions That Interact With The OS
In the @code{os} package you can find functions that will handle OS specific things. Nixstaller has included some extra functions to this module.@*
@*
On failure (ie a file doesn't exist), some functions will return 2 things: @code{nil} and a string containing an error message. On success these functions will return @code{true}. With this you can easily handle errors like so:
@codeblock
{-- Function taken from internal Nixstaller code
-- (ThrowError is just a function that cleans some stuff up and calls error())
function RequiredCopy(src, dest)
    local stat, msg = os.copy(src, dest)
    if (not stat) then
        ThrowError("Error could not copy required file %s to %s: %s", src, dest, msg or "(No error message)")
    end
end}

@defvr Variable os.arch
This is a string containing the name of the current CPU architecture, such as x86 or x86_64.
@end defvr

@defvr Variable os.osname
This is a string containing the name of the current Operating System.
@end defvr

@deffn Function os.chdir (d)
Tries to change the current directory to directory @code{d}. On failure it will return @code{nil} and the error message, on success it will return @code{true}.
@end deffn

@deffn Function os.chmod (f, p)
Changes the permissions from file or directory @code{f} using the unix like permission bits taken from string @code{p}. On failure it will return @code{nil} and a string containing the error message, on success it will return @code{true}.
Example:
@codeblock
{os.chmod("mydir/", "777")    -- The directory 'mydir' has now full access for everyone}
@end deffn

@deffn Function os.clock ()
Returns the time used by the CPU in seconds.
@end deffn

@deffn Function os.copy (f[, ...], d)
Copies the file @code{f} to destination @code{d}. If @code{d} is a directory it will copy the file to that directory, if @code{d} is a file it will overwrite the contents of that file with the contents of @code{f}. You can also specify 3 or more arguments: in this case the last argument, @code{d}, should be a directory and all the previous arguments files that should be copied to this directory.
examples:
@codeblock
{os.copy("file1", os.getenv("HOME"))         -- Copies 'file1' to the users home directory
os.copy("file1", "file2")                   -- Replaces 'file2' with 'fil1'
os.copy("file1", "file2", "file3", "/tmp")  -- Copies 'file1', 'file2' and 'file3' to /tmp}
@strong{Note}: The source and destination files/directories should exist or else Lua will throw an error and abort the program.
For (other) copy failures @code{nil} and the error message will be returned. On success @code{true} is returned.
@end deffn

@deffn Function os.difftime (t2, t1)
Returns the difference in seconds from @code{t2} and @code{t1}. Mostly this is the same as @code{t2 - t1}.
@end deffn

@deffn Function os.execute (c)
@c UNDONE
Executes the shell command @code{c}. This function returns the exit code from the executed command. It's recommended to use install.execute() instead (see section X).
@end deffn

@deffn Function os.exit ([n=0])
Terminates the program with exit code @code{n}.
@end deffn

@deffn Function os.fileexists (f)
Returns @code{true} if the file or directory @code{f} exists.
@end deffn

@deffn Function os.filesize (f)
Returns the filesize in bytes of file @code{f} or @code{nil} plus the error message on failure.
@end deffn

@deffn Function os.getcwd ()
Returns a string containing the current directory. On failure it will return @code{nil} and the error message.
@end deffn

@deffn Function os.getenv (v)
Returns a string containing the value of the shell variable @code{v}. If this variable does not exists, @code{nil} will be returned.
@end deffn

@deffn Function os.isdir (f)
Returns @code{true} if @code{f} is a directory.
@end deffn

@deffn Function os.log (s, ...)
Logs the text from string @code{s} and all the function arguments after that, using @code{syslog}. You can use this function to debug for example.
@end deffn

@deffn Function os.mkdir (d[, m="0777"[, b])
Tries to create the directory @code{d}. If @code{m} is given it should be a string with the unix style permission bits. If @code{b} is @code{true} the @samp{umask} of the current system will be ignored. See the manual page of @code{umask} for details. The function will return @code{nil} and an error message on failure, on success it will return @code{true}.
Example:
@codeblock
{-- Creates directory in the users home directory with rwx access for the user only.
os.mkdir(os.getenv("HOME") .. "/.myconfig", "700")}
@end deffn

@deffn Function os.mkdirrec (d[, m="0777"[, b])
Tries to create directory @code{d} and its parent directories if non existant. @code{m} and @code{b} have the same function as with @code{os.mkdir}. Returns @code{nil} and an error message on failure, on success it will return @code{true}.
@end deffn

@deffn Function os.readperm (f)
Returns @code{true} if the file or directory @code{f} can be read.
@end deffn

@deffn Function os.remove (f)
Removes the file or directory @code{f}. Directories needs to be empty to be removed. On error it returns @code{nil} and a string containing the error message. On success @code{true} will be returned.
@end deffn

@deffn Function os.rename (f, f2)
Renames the file or directory @code{f} to @code{f2}. On error it will return @code{nil} and a string containing the error message, on success @code{true}.
@end deffn

@deffn Function os.time ()
Returns the current system time. This can for example be used as an argument for @code{math.randomseed}. There is also a second version which will put information in a table, such as the current day and month. For this see the @uref{http://www.lua.org/manual/5.1/,Lua Manual}.
@end deffn

@deffn Function os.tmpname ()
Returns a random file name which can be used for files in the @code{/tmp} directory. This only returns a filename; you still have to create it (see the io package) and remove it manually.
@end deffn

@deffn Function os.writeperm (f)
Returns @code{true} if the file or directory @code{f} has write access for the current user.
@end deffn


@subsection I/O Functions
The @code{io} package provides several Input/Output functions. As with some functions from the @code{os} package, some functions return @code{nil} and a string containing an error message on failure and @code{true} on success.@*
@*
At the first some functions of the @code{io} package will be discussed. After that the @code{file} class will be explained. Instead of adding examples for most functions, this section ends with a few bigger examples. This because most functions need eachother.

@deffn Function io.dir (d)
@c UNDONE
This function is a function iterator (see section X) that is used to scan directory @code{d}. On success the function will return a string containing the next file or directory name. On failure (ie. the directory does not exist) it will return @code{nil} and a string containing the error message.@*
Example:
@codeblock
{-- This will list every file and directory in the current directory
for d in io.dir(".") do
    print(d)
end}
@end deffn

@deffn Function io.open (f[, m="r"])
Tries to open the file @code{f}. The optional argument @code{m} defines how to open the file. This should be a string containing one of these:
@table @code
@item "r"
Opens the file in read mode. All reads start from the beginning of the file. Fails if the file doesn't exist.
@item "w"
Opens the file in write mode. If the file exists all the previous contents will be removed first. The file will be created if the file doesn't exist.
@item "r+"
Opens the file for reading and writing. The previous contents will be kept and reading/writing will start at the beginning. Fails if the file doesn't exist.
@item "w+"
Opens the file for writing and reading. The file will be cleared if it exists or created if it doesn't exist. Writing/Reading starts from the beginning.
@item "a"
Opens the file in append mode. If a file exists it the contents will be kept and writing starts from the end of the file. If the file doesn't exist it will be created.
@item "a+"
Opens the file in append and read mode. This is the same as the "a" option except that a file can be read aswell (reading also starts at the end of the file).
@end table
A @samp{b} can be appended to the mode string indicating that it's a binary file. This isn't necessary on most UNIX like systems though because binary and text files are threaded equally.@*
@*
@c UNDONE
On success, this function will return a @emph{file handle}. This is a class (see section X) with member functions to operate on the file. File handles are discussed in section X. When the file could not be opened, @code{nil} and an error message is returned.
@end deffn

@deffn Function io.popen (c[, m="r"])
@c UNDONE
This will execute the shell command @code{c} in a seperate process. The function returns a @emph{file handle} like @code{io.open} does. More on file handles in section X.@*
@*
If @code{m} is "r" all data from the command that is written to the standard output can be read. If "w" is specified the standard input from the file is linked to the data provided from writes.
@end deffn

@deffn Function io.tmpfile ()
@c UNDONE
Creates a temporary file and returns a @emph{file handle}. This file has a random name and is opened as "r+b" (see section X). On exit the file is removed automaticly.
@end deffn

@deffn Function io.type (t)
This function checks the file handle @code{f}. If the file is opened it will return the string "file", if it's closed "closed file" or @code{nil} if @code{t} is not a file handle.
@end deffn

@subsubsection File Handles
@c UNDONE
File handles are classes (see section X) that can operate on files, such as reading or writing. They are returned from @code{io.open}, @code{io.popen} and @code{io.tmpfile}. The file handle class is referred with the name @code{file} each time below.

@deffn Function file:close ()
Closes the file. When a file is closed you cannot read or write from/to it anymore. Note that each file eventually is closed automaticly.
@end deffn

@deffn Function file:flush ()
Normally writes are @emph{buffered}. This function forces to write and clean the buffer.
@end deffn

@deffn Function file:lines ()
@c UNDONE
This is an iterator function (see section X) that can be used in a generic @code{for} loop to get each line from the file. Note that the trailing newlines are deleted from the output.
@end deffn

@deffn Function file:read (...)
This file is used to read from the file. The used arguments should be one of the following formats:
@table @strong
@item "*n"
Reads a number and will return it.
@item "*a"
Reads the whole file and returns it as a string.
@item "*l"
Reads and returns (the rest of) a line, without a trailing newline.
@item A number
Reads the specified amount of bytes and returns it as a string.
@end table
If no function arguments are used, the @samp{*l} option is used. This function is variadic, so multiple formats can be specified in one call. On error @code{nil} is returned.
@end deffn

@deffn Function file:seek ([b="cur"[, o=0]])
This function can be used to set/get the current file position. This position is used to start reading or writing. The parameter @code{b} is used to specify a base location and @code{o} is a number which specifies the offset from that. @code{b} can be any of these strings:
@table @strong
@item "set"
The base is at the beginning of the file.
@item "cur"
The base starts from the current location.
@item "end"
The base starts from the end of the file.
@end table
The return value is the position after the change has been applied. So @code{file:seek("set")} will return @samp{0}, @code{file:seek("cur")} returns the current position and @code{file:seek("end")} the end position. Note that this function does not work with file handles gained from the @code{io.popen} function.
@end deffn

@deffn Function file:setvbuf (m[, s=?])
Writing to a file is @emph{buffered}. This is to gain performance. The first parameter, @code{m}, is a string which defines how to buffer:
@table @strong
@item "no"
Writes are unbuffered, meaning the data will be written immediately.
@item "full"
Writes are fully buffered, this is the default. Data will only be written when the buffer is full, @code{file:flush} is called or when the file is closed.
@item "line"
Like "full", but the data is also written after each newline.
@end table
The optional @code{s} argument specifies the buffer size in bytes. By default this is a value which suids the system the most.
@end deffn

@deffn Function file:write (...)
Writes each function argument to the file. Numbers and strings are valid argument types.
@end deffn

@subsubsection Examples
Here follow a few examples of the IO related functions that were discussed.@*
@*
@codeblock
{-- This code will open a file, read and display its contents and close it
f, msg = io.fopen("test.txt", "r")    -- f will contain the file handle, msg an error message on failure
@*
-- File could not be opened? (ie doesn't exists)
if (not f) then
    print("Could not open file: " .. msg)
    exit(1)    --- UNDONE: see section X
end
@*
print(f:read("*a"))
@*
f:close()
}
@*
Here is another example showing how to copy a file; it reads one line and writes it to a second file
@codeblock
{-- Function that copies the contents of file src to file dest
function copy(src, dest)
    local f_src = io.open(src, "r")
    local f_dest = io.open(dest, "w")
@*
    if (not f_src or not f_dest) then
        print("Error opening files")
        return
    end
@*
    for line in f_src:lines() do
        f_dest:write(line)
@*
        -- lines() will not return the trailing newline, so we have to add it manually
        f_dest:write("\\n")
    end
@*
    f_src:close()
    f_dest:close()
end}
@*
The last example is about @code{io.popen}:
@codeblock
{-- This code will execute @samp{ls -a} and print its output
cmd = io.popen("ls -a", "r")
@*
if (cmd) then
    local line = cmd:read()
    while (line) do
        print(line)
        line = cmd:read()
    end
    cmd:close()
else
    print("Could not execute command")
end
@*
This will 'open' the unix command @samp{cat} and feed it some data:
cmd = io.popen("cat", "w")
@*
if (cmd) then
    for i=1,10 do
        cmd:write("Line " .. i .. "\\n")
    end
else
    print("Could not execute command")
end}

@subsection Installation Functions
@c UNDONE
This section describes all the install related functions. They are obviously Lua extensions so you won't find them in any other Lua manual. @strong{All} these functions should only be called from the @code{install()} function. It's better to use this section as a reference after you've read chapter X.@*
@*
First all the functions from the @code{install} package are described. After that the @samp{config screen class} (used to create new installer screens) and the @samp{config menu class} (a menu class to be used in a custom install screen) are discussed. For examples of these functions you should read the tutorials (see section X).

@subsubsection The @code{install} Module

@deffn Function install.askrootpw ()
This function will ask the user to type the systems root password. Normally this is done automaticly if,
@itemize
@item @code{executeasroot()} is called,
@item when @code{install.destdir} is set to a directory which cannot be written to by the user.
@end itemize
A good reason to call this functions is when you're sure the script will execute one or more commands as root @emph{after} @code{install.extractfiles()} is called. This way the user can abort if he or she doesn't want to or cannot type the root password before the installation begins.@*
@*
When this function is called more than once it won't do anything (the password is cached).
@end deffn

@deffn Function install.execute (c[, p="/bin:/usr/bin:/usr/local/bin:/usr/X11R6/bin:."[, r=true]])
This function will execute the shell command defined by string @code{s}. With the optional argument @code{p} you can specify a value which is used to change the @code{PATH} shell variable before the command is executed. The optional argument, @code{r}, tells that the installation should be aborted when the command failed to execute.@*
@*
This function writes all the output from the command to a status window so the user can see whats happening. Because of this it's better to use this command instead of @code{os.execute}. Another reason is that @code{os.execute} will block all user input when it's called, so that for example the user cannot abort the installation without manually killing it.
@end deffn

@deffn Function install.executeasroot (c[, p="/bin:/usr/bin:/usr/local/bin:/usr/X11R6/bin:."[, r=true]])
This function does essentially the same as @code{install.execute}, but using the @code{su} command to execute it as root. When the root password is not given yet it will ask the user to do so.
@end deffn

@deffn Function install.extractfiles ()
This function will extract all installation files to the directory that was specified by the global variable @code{destdir}. This function will automaticly call @code{install.setstatus()} to notify the user that the files are extracted. Each file which was extracted is printed on the screen, and the progress bar is updated properly.
@end deffn

@deffn Function install.gettempdir ()
This function is used to assign a temporary directory the the @code{destdir} variable. Setting @code{destdir} to a temporary directory is useful for installers that need to do additional tasks with the installation files such as compilation.
@end deffn

@deffn Function install.newcfgscreen ([t])
@c UNDONE
This function will return a class for a new @emph{configuration screen}. The members of this class are described in section X. The optional argument, @code{t}, specifies a (short) title for this screen.
@end deffn

@deffn Function install.setstatus (s)
You can use this function to specify the current status of the installation. This way the user can see what the installer is doing. @*
Example:
@codeblock
{-- Somewhere inside the install() function
-- ...
install.setstatus("Copying files")
os.copy(file1, file2, "/usr/local/share")}
@end deffn

@deffn Function install.setstepcount (n=1)
This function is used to specify how many @emph{steps} the installation has, specified by parameter @code{n}. This is used to divide the progress bar and to put a text in the form of (x/X) on the screen, where @samp{x} is the current step and @samp{X} the total count of steps. On each @code{install.setstatus} call (including from @code{install.extractfiles()}) the current step will be incremented by one.
@end deffn

@subsubsection The @code{config screen} class
The class described here is returned after a call to @code{install.newcfgscreen}. The function definitions below use @samp{cfgscreen} as classname, though you should replace that name with the name of the variable that contains the class.

@deffn Function cfgscreen:addcfgmenu ([t])
@c UNDONE
Creates a new @samp{config menu}. The string parameter @code{t} sets a title. The menu is used to let the user configure certain parameters. These parameters can be paths (configured through a file manager), strings, boolean flags (can be enabled or disabled) or a list with options. The function will return a class containing function methods to add parameters, see section X for info about these.
@end deffn

@deffn Function cfgscreen:addcheckbox (t, o)
Adds a checkbox widget to the install screen. The argument @code{t} can be used to set a title (simply use "" for no title). The second argument, @code{o}, should be an array containing strings which specify the name for each option. The function will return a class with the following members (chkbox is just a name that should be replaced by the variable containing the class):
@deffn Function chkbox:get (n)
Returns @code{true} if the option from array index @code{n} is enabled or @code{false} when disabled.
@end deffn
@deffn Function chkbox:set (n, e)
If @code{e} is @code{true} the option at position @code{n} will be enabled, if @code{false} it will be disabled.
@end deffn
@end deffn

@deffn Function cfgscreen:adddirselector ([t[, d=os.getenv("HOME")]])
This function will add an inputfield which holds the current selected directory name and a button next to it which will launch a file dialog. This way the user can either select a directory by typing it or by browsing. Argument @code{t} sets an optional title and argument @code{d} sets an initial directory, defaulting to the user's home directory. The function will return a class with the following methods (where dirsel should be replaced by the actual variable name):
@deffn Function dirsel:get ()
Returns a string containing the current selected directory.
@end deffn
@deffn Function dirsel:set (d)
Sets the directory to string @code{d}.
@end deffn
@end deffn

@deffn Function cfgscreen:addinput ([t[, l[, m=1024[, v[, tp="string"]]]])
This will add an input field to the config screen. The parameter @code{t} specifies a title. @code{l} can be used to specify a label (text which is put in front of the input field). @code{m} specifies the max character count that can be typed. @code{v} specifies an initial value. The last parameter, @code{tp}, specifies the type of the inputfield and can be one of these:
@table @strong
@item "string"
The user can type any (alphanumeric) character as input.
@item "number"
The user can type any number but not fractions.
@item "float"
The user can type any number including fractions.
@end table
The function will return a class with the following method functions (input should be replaced with the actual variable name which points to this class):
@deffn Function input:get ()
Returns the current value hold by the input field.
@end deffn
@deffn Function input:setspacing (n)
This function can be used to set the distance from the windows left border to the start position of the input field. The parameter @code{n} specifies the distance, with a range from 1-100. This function is used to make sure that each input field can start from a fixed position. Normally this depends on the length of the given label. So to make sure that each input field will start at the same position on the install screen, you should call this function for every input field with the same value.
@end deffn
@end deffn

@deffn Function cfgscreen:addradiobutton (t[, o])
This function will add a radio button widget to the install screen. The parameter @code{t} specifies a title. The parameter @code{o} should be an array containing string entries with the options that can be selected. This function will return a class with the following methods (radio should be replaced by the variable that is pointing to the class):
@deffn Function radio:get ()
Returns the array index number of the option that is enabled.
@end deffn
@deffn Function radio:set (n)
Enables the option at array index @code{n}.
@end deffn
@end deffn

@subsubsection The @code{config menu} Class
@c UNDONE
This (sub)section describes the @code{config menu} class, which is created by @code{cfgscreen:addcfgmenu} (see section X). This menu is used to let the user configure various parameters through a menu. A type for these parameters is specified so that the user can change them in a logic way; file paths with a file manager, parameters with predefined options through a listbox etc.
The class contains the following methods (replace cfgmenu with the variable name pointing to the class):

@deffn Function cfgmenu:addbool (p, d[, v=false])
This function will add a parameter that can be enabled or disabled by the user. Argument @code{p} should be a @code{string} containing the name of the parameter. Argument @code{d} should be a @code{string} with a description. The optional argument @code{v} is a @code{boolean} telling the initial value: @code{true} if enabled, @code{false} when disabled.
@end deffn

@deffn Function cfgmenu:adddir (p, d[, v])
This function adds a parameter that will contain a @code{string} that holds a directory path. The user can modify this through a file browser. Argument @code{p} should be a string containing the parameter name, @code{d} a string with a description and @code{v} a string with an initial path.
@end deffn

@deffn Function cfgmenu:addlist (p, d, l)
This function adds a parameter which the user can edit with a predefined list of options. @code{p} specifies the variable name, @code{d} a description and @code{l} should be an array with strings for each option name.
@end deffn

@deffn Function cfgmenu:addstring (p, d[, v])
This function adds a parameter that can the user can modify through an input field. Argument @code{p} sets the parameter name, @code{d} the description and @code{v} should be a string with the initial value.
@end deffn

@deffn Function cfgmenu:get (p)
Returns the value from parameter @code{p}. If the type of @code{p} is a boolean, @code{true} will be returned when the parameter is enabled and @code{false} if disabled. In all other cases a @code{string} will be returned.
@end deffn


@subsection GUI Functions
@c UNDONE
There are several functions available through the @code{gui} package which interact with the user. Like the @code{install} package, all of these functions should only be called in the @code{install} function (see section X).

@deffn Function gui.choicebox (m, b1, b2[, b3])
Creates a window that will show the message identified by function argument @code{m}. @code{b1}, @code{b2} and (optionally) @code{b3} is each a string used for a button name (so the window can have 2 or 3 buttons). On failure the function will return the number of the last button (@samp{3}). On success the number of the clicked button is returned.
Examples:
@codeblock
{-- somewhere in the install() function
gui.choicebox("Could not copy file, what should I do?", "Abort", "Retry", "Ignore") -- 3 buttons
@*
-- ....
gui.choicebox("Could not execute command, what do you want?", "Ignore", "Abort") -- 2 buttons}
@end deffn

@deffn Function gui.msgbox (m, ...)
Will display a dialog with the text specified by argument @code{m}. The variadic arguments can be used to concat other texts to this message.@*
Example:
@codeblock {gui.msgbox("Thank you for downloading myapp 0.1! For updates please check www.myapp.org")}
@end deffn

@deffn Function gui.warnbox (m, ...)
The same as @code{gui.msgbox}, but used to alert the user. For example in ncurses the dialog has another color (red) and with the FLTK frontend a warning sign will be shown.
@end deffn

@deffn Function gui.yesnobox (m, ...)
This function will show a dialog with a message used from parameter @code{m} and arguments after that if available (will concat text). The dialog has a yes and a no button. If the user presses "No" @code{false} will be returned, if "Yes" @code{true} is returned.
Example:
@codeblock{-- Somewhere in install() 
if (gui.yesnobox("Do you want to install some add-ons?")) then
    -- Copy some files
end}
@end deffn

@subsection Other Functions
The last few functions are not in any package but are global functions.

@deffn Function assert (f[, ...[, m="Assert failed!"]])
This function is mainly used to debug Lua scripts. If @code{r} is @code{false} or @code{nil} this function will call @code{error} with @code{m} as argument. If @code{r} is another value the function will return @code{r} and the variadic arguments between @code{f} and @code{m} (if existant). This is mostly used in combination with functions that will return @code{nil} on error (many functions from the @code{os} package do this for example).@*
Example:
@codeblock{assert(os.rename("file1", "file2"))    -- If this function fails the script will be aborted}
@end deffn

@deffn Function dofile (f)
Executes the Lua script specified by argument @code{f}. You can use this if you want to split script files for example.@*
Example:
@codeblock
{if (os.osname == "linux") then
    dofile("linux.lua")
elseif (os.osname == "solaris") then
    dofile("solaris.lua")
else
    dofile("generic.lua")
end}
@end deffn

@deffn Function error (m[, l=1])
This function will abort the install and display an error specified by string @code{m} prefixed with the script name and line number. The optional argument, @code{l}, is used to specify the function level which is used when displaying the error: if it's @samp{0} no line number will be displayed, @samp{1} is used for the current line number (default), @samp{2} for the line number of the function that called the current function etc. @*
Example:
@codeblock
{if (not os.copy("file.txt", "somedir/")) then
    error("Could not copy file")
end}
@end deffn

@deffn Function ipairs (t)
Iterator function that can be used to traverse an array with numeric indexes. Returns 2 values: the first is the current array index and the second is the current entry at that array index. When the next entry is @code{nil}, the function will return @code{nil}. This way it will terminate a generic for loop. Argument @code{t} specifies the table to use.@*
Example:
@codeblock{t = @{ 5, 10, 15, 20 @}
for i, e in ipairs(t) do
    print(string.format("t[%d] = %d", i, e))
end}
Results in
@codeblock{t[1] = 5
t[2] = 10
t[3] = 15
t[4] = 20}
@end deffn

@deffn Function pairs (t)
As the above function as @code{ipairs} (well mostly, see the @uref{http://www.lua.org/manual/5.1, Lua manual for details}). This function also accepts other key index types than numbers.@*
Example:
@codeblock{t = @{ @}
t.name = "Rick"
t.age = 21
t.country = "The Netherlands"
for i, e in pairs(t) do
    print(string.format("t.%s = %s", i, e))
end}
Results in
@codeblock
{t.name = Rick
t.age = 21
t.country = The Netherlands}
@end deffn

@deffn Function print (s[, ...])
This function will print all the given arguments to the standard output (usually the terminal). Since the ncurses frontend already uses the terminal it will call @code{os.log} instead. This function is mainly only used for debugging, since the user probably won't notice the output.
@end deffn

@deffn Function unpack (t[, i=1[, j=#t]])
Returns each entry from table @code{t}. This table should be an array with numeric indexes. @code{i} and @code{j} specify the range to use.@*
Example:
@codeblock
{t = @{ "Hello", " ", "World" @}
print(unpack(t))    -- Prints "Hello World"}
@end deffn

@node Index
@unnumbered Index

@printindex cp

@bye
