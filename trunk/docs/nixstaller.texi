\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename nixstaller.info
@settitle Nixstaller Manual
@c %**end of header

@c @include macros.texi

@ifhtml
    @include macros-html.texi
@end ifhtml

@ifnothtml
    @include macros-default.texi
@end ifnothtml

@titlepage
@title Nixstaller 0.2 Manual
@author Rick Helmus
@end titlepage

@c Output the table of the contents at the beginning.
@contents

@ifnottex
    @node Top
    @top About
@end ifnottex

This document describes how to use Nixstaller to create installers for UNIX like systems.

Here is a short description for what you can find in this document:
@menu
* Features:: What Nixstaller can do.
* Installing:: How to install Nixstaller.
* Quickstart:: If you're in a hurry or want a quick reference.
* Basics:: Explains the basics behind Nixstaller.
* Lua Guide:: Explains the Lua scripting language.
* Index:: Complete Index
@end menu

@node Features
@chapter Features

@section Main Features
Here is a list with the main features. Read further for more info to see what they do and how to use them.

@itemize @bullet
@item 2 different frontends used for the installer: @uref{http://www.fltk.org,FLTK} and @uref{http://www.gnu.org/software/ncurses/ncurses.html,ncurses}.
@item Support for most common UNIX like systems: NetBSD(x86 and amd64), Linux(x86 and amd64), FreeBSD(x86 and amd64) and Solaris 10/Nexenta(x86).
@item An installer itself has the following features:
@itemize
@item Can be fully translated (no UTF yet). Translations for English and Dutch are supplied by default.
@item Different kind of installer screens:
@itemize
@item A screen where the user can select a language.
@item An introduction screen with an optional image and text.
@item A screen where the user can read/accept a provided license.
@item A screen where the user can select a destination directory to put the installation files.
@item A screen which shows the progress of the installation.
@item A screen which can show text after the installation.
@item A generic screen which can be made with a script.
@end itemize
Most screens are optional and can be shown in any particalur order.
@end itemize
@item Frontends are build in a way that they can be used on many different systems by linking less common libraries staticly.
@item The files can be packed with gzip-, bzip2 and lzma compression.
@item Installation files can be extracted to various directories; a temporary directory (useful for @samp{./configure && make && make install} like installers), a directory which can be selected by the user and a default directory.
@item @uref{http://www.lua.org,Lua} support is provided to configure the installer and to program the installation procedure. This allows very flexible configurations.
@end itemize

@section Changelog
@subsection 0.1 --> 0.2
@itemize
@item Lua support.
@item Support for Nexenta/Solaris 10 and AMD64 support for Linux, FreeBSD an NetBSD.
@item New manuals created by @uref{http://www.gnu.org/software/texinfo,GNU's Texinfo}.
@end itemize



@node Installing
@chapter Installing
Installing Nixstaller is easy: just extract the files to a directory and your done. All the work (ie. calling scripts) is done inside this directory.


@node Quickstart
@chapter Quickstart
@itemize
@item @ref{Installing, Install} Nixstaller.
@item Go to a terminal and @command{cd} to the directory where you extracted Nixstaller.
@item @command{cp -R example/simple/ release/}
@item Edit @file{release/config.lua} and optionally @file{release/run.lua}
@item Put some files in @file{release/files_all/} and perhaps in @file{release/files_linux_all}, @file{release/files_freebsd_x86} etc.
@item @command{./geninstall.sh release/}
@item @command{./setup.sh}
@end itemize

@c UNDONE
Also read the tutorials.

@node Basics
@chapter Basics

@section Installation package
The final product of Nixstaller is a @emph{install package}. The package itself is simply a self-extracting archive in the form of a shell script. When the package(the shell script) is executed it will extract a few files to a temporary directory and will call another script. This second script will detect a usable frontend and will call it.
A install package itself contains the following files:
@itemize
@item One or more frontends. Depending on the configuration there can be multiple frontends for different systems.
@item One or two lua scripts which tell what the installer should do.
@item Translation files. (optional)
@item Some text files used for displaying a introduction text, license info and/or a finish message. (optional)
@item An archive file containing the files to be used for the installation.
@item A script that is called when the package is extracted.
@end itemize

In the following sections these items will be further explained.

@section Frontends
The @emph{frontend} is a program from which the user can interact. When the install package is executed by the user a suitable frontend will be launched. This is determined by if X is running and which frontends are included in the package for the user's system.

Currently there are 2 frontends for Nixstaller.
@ifhtml
One is powered by @uref{http://www.fltk.org,FLTK}:

@image{fltk,,,,png}

and the other by @uref{http://www.gnu.org/software/ncurses/ncurses.html,ncurses}:

@image{ncurs,,,,png}

@end ifhtml
@ifnothtml
The first is powered by FLTK and the second is powered by ncurses.
@end ifnothtml
You can select which frontend(s) you want to include.

@section Lua scripts
@c UNDONE
The installation is controlled by one or two lua scripts. In chapter X and chapter Y. This is in detail explained.

@section Translations
The text used by the frontends can be translated via @emph{translation files}. This file is simply called @file{strings} and will contain all (English) strings used by the installer with the translation beneath them. Any line that starts with a @samp{#} will be ignored.

Currently there are already 2 translations: Dutch and English. You can find these in the @file{lang/} directory. You can 'translate' the English @file{'strings'} file in order to modify the English texts used by the installer.

Here is a example taken from the file:
@codeblock{License agreement
Licentie overeenkomst}

@samp{Licentie overeenkomst} is dutch for @samp{License agreement}. It's very important that the English text (the first line) is exactly the same as used by the installer.
If you read further in this file you will see the following sentence:
@codeblock{Installation of %s complete!
Installatie van %s gereed!}

Notice the @samp{%s}? The @samp{%s} will be replaced by the installer with another string. This can be all kind of things, in this case it is the program name. What will be replaced is usually commented in the @file{strings} file itself.


@strong{IMPORTANT}: Currently there is no UTF support yet. This means that you can't use any 'special' characters yet (such as accented characters).

@subsection Multiline translations
Some translations need more than one line. If this is the case the text should be put between 2 square brackets.
For example:
@codeblock{[
Directory does not exist
Do you want to create it?
]
[
Directory bestaat niet
Wilt u het aanmaken?
]}

If you want to put a @samp{]} in the translation itself you should put a backslash before it: @samp{\]}.

@subsection Other things that can be translated
There are other things to be translated as well:
@itemize
@item The welcome message 
@item The license agreement 
@item The 'finish message' 
@item Text used by Lua scripts
@end itemize

@c UNDONE
The first 3 items will be explained in the next section. Lua scripts will be handled in chapter X.

@section Welcome message, license agreement and the @samp{finish message}
@table @strong
@item Welcome message
This is the message that is displayed on the @samp{Introduction installscreen}.
@item License agreement
This is the text used to display the License Agreement.
@item Finish message
This is the message that is displayed after the installation has (succesfully) finished.
@end table

Each of these items are stored in plain text files. The @emph{welcome message} is in the file @file{welcome}, the @emph{license agreement} is in a file called @file{license} and the @emph{finish message} is in the file @file{finish}.
@c UNDONE
For translations of any of these texts there should be a copy of the file put in a seperate directory. Chapter X describes the file layout and mentions where to put all the files.

@node Lua Guide
@chapter Lua Guide
@section Introduction
Lua (@url{http://www.lua.org}) is used for configuring properties of the @emph{Install Package} and to control the installation process. Lua is a simple and easy to learn scripting language. In the next section a brief guide is given about Lua. Another good resource is the @uref{http://www.lua.org/pil,Lua Book}. Note that the online version describes version @emph{5.0} while Nixstaller uses @emph{5.1}. Though not much has been changed, especially not the basics.

@section Lua Basics
@subsection Comments
Lua files can contain @emph{comments}. Comments are for example used to describe pieces of code or to quickly 'disable' some code.

Some examples:
@codeblock{-- This is a comment line, comment lines always start with @samp{--}
a = b + 5     -- Comment can be after a code line aswell
-- b = b + 1   -- A 'disabled' line}

There can also be @emph{comment blocks}:
@codeblock{--[
Text between the two square brackets is comment.
This is useful if you want to write a few lines or disable multiple code lines.
--]}

@subsection Variables
To store data @emph{variables} are used. A variable name is a combination of letters, underscores and/or numbers. Note that the variable name cannot start with a number.
To create a variable you simply assign data to it. To remove a variable you assign @code{nil} to it.

@subsubsection Types
Variables are not bound to a single type(typeless, languages as C are typed). There are various types in the Lua environment:
@table @strong
@item Numbers
Numbers can be both a decimal type or a integral type. Examples:
@codeblock{a = 15
b = 1.5}
@item Strings
Strings are used to store an array of characters. The text used for a string should be either enclosed by single quotes ('') or double quotes (""). Example:
@codeblock{text1 = "Hello"}
@item Boolean
@c UNDONE
A Boolean is either @code{true} or @code{false}. They are used to enable/disable flags and test them in conditional lines. Example:
@codeblock{a = true
b = false}
@item Tables
@c UNDONE
Tables are a generic type and can be used in many different ways. See ... for a detailed explanation.
@item Functions
@c UNDONE
Functions can also be stored in variables. Section X is about functions.
@item @samp{@strong{nil}}
As said before, @code{nil} is used to delete a variable. @code{nil} is also sometimes used to indicate @samp{Nothing}. Example:
@codeblock{a = nil    -- a will now be collected by Lua's garbage collector}
@end table

@subsubsection Operators
Operators are used to operate on variables. For example to multiply 2 numbers or to add (concat) 2 strings to each other. The following table lists every operator and its function. The items are shown in order of priority.
@starttable{.25,.25,.25,.25}
@addtableheaderrow{Operator}
    @addtableheadercol{Used on}
    @addtableheadercol{Effect}
@endtablerow

@addtablerow{@code{^}}
    @addtablecol{Numbers}
    @addtablecol{Calculates the power}
@endtablerow

@c UNDONE
@addtablerow{@code{not}, @code{-}, @code{#}}
    @addtablecol{Numbers}
    @addtablecol{@code{not} returns @code{true} when a expression is false(see section X).@*
The minus in this case is the operator used for negative values.@*
The @samp{#} is used to retrieve the number of entries in a table (see section X)}
@endtablerow

@addtablerow{@code{/}, @code{*}}
    @addtablecol{Numbers}
    @addtablecol{Arithmetic operations (@abbr{resp.} divide, multiply)}
@endtablerow

@addtablerow{@code{+}, @code{-}}
    @addtablecol{Numbers}
    @addtablecol{Arithmetic operations (@abbr{resp.} add, substract)}
@endtablerow

@addtablerow{..}
    @addtablecol{Strings}
    @addtablecol{Concats 2 strings}
@endtablerow

@c UNDONE
@addtablerow{@code{>}, @code{<}, @code{>=}, @code{<=}, @code{==}, @code{~=}}
    @addtablecol{Strings, Numbers, Tables}
    @addtablecol{Used to compare values @*
See section X}
@endtablerow

@addtablerow{@code{and}}
    @addtablecol{Anything}
    @addtablecol{Checks if 2 expressions are @code{true} @*
See section X}
@endtablerow

@addtablerow{@code{or}}
    @addtablecol{Anything}
    @addtablecol{Checks if 1 of 2 expressions is @code{true} @*
See section X}
@endtablerow
@endtable

Parenthesis(@samp{()}) can be used to give an expression the highest priority.

Some examples:
@codeblock{a = 5 * 2       -- a = 10
b = 20 / 5      -- b = 4
c = (a + b) * 2 -- c = 28
d = 5^2         -- d = 25
txt1 = "Hello"
txt2 = "World"
txt = txt1 .. " ".. txt2    -- txt = "Hello World"}
Note that the @samp{..} operator can convert numbers to strings aswell:
@codeblock
{n = 5
txt = "The number is: " .. n    -- txt = "The number is: 5"}

@subsection Testing variables and values

@subsubsection Operators for testing
In lua there are a few operators to test variables and values:
@table @strong
@item <
Less than
@item >
More than
@item ==
Equal to (@strong{a single @samp{=} does not compare, just assign})
@item ~=
Unequal to
@item <=
Less or equal to
@item >=
More or equal to
@item and
Tests if 2 expressions are true
@item or
Tests if one of 2 expressions is true
@item not
Tests if a expression is not true
@end table

@c UNDONE
All of these work on @code{numbers} and @code{strings} and some might work on @code{tables} (see section X).

When a test succeeds @code{true} will be returned, when it fails @code{false} will be returned. Except for @code{or} and @code{and}. @code{or} will return the first expression if its true, otherwise the second. @code{and} will return the first expression if its false, otherwise the second.

Here are some examples:
@codeblock{a = 55
b = 100
c = a > b    -- c = false
@*
text1 = "Apple"
text2 = "Orange"
c = text1 < text2   -- c = true (alphabetical comparisation)
@*
c = 5 > 2 and "5" < "2"   -- false (second expression is false)}

As mentioned, the @code{or} and @code{and} operators will return one of the expressions. With that knowledge a nice trick can be made:
@codeblock{a = 5
b = 2
c = 6
d = 12
n = (a > b) and c or d   -- n = d(12)}
This might look a bit odd. If you're a C (or C++) programmer you may recognize this: it's similar to @code{(expr) ? a : b}. If you're not, here is what happens:
@itemize
@item @code{(a > b)}: this is false,
@item @code{... and c}: this is ignored since the previous expression was false. The first expression is returned (@code{false}).
@item @code{... or d}: The previous expression was @code{false}, so @code{or} will return @code{d} (12).
@item @code{n = ...}: @samp{12} was returned, so @code{n} is now @samp{12}.
@end itemize

@c UNDONE
If you find this confusing, you can use @code{if statements} (see section X) instead. This little trick is mainly used as a shortcut.

@subsubsection If statements
@code{if statements} are used to test some expression and if @code{true} it will execute some other code.
The general syntax is like this:
@codeblock{if expr1 then
    -- Code here for when expr1 is true
elseif expr2 then
    -- Code here for when expr2 is true and expr2 isn't
else
    -- Code here for when expr1 and expr2 are not true
end}

The @code{elseif} and @code{else} part is optional. The keyword @code{end} is used to end the @samp{if-then block}.
An expression is false when the value is @code{false} or @code{nil}. In any other case it's @code{true}.

@strong{NOTE}: In some other (scripting) languages zero (@samp{0}) and an empty @code{string} are @code{false}, however this is not the case in Lua.

Here are some examples (with comments) to illustrate some usage of if statements.
@c UNDONE
@codeblock{n = false
if n then
    -- Impossible
else
    -- Do something here
end
@*
-- This is the same as the 'and-or' trick of section X
if (a > b) then
    n = c
else
    n = d
end
@*
if (msg == "yes") and (not flag) then
    flag = true
elseif (msg == "no") and (flag) then
    flag = false
end}

@c UNDONE
@strong{Note}: I used parenthesis(@samp{()}) around some expressions and will in later examples. This is merely for clarity in most cases. In above examples the parenthesis don't have any effect. See section X for more details.

@subsection Loops
@emph{Loops} are used to execute some code lines more than once. In the following sections the different kind of loops available in Lua are explained.

@subsubsection @code{while} loops
The @code{while} loop looks like this:
@codeblock{while expr1 do
    -- Do some code
end}

As long as @samp{expr1} is not @code{false} it will execute the code in the @samp{while-do-end} block.
Here is a short example:
@codeblock
{n = 1
while (n <= 10) do
    -- Some code
@*
    n = n + 1
end}
In this example the @code{while} loop repeats itself until @code{n} is more than @samp{10}.

@subsubsection @code{repeat} loops
Another loop is the @samp{repeat-until} loop. This will repeat the code block @emph{until} some expression is @code{true}.
Example:
@codeblock
{n = 1
repeat
    -- Some code
@*
    n = n + 1
until n > 10}
This does exactly the same as the @code{while} example. So why choose @code{repeat} over @code{while}? A reason is when you want to execute the code in the block atleast once. With a @code{while} loop the expression has to be @code{true} before the loop can even begin. With the @code{repeat} - @code{until} statement however it will check the expression at the end of the block and therefore execute the code atleast once.

@subsubsection @code{for} loops
@c UNDONE
There are 2 kind of @code{for} loops: the @emph{numeric} and the @emph{generic}. We will discuss the first here, the @emph{generic} @code{for} loop will be explained in section X.

The @emph{numeric} @code{for} loop looks like this:
@codeblock
{for var=expr1,expr2,expr3 do
    -- Some code
end}

@table @emph
@item var=expr1
This will assign @emph{expr1} to the variable @code{var}. Note that this variable @strong{only} exists in the @code{for} loop.
@item expr2
As long as @emph{expr2} is unequal to @code{var} the loop repeats itself.
@item expr3
This is optional. @emph{expr3} is used to specify how much @code{var} should increment (or decrement incase a negative value is specified). If not specified it defaults to @samp{1}.
@end table

Now some examples:
@codeblock
{for n=1,10 do
    -- Some code here that will be executed 10 times
end
@*
for n=2,20,2 do
    -- Some code that will be executed 10 times. (n = incremented by 2 each time)
end}

Here are some points to remember with @code{for} loops:
@itemize
@item As been said the variable used for the loop only exists inside the loop. If you need the value outside the loop you should copy it to another variable.
@item All the three expressions are evaluated just once. This is important to know when you use functions (see section X) for an expression.
@item Do not modify the variable used by the @code{for} loop by hand.
@end itemize

@subsubsection @code{break}
@c UNDONE
To escape from a loop in Lua you can use @code{break} (or @code{return} which is handled in section X).
Here is an example:
@codeblock
{n = 1
while (true)  -- Infinite loop
    if (n == 50) then
        break -- Not infinite afterall
    end
    n = n + 1
end}
This will escape from the loop when n equals to @samp{50}.
Note that you can only use @code{break} at the end of a code block. In this case it was at the end of the @samp{if-then} block. If this wasn't the case Lua would throw an error.

@subsection Functions
@emph{Functions} are a way to create @samp{commands}. With functions a piece of code can be executed on all kinds of places.

@subsubsection Basics
Before a function can be used you have to @emph{declare} it:
@codeblock
{function funcname(args)
    -- Code
end}
@table @emph
@item funcname
This is how the function will be called.
@item args
Which @emph{arguments} or @emph{parameters} this function expects.
@end table

@subsubsection Functions arguments
Some functions may need data from the caller. To pass this data @emph{function parameters} are used. These are variables which are @emph{local} (not exist outside the function) to this function. Here is an example to acclompish this:
@codeblock
{
counter = 0
@*
function increment(n) -- Function that increments @samp{counter} by @code{n}
    counter = counter + n
end
@*
@*
increment(5)
-- counter is now 5
increment(-2)
-- counter is now 3}
You can also specify multiple function arguments: just seperate them with a comma (@samp{,}).

@c UNDONE
Functions can also have a variable number of arguments. See section X for more info.

@subsubsection Return values
When a function is called it can also return data to the caller. Here is how it generally looks:
@codeblock
{function func()
    -- Code here
    return arg1, arg2, arg3 -- etc
end}

Unlike some other language, lua has the feature to return multiple values. Here are some examples about returning values:
@codeblock
{function sum(a, b)
    return a + b
end
@*
function f()
    return "Hello", " ", "World"
end
@*
@*
n1 = 5
n2 = 10
n3 = sum(n1, n2)    -- n3 = 15
@*
str1, str2, str3 = f() -- str1 = "Hello", str2 = " ", str3 = "World"}

@subsection Local variables
For now mostly @emph{global} variables were used. There is another type of variable: the @emph{local} variable. The variable used in a numeric @code{for} loop is local, so are the function arguments. Local variables only exist in a code block (and the underlying code blocks). To create local variables you have to @emph{define} them with the @code{local} keyword. Local variables are mostly used inside functions, so that they don't corrupt the global environment.
As usual, here are some examples:
@codeblock
{function f()
    local a             -- a will only exist in this function
    local b, c          -- More variables can be defined at once
    local c, d = 5, 6   -- And can also be assigned: c = 5, d = 6
@*
    -- Some code
end
@*
count = 0    -- Global variable
@*
function g()
    local count     -- Overide count
    count = 1       -- Modify our own count
end
@*
-- count is still 0 here}
As shown above @code{local} variables can have the same name as a existing global variable. In such cases @code{local} variables have a higher priority then underlying global variables.

@section Advanced Lua
@c UNDONE
In this section some of the more advanced features of Lua will be shown. Atleast the first 2 sections of tables is important. For less advanced installers these might be enough for now.

@comment @subsection More About Functions
@comment 
@comment @subsubsection Closures
@comment @c UNDONE: Refer to Lua Book?
@comment A @emph{closure} is the concept where a function is returned by another function. Here is how it generally looks:
@comment @codeblock
@comment {function f()
@comment     -- Some code and most lickely some locals
@comment     return function()
@comment         -- Code for 'child' function 
@comment     end
@comment end}
@comment 
@comment 
@comment The function that is returned has access to all 
@comment 
@comment @subsubsection Local Functions

@subsection Functions As Variables
@c UNDONE
As said before in section X, functions are a variable type. The way we did to create functions so far is actually a shortcut to assign a function to a (global) variable:
@codeblock
{function f()
    -- ...
end}
Is essentially the same as:
@codeblock
{f = function()
    -- ...
end}

With that knowledge some interesting things can be made. @*
For example, a function can be passed to another function:
@codeblock
{function sum(a, b)
    return a + b
end
@*
x = 0
@*
function modifyx(func, val1, val2)
    x = func(val1, val2)
end
@*
modifyx(sum, 1, 1)
-- x is now 2}

Another example is to use @emph{anonymous functions}. These are, as the name suggests, functions without a name. A good reason to use them is when you want to pass (a simple) function like we did above. Here is the anonymous version:
@codeblock
{x = 0
@*
function modifyx(func, val1, val2)
    x = func(val1, val2)
end
@*
modifyx(function(a, b)
            return a + b
        end, 1, 1)
-- x is now 2}
This does essentially the same, just with a anonymous function.

@subsection Tables
Tables are generic types also called @emph{objects}. Tables can be used to create new datatypes, store blocks of data (arrays) and even for OOP(Object Orientated Programming). Not all features of tables are described. Just the few that are in the authors opinion important to know for now. A good reference for lua tables is the @uref{http://www.lua.org, Lua Book}.

@subsubsection Creating A table
Before we go in to details, lets start with how to create a table. Unlike other types, you have to @emph{construct} tables. The simplest way of doing this is like this:
@codeblock{t = @{ @}}
The 2 curley braces are the key to construct a new table. There are other ways to construct a table, these will be handled in the next sections.
@*
Another thing to remember is that variables can only @emph{point} to a table. The following example shows an error:
@codeblock
{t = @{ @}   -- Construct a new table
t2 = t    -- Copy table (ERROR)}
In this example, @code{t2} will @strong{not} be a copy of @code{t}. Instead @code{t2} will @emph{point} to the same table as @code{t} does. @*
When all references to a table are gone, for example by setting @code{t} and @code{t2} to @code{nil}, the table will be removed by Lua's garbage collector.

@subsubsection Tables Seen As An Array
As been said, tables can be used in many ways. Lets start with the @emph{array} like feature. You can see an array like a datablock. This block can expanded, indexed and traversed. Here are the usual examples:
@codeblock
{
t = @{ @} -- Construct new table
-- Create 3 table entries
t[1] = 5
t[2] = 6
t[3] = 7}
In this example the table referenced by @code{t} has 3 entries. Each are @emph{indexed} by numbers: @code{t[1]} points to 5, @code{t[2]} to 6 and @code{t[3]} to 7. Unlike languages such as C the arrays from Lua can be indexed with any type (except @code{nil}). And as usual, the data can be from any type and @code{nil} can be used to remove the data. Some more examples:
@codeblock
{t = @{ @}
t["Name"] = "Rick"
t["Phone"] = 123456789
t["Country"] = "The Netherlands"}
This time we used @code{string}s to index a table. Mixes of types can be used for indexing aswell.
@*
Usually though we use numbers only as indexes. Records (see below) are mainly used for strings. When you use numbers to index an array it's recommended to start with @samp{1} instead of @samp{0} like some other languages do. A reason for this is that most Lua functions that operate on tables (or arrays) expect that @samp{1} is the first index.

@subsubsection Table Seen As A Record
As explained in the previous section tables can be @emph{indexed}. Another way to assign data to a table is by using @emph{records}. This is the general syntax:
@codeblock{tablename.fieldname}
And an example:
@codeblock
{t = @{ @}
t.Name = "Rick"
t.Phone = 123456789
t.Country = "The Netherlands"}
Looks familiar? It's infact the same as the example shown with the array indexed by strings. In other words
@codeblock{t["field"] = 1}
is the same as
@codeblock{t.field = 1}
The reason for this alternative syntax is to have a shortcut specifically for records

@subsubsection Table Seen As A Package
Another popular way is to use tables for @emph{packages} or @emph{modules}. A good example are the Lua libraries discussed later. 
@c UNDONE
A package is basicly a record which is defined somewhere else. This record contains mostly functions and sometimes other variables. Section X describes that functions are variable types. Using that knowledge we can create a package like this:
@codeblock
{mypackage = @{ @}
mypackage.f = function()
                -- Some code
              end
mypackage.v = "Hello World"
@*
mypackage.f()    -- Call f() from mypackage}
For functions in packages Lua has a shortcut:
@codeblock
{-- Same as above
function mypackage.f()
    -- Some code
end}

@subsubsection Traversing Tables
To traverse a table we can use the @emph{generic} @code{for} loop combined with a @emph{iterator function}. The syntax looks like this:
@codeblock
{for vars in expression do
    -- Code
end}
@table @emph
@item vars
These are 1 or more variables (depending on the used iterator). Multiple variables are as usual seperated with a comma.
@item expression
Normally the iterator function
@end table
So what is a iterator function? To say it easy: when you call it, it will return the next entry of a table. It can do so because it will store its current state by each call.
@*
@c UNDONE
There are different kinds of iterators in Lua. We'll discuss 2 types here and some others are explained in section X.
@*
The first we discuss is the @code{pairs} function. This function, combined with a (generic) @code{for} loop, can traverse @emph{any} table. Here is a example:
@codeblock
{t = @{ @}
t[1] = 55
t[2] = 105
t.name = "Rick"
@*
for i,v in pairs(t) do
    print("Table entry: " .. i)
    print("Contains: " .. v)
end}
@c UNDONE
You might be wondering where @code{print} comes from. It's a Lua function which prints text to the standard output (usually a terminal). This function is discussed further in section X@*
Running the program it produces the following output:
@codeblock
{Table entry: 1
Contains: 55
Table entry: 2
Contains: 105
Table entry: name
Contains: Rick}
As you can see the first variable (@code{i}) is used to store the current index of the table. The second variable (@code{v}) is used to store the value of the current entry.
@*
The second iterator function is @code{ipairs}. This function is almost identical to @code{pairs}. The only difference is that it will @emph{only} list numeric indexes. This is useful for arrays. If we change the above example to use @code{ipairs} instead of @code{pairs} it will produce the following output:
@codeblock
{Table entry: 1
Contains: 55
Table entry: 2
Contains: 105}
As you can see it omits the @code{"name"} index. Note that, as other Lua functions, @code{ipairs} expects that @samp{1} is used as the first index for an array.

@subsubsection Table Constructers
For now we only used one way to construct tables. Another way is to assign data right away when the table is constructed. For this you can use different ways to acclompish this.
@*
The first way is specifically for arrays indexed by numbers, example:
@codeblock
{array = @{ 5, 10, "Hello World" @}}
This is equivalent to
@codeblock
{array = @{ @}
array[1] = 5
array[2] = 10
array[3] = "Hello World"}
As you see, it starts with index @samp{1}.
@*
Another way is handy for records and such:
@codeblock
{record = @{ Name="Rick", Country="The Netherlands" @}
-- or like this:
record2 = @{ "Name"="Rick", "Country"="The Netherlands" @}}
which would be equivalent to
@codeblock
{record = @{ @}
record.Name = "Rick"
record.Country = "The Netherlands"
-- or like this:
record2["Name"] = "Rick"
record2["Country"] = "The Netherlands"}
@*
Table constructors can be nested, like this:
@codeblock
{table = @{ @{5, 10@}, @{15, 20@} @}
print(table[1][1], table[1][2])   -- prints @samp{5     10}
print(table[2][1], table[2][2])   -- prints @samp{15    20}}

@subsubsection The @samp{#} operator
There is one special operator for Lua tables: the @samp{#} operator. This operator return the number of entries in a table. Example:
@codeblock
{t = @{ 5, 10, 15 @}
print("t got " .. #t .. " elements")    -- Prints 't got 3 elements'}

@subsection Variadic Functions
@emph{Variadic functions} are functions with a @emph{variable} number of arguments. Here is a example that displays how to use them:
@codeblock
{function f(...)
    for i, v in pairs(arg) do
        print("Arg " .. i .. " contains " .. v)
    end
end
@*
f("Hello", " ", "World")}
When executed, the following output is produced:
@codeblock
{Arg 1 contains Hello
Arg 2 contains
Arg 3 contains World
Arg n contains 3}
@table @emph
@item @samp{...}
This is a way to say to Lua that you don't know which arguments are to be expected.
@item arg
In variadic functions this variable is an array with all passed arguments.
@item n
As you may have noticed from the output there is also an entry called @samp{n}. This holds the total number of arguments in the array.
@end table
@*
You can also pass the arguments to another function:
@codeblock
{function f(...)
    -- Do some stuff
    @*
    print(...)    -- The print function is also variadic
end}

@section Lua Library
@c UNDONE
Now we discussed the basics of Lua we start with the Lua library. The Lua library contains many different functions. Most are inside modules (see section X). A special note for people who already know Lua: Nixstaller has lots of additional functions added to existing modules, so this section is handy to read for everyone.@*
@*
For each function a definition will be given with a description beneath. In the definition the expected arguments for this function are given aswell. Optional arguments are between square brackets, three dots (@samp{...}) means that it is a variadic function. If an argument has a default value it will be shown with @samp{=val} right next to the argument.

@subsection String Functions
In this section functions will be discussed that can modify strings, get info from strings, format strings, search strings etc. All these functions are in the @code{string} package. @*
@*
Note that strings itself are @emph{immutable}. This means that once a string is created, you cannot modify it (well you can delete it by reassigning the variable to @code{nil}). For this reason every function that will operate on strings will return a new (sub)string.

@subsubsection Basic String Functions
We start with the more easy and common functions.

@deffn Function string.byte (s [, i=1 [, j=i]])
This will return the byte codes (such as ASCII values) used from string @code{s} starting with index @code{i} till @code{j}. Byte codes can differ from platform to platform.
@end deffn

@deffn Function string.char (...)
Expects numeric arguments which are byte values (for example returned from @code{string.byte}). It will return a string consisting of each argument converted to the correspending character.@*
Example:
@codeblock
{print (string.char(string.byte("Hello World", 1, -1)))   -- Prints Hello World}
@end deffn

@deffn Function string.len (s)
Returns the length of the string @code{s}.
@end deffn

@deffn Function string.lower (s)
Returns a lowercased version of string @code{s}. Characters that don't have a lowercased version are left alone.
@end deffn

@deffn Function string.upper (s)
Returns a uppercased version of string @code{s}. Characters that don't have an uppercased version are left alone.@*
Example:
@codeblock
{
s = "Hello World!"
print(string.lower(s))    -- Prints hello world!
print(string.upper(s))    -- Prints HELLO WORLD!}
@end deffn

@deffn Function string.rep (s, n)
Returns a string that is a copy of string @code{s} replicated @code{n} times.@*
Example:
@codeblock
{print(string.rep("A", 5))    -- Prints AAAAA}
@end deffn

@deffn Function string.reverse (s)
Returns a reversed version of string @code{s}.
@end deffn

@deffn Function string.sub (s, i [, j=-1])
Returns a @emph{substring} from string @code{s} starting at index @code{i} till index @code{j}. When @code{i} is negative it will start at the end.@*
Examples:
@codeblock
{s = "Hello World"
print(string.sub(s, 2))    -- Prints ello World
print(string.sub(s, 1, 2)) -- Prints He}


@subsection Table Functions

@subsection Math Functions

@subsection Functions That Interact With The OS

@subsection I/O Functions

@subsection Installation Functions

@subsection Other Functions


@node Index
@unnumbered Index

@printindex cp

@bye
