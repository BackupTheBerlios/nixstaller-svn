\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename nixstaller.info
@settitle Nixstaller Manual
@c %**end of header

@macro luafunc{f}
@deffn Function \f\
@c @anchor{\f\}
@end macro


@macro endluafunc
@end deffn
@end macro

@titlepage
@title Nixstaller 0.3 Manual
@author Rick Helmus
@end titlepage

@c Output the table of the contents at the beginning.
@contents

@ifnottex
@node Top
@top About

This document describes how to use Nixstaller to create installers for UNIX like systems.

Here is a short description for what you can find in this document:
@menu
* Features:: What Nixstaller can do.
* Installing:: How to install Nixstaller.
* Quickstart:: If you're in a hurry or want a quick reference.
* Basics:: Explains the basics behind Nixstaller.
* Lua Scripts:: Explains how Nixstaller is scripted.
* Creating Installers:: How Installers are made.
* Tutorials:: Step by step guides for creating Installers.
* Compilation:: Info on compiling Nixstaller.
* Miscallenous:: Credits and Feedback.
* Lua Basics:: Explains the basics of the Lua scripting language.
* Lua Library Reference:: Explains Most of the Lua Library Functions, including extensions from Nixstaller.
* License:: The Nixstaller license.
* Index:: Complete Index
@end menu
@end ifnottex

@c @include macros.texi

@ifhtml
    @include macros-html.texi
@end ifhtml

@ifnothtml
    @include macros-default.texi
@end ifnothtml


@node Features
@chapter Features

@section Main Features
Here is a list with the main features. Read further for more info to see what they do and how to use them.

@itemize @bullet
@item 3 different frontends used for the installer: @uref{http://www.fltk.org,FLTK}, @uref{http://www.gnu.org/software/ncurses/ncurses.html,ncurses} and @uref{http://www.gtk.org,GTK2}.
@item Support for most common UNIX like systems: NetBSD, Linux, FreeBSD, OpenBSD and Solaris Express/Nexenta (all x86).
@item An installer itself has the following features:
@itemize @bullet
@item Can be fully translated (no UTF yet). Translations for English and Dutch are supplied by default.
@item Different kind of installer screens:
@itemize @bullet
@item A screen where the user can select a language.
@item An introduction screen with an optional image and text.
@item A screen where the user can read/accept a provided license.
@item A screen where the user can select a destination directory to put the installation files.
@item A screen which shows the progress of the installation.
@item A screen which can show text after the installation.
@item A generic screen which can be made with a script.
@end itemize
Most screens are optional and can be shown in any particalur order. New type of installation screens can be created manually.
@end itemize
@item Frontends are build in a way that they can be used on many different systems by linking less common libraries staticly.
@item The files can be packed with gzip-, bzip2 and lzma compression.
@item Installation files can be extracted to various directories; a temporary directory (useful for @samp{./configure && make && make install} like installers), a directory which can be selected by the user and a default directory.
@item @uref{http://www.lua.org,Lua} support is provided to configure the installer, create installation screens and program the installation procedure. This allows very flexible configurations.
@end itemize


@section Changelog
@subsection 0.2.2 @minus{}@minus{}> 0.3
@itemize @bullet
@item Added missing ncurses buttonbar entries.
@item Fixed about not loading in file installation screen.
@item Users can now create directories as root from directory selectors
@item SelectDirScreen can now create directories with root access
@item input:setspacing is changed to input:setlabelwidth
@item input:set function
@item checkbox:get and checkbox:set now accept strings besides numbers as arguments.
@item radiobutton:set now accepts strings as arguments aswell
@item SConstruct now works with latest SCons (0.97)
@item Preparing/copying frontend binaries message in geninstall.lua
@item --h/-h option in geninstall.sh
@item Fixed: Lua execution would stop UI updates
@item startupinstaller.sh now checks if a frontend is really launched
@item genprojdir.sh
@item startupinstaller.sh doesn't check for lzma binaries anymore when archivetype is not "lzma"
@item Fixed max intropicsize
@item files_extra/ support
@item Lua widget groups
@item FLTK layout: Logo support, screen header, white backgrounds, Xft font rendering
@item Fixed: Empty folders weren't included in installation files package
@item Fixed: Manual example code was using exit() instead of os.exit()
@item Fixed: Overide os.exit() instead of exit()
@item Track widget behaviour with customly defined widget:datachanged() and widget:verify() lua functions.
@item Control screen activation with customly defined screen:canactivate() and screen:activate() lua functions.
@item Updated to Lua 5.1.2
@item Compiled FLTK with Xdbe and Xft support
@item install.newcfgscreen() changed to install.newscreen(). Docs now mentions 'screen class' instead of 'cfgscreen class'.
@item checkbox:get() and checkbox:set() now support both string and array number as argument
@item radiobutton:set() now accepts both a string and array number as argument
@item cfgmenu:addlist() now accepts argument with initial value
@item Widgets now check arguments on bounds
@item New lua widgets: menu, image, label, progressbar and textfield
@item GTK2 frontend
@item install.getlang() function
@item Temporary lzma archives are now unpacked to temporary directory instead of destdir.
@item install.lockscreen function
@item Fixed: Several su (used for root access) bugs on OpenBSD and FreeBSD.
@item OpenBSD 4.1 support
@item NetBSD 4.X support
@item Updated vim example for vim 7.1.
@end itemize

@subsection 0.2.1 @minus{}@minus{}> 0.2.2

@itemize @bullet
@item Fixed: startupinstaller.sh would not sort files (reported by Tero Pelander).
@item Fixed: geninstall.sh didn't check given commandline arguments anymore.
@item Fixed: Missing quotes in startupinstaller.sh (reported by Tero Pelander).
@item Startup message is now read from file.
@item New way of choosing frontends: instead of trying to find available C/C++ system libraries each frontend is checked with ldd for missing libraries (suggested by Tero Pelander).
@end itemize

@subsection 0.2 @minus{}@minus{}> 0.2.1

@strong{FLTK}
@itemize @bullet
@item Fixed: Welcome and License screen would not show up if only one language was available.
@end itemize

@strong{OVERALL}
@itemize @bullet
@item Fixed: Tried to default to english incase only one language was available even if this wasn't English.
@item Fixed: Startup script wouldn't detect libstdc++ on Gentoo (reported by Edward Rudd).
@item Startup script now defaults to Linux incase no frontends are found for the current OS and defaults to x86 incase no frontends are found for the current CPU arch.
@end itemize


@subsection 0.1.1 @minus{}@minus{}> 0.2

@strong{FLTK}
@itemize @bullet
@item Fl_File_Input instead of Fl_input for directory selectors
@end itemize
@strong{ncurses}
@itemize @bullet
@item Completely new frontend code, uses ncurses++ instead of CDK.
@item Upgraded to ncurses 5.6
@end itemize

@strong{OVERALL}
@itemize @bullet
@item License change: Removed CDK exception
@item Completely new configuration via Lua 5.1.1;
@itemize @bullet
    @item Configuration is split to 2 files (config.lua and run.lua instead of install.cfg).
    @item New installation screens can be created.
    @item The order of and which installation screens can be configured.
    @item Installers can now be programmed instead of just configured.
@end itemize
@item Support for OpenBSD and Solaris Express/Nexenta
@item lzma compression support and the default is changed from gzip to lzma.
@item edelta support for 'binary diffs' (reduces size)
@item New manual, made with texinfo and texi2html
@item Directory structure: source files are moved to src/ subdirectory, Nixstaller archives have all the files in a nixstaller subdirectory.
@item Removed SCons example, added Cube and Vim examples
@item C++ library (libstdc++) is now linked dynamicly (reduces size)
@item Shell commands executed during installation are now terminated when the frontend closes.
@item C++ exception support
@item Moved many duplicate frontend code to a single library
@item Removed NetBSD 1.6.2 support
@item Removed norwegian translations (outdated)
@end itemize

@subsection 0.1 @minus{}@minus{}> 0.1.1
@itemize @bullet
@item Fixed: Ncurses frontend crashes if only 1 language is available. 
@item Fixed: geninstall.sh couldn't detect current directory with older versions of ksh. 
@item Added norwegian language support.
@end itemize



@node Installing
@chapter Installing
Installing Nixstaller is easy: just extract the files to a directory and your done. All the work (ie. calling scripts) is done inside this directory.



@node Quickstart
@chapter Quickstart
@itemize @bullet
@item @ref{Installing, Install} Nixstaller.
@item Go to a terminal and @command{cd} to the directory where you extracted Nixstaller.
@item @command{./genprojdir.sh release/}
@item Edit @file{release/config.lua} and optionally @file{release/run.lua}
@item Put some files in @file{release/files_all/} and perhaps in @file{release/files_linux_all}, @file{release/files_freebsd_x86} etc.
@item @command{./geninstall.sh release/}
@item @command{./setup.sh}
@end itemize

Also read the @ref{Tutorials, tutorials}.



@node Basics
@chapter Basics


@section Installation package
The final product of Nixstaller is an @emph{install package}. The package itself is simply a self-extracting archive in the form of a shell script. When the package (the shell script) is executed it will extract a few files to a temporary directory and will call another script. This second script will detect a usable frontend and calls it.
An install package itself contains the following files:
@itemize @bullet
@item One or more frontends. Depending on the configuration there can be multiple frontends for different systems.
@item One or two lua scripts which tell what the installer should do.
@item Translation files. (optional)
@item Some text files used for displaying a introduction text, license info and/or a finish message. (optional)
@item An archive file containing the files to be used for the installation.
@item A script that is called when the package is extracted.
@item Other files needed runtime, such as images, logos and any other files specified by the install creator. (optional)
@end itemize

The items important for the install creator are discussed in this and following chapters.


@section Frontends
The @emph{frontend} is a program from which the user can interact. When the install package is executed by the user a suitable frontend will be launched. This is determined by if X is running and which frontends are included in the package for the user's system.

Currently there are 3 frontends for Nixstaller.
@ifhtml
The first is powered by @uref{http://www.fltk.org,FLTK}:

@c @image{fltk,,,,png}
@html
<img src="fltk.png" alt="FLTK frontend picture">
@end html

The second by @uref{http://www.gnu.org/software/ncurses/ncurses.html,ncurses}:

@c @image{ncurs,,,,png}
@html
<img src="ncurs.png" alt="ncurses frontend picture">
@end html

and the third by @uref{http://www.gtk.org/,GTK2}:

@html
<img src="gtk.png" alt="gtk frontend picture">
@end html

@end ifhtml
@ifnothtml
The first is powered by FLTK, the second is powered by ncursesand the third by GTK2.
@end ifnothtml
You can select which frontend(s) you want to include.@*
@*
The ncurses frontend is text based and should run on nearly all systems. It doesn't require X and has the least dependencies.@*
@*
The FLTK frontend is a graphical frontend. Some commonly available X11 libraries are required to run. Like the ncurses frontend, the FLTK frontend has also very few dependencies and runs on many systems. @*
@*
The GTK2 frontend depends on GTK+ 2.4 or later. For this reason it may not run on every system. However, because it's dynamicly linked, it's also the smallest frontend.@*
@*
The selection of a frontend may depend on the package requirements: Is your software text based? The ncurses frontend might be enough. If your software however requires GTK2 it makes sence to only include this frontend. If size isn't a big issue you may aswell just include all the frontends and therefore increase the chance that the a suitable frontend can be found on various systems.


@section Lua scripts
The installation is controlled by one mandatory and two optional lua scripts. These are explained in the @ref{Lua Scripts} chapter.


@anchor{Translations}
@section Translations
The text used by the frontends can be translated via @emph{translation files}. Each file is simply called @file{strings} and will contain all (English) strings used by the installer with the translation beneath them. Any line that starts with a @samp{#} will be ignored.

Currently there are already 2 translations: Dutch and English. You can find these in the @file{lang/} directory. You can 'translate' the English @file{'strings'} file in order to modify the English texts used by the installer.

Here is a example taken from the file:
@codeblock{License agreement
Licentie overeenkomst}

@samp{Licentie overeenkomst} is dutch for @samp{License agreement}. It's very important that the English text (the first line) is exactly the same as used by the installer.
If you read further in this file you will see the following sentence:
@codeblock{Installation of %s complete!
Installatie van %s gereed!}

Notice the @samp{%s}? The @samp{%s} will be replaced by the installer with another string. This can be all kind of things, in this case it is the program name. What will be replaced is usually commented in the @file{strings} file itself.


@strong{IMPORTANT}: Currently there is no UTF support yet. This means that you can't use any 'special' characters yet (such as accented characters).

@subsection Multiline translations
Some translations need more than one line. If this is the case the text should be put between 2 square brackets.
For example:
@codeblock{[
Directory does not exist
Do you want to create it?
]
[
Directory bestaat niet
Wilt u het aanmaken?
]}

If you want to put a @samp{]} in the translation itself you should put a backslash before it: @samp{\]}.

@subsection Other things that can be translated
There are other things to be translated as well:
@itemize @bullet
@item The welcome message 
@item The license agreement 
@item The 'finish message' 
@item Text used by Lua scripts
@end itemize

The first 3 items will be explained in the next section. Lua scripts will be handled in the chapter @ref{Lua Scripts}.


@anchor{welcome license finish}
@section Welcome message, license agreement and the @samp{finish message}
@table @strong
@item Welcome message
This is the message that is displayed on the @samp{Introduction installscreen}.
@item License agreement
This is the text used to display the License Agreement.
@item Finish message
This is the message that is displayed after the installation has (succesfully) finished.
@end table

Each of these items are stored in plain text files. The @emph{welcome message} is in the file @file{welcome}, the @emph{license agreement} is in a file called @file{license} and the @emph{finish message} is in the file @file{finish}. For translations of any of these texts there should be a copy of the file put in a seperate directory. Chapter @ref{Creating Installers} describes the file layout and mentions where to put all the files.

@section Other files
Other files include files needed during runtime (ie when the installer is started, but not installing yet) and the files to be used during installation. Examples of runtime files are graphics such as a logo or text files that need to be displayed. The next chapter will cover how to specify these files.

@anchor{pkgmode}
@section Package Mode
Besides the @emph{regular} installation mode, Nixstaller supports an additional mode called @emph{Package Mode}.@*
@*
The main reason for using this mode is that it allows easier package managing of the software to be installed. This is accomplished by either registering the software on the users package manager system (ie. rpm) or by creating a script that is used to uninstall the software.@*
@*
Another reason is dependency handling. At this point it is very basic, but more features will be added to feature releases of Nixstaller.

@subsection How it works
The files that should be installed are placed in a special directory, the @emph{temporary package directory}. The installer will then either package these files and use the local package manager system to install them or copy them directly to their destination. Whether a package is registered or not depends on user configuration, installer configuration and if there is support for the user's package manager.@*
@*
The files are not directly placed in the destination directory, but instead are placed in a subdirectory inside the destination directory. This subdirectory is generally referred as the @emph{data directory}. Scripts will be installed to another directory, the @emph{binary directory}, that will launch an executable from the data directory. These scripts can set up an environment (usually by setting one or more shell variables) so that the executable is able run. Besides the @emph{binary scripts}, the binary directory is also used to store any uninstallation scripts. Usually the binary directory is defined within the user's @var{PATH} variable. @*
@*
The fact that seperate scripts are used to set up an environment is how the current dependency handling works. The shell variable @var{LD_LIBRARY_PATH} is used to let programs find dynamic libraries in non default directories. In these binary scripts @var{LD_LIBRARY_PATH} is set to include a subdirectory called @file{lib/} in the data directory. So to include any (dynamic library) dependencies you simply have to make sure they are placed within a subdirectory called @file{lib/} located inside the temporary package directory.@*
@*
For KDE programs the @var{KDEDIRS} shell variable can be set up to include the @emph{data directory} so that KDE programs are able to run.@*
@*
Besides @var{LD_LIBRARY_PATH} and @var{KDEDIRS} any other shell variables can be set, this is discussed in the next chapter.@*
@*
To summarize:
@itemize @bullet
@item Files to be installed are placed inside the @emph{temporary package directory}.
@item Depending on configurations and the user's system the files are being registrated into the local package manager or simply copied.
@item All the files are installed to the @emph{data directory}, which is a subdirectory inside the destination directory.
@item The user should launch any executables via @emph{binary scripts}. These scripts will set up an environment and launch the actual executable.
@item Using Package Mode the user can uninstall the software via his system's package manager or via a script (which is located inside the binary directory).
@end itemize


@section Desktop Menu Entries
Nixstaller can easily create and install so called @emph{.desktop} files that are used for menu entries on various window managers and desktop environments. The files are created according to the freedesktop specifications, more info @uref{http://standards.freedesktop.org/menu-spec/latest/,here}. When Package Mode is enabled the menu entries will be removed as soon as the user uninstalls the package. The next chapter discusses how to generate .desktop files.


@node Lua Scripts
@chapter Lua Scripts

@section Introduction
This chapter discusses how to use Lua for scripting the installer.@*
@*
The creation and behaviour of the installer is controlled by 3 Lua scripts: @file{config.lua}, @file{run.lua} and @file{package.lua}. If you're not familiar with Lua or programming in general it's recommended to read the appendix @ref{Lua Basics} or atleast keep it close.@*
@*
The appendix @ref{Lua Library Reference} is a complete reference for all the Lua functionality (including extensions from Nixstaller). You will probably want to check this after you read this and the @ref{Tutorials,,tutorials chapter}.

@anchor{config.lua}
@section First Lua Script: @file{config.lua}
The first Lua script, @file{config.lua}, is as the name says used for configuration. This file is pretty small and should only contain a few variable assignments. The variables are all in the @code{cfg} module:
@table @code
@vindex cfg.appname
@item cfg.appname
This variable is a @ref{Strings,,string} which should contain the name of your application.
@vindex cfg.archivetype
@item cfg.archivetype
This variable tells which type of compression is used for archiving the installation files. It can be one of these @ref{Strings,,strings}:
@table @code
@item "gzip"
Gzip is very fast at both compression and decompression.
@item "bzip2"
Bzip2 usually compresses better (makes the archive smaller) than gzip, but is slower and uses more memory.
@item "lzma"
LZMA compresses the best of all three. Compression is fairly slow, but decompression is rather fast.
@end table
If this variable is not specified it will default to "lzma". If you're testing your installer it might be a good idea to use "gzip" and switch to "lzma" when the installer is done. That way you have fast compression while testing and good compression for the user.
@vindex cfg.defaultlang
@item cfg.defaultlang
This variable should contain a @ref{Strings,,string} defining the default language. The default language is used to translate the language selection screen itself. The specified language can be any of the strings from the @code{languages} variable (see below). The default for this variable is "english" or the first valid language if English is not available.
@vindex cfg.frontends
@item cfg.frontends
This variable should point to an array (@pxref{Tables}) containing @ref{Strings,,strings} with the names of the frontends you want to include. Valid values are: "gtk", "fltk", "ncurses". The default is @code{@{ "gtk", "fltk", "ncurses" @}}.
@vindex cfg.intropic
@item cfg.intropic
An optional variable containing a @ref{Strings,,string} with the filename of a picture to use in the welcomescreen. Valid file formats are png, jpeg, bmp and gif. If the size is more than 300x200 px the image will be resized to fit. The file should be placed in the @file{files_extra/} directory or, for backward compatibility, in the main project directory.
@vindex cfg.languages
@item cfg.languages
An array (@pxref{Tables}) with @ref{Strings,,strings} containing the names of the languages to include for translations. The language names should be the same as the name of the subdirectories in the @file{lang/} directory from your project directory. The default is @code{@{ "english", "dutch" @}}.
@vindex cfg.logo
@item cfg.logo
An optional variable containing a @ref{Strings,,string} with the filename of a picture to use as a logo. Valid file formats are png, jpeg, bmp and gif. The file should be placed in the @file{files_extra/} directory. If unspecified a default logo is used.
@vindex cfg.targetarch
@item cfg.targetarch
A variable that should contain an array (@pxref{Tables}) of @ref{Strings,,strings} for the CPU architectures this installer should support. Nixstaller currently only supports @samp{x86} and this variable will default to this if not specified.
@vindex cfg.targetos
@item cfg.targetos
An array (@pxref{Tables}) of @ref{Strings,,strings} holding the names of the OSs (Operating Systems) which the installer should support. The OS names should be the lowercased output from the shell command @command{uname}. If not specified the variable will default to the current OS.
@end table
Here is an example @file{config.lua} file with all the above variables:
@codeblock{@minus{}@minus{} Example showing every variable
cfg.appname = "Test App"
cfg.archivetype = "gzip"
cfg.defaultlang = "english"
cfg.frontends = @{ "fltk" @}
cfg.intropic = "intro.png"
cfg.logo = "mylogo.png"
cfg.languages = @{ "english" @}
cfg.targetarch = @{ "x86" @}
cfg.targetos = @{ "sunos", "netbsd", "linux" @}}

@section Second Lua Script: @file{package.lua}
This file is only necessary when using @ref{pkgmode,,Package Mode}. Like @file{config.lua} this file is fairly simple and is only used for setting up Lua variables. All the variables are inside the @code{pkg} package. Descriptions of them are listed below.

@table @code
@item pkg.bindir
This variable should contain a @ref{Strings,,string} describing the location of the binary directory. When unspecified, a reasonable default is choosen for the user's system (mostly @file{/usr/local/bin}).
@item pkg.bins
This variable holds an array (@pxref{Tables}) with @ref{Strings,, strings} pointing to any executables, relative to the @emph{data directory}. These are used for the generation of @emph{binary scripts}.
@item pkg.description
A description of the software to be installed. Usually not longer than a few sentences.
@item pkg.destdir
A @ref{Strings,,string} containing the destination directory for the data directory. When unspecified a reasonable default is choosen for the user's system (mostly @file{/usr/local/share}).
@item pkg.group
This variable should contain a @ref{Strings,,string} describing a valid @emph{package group}. Some package managers assign to each package a package group. Nixstaller has it's own range of package groups, these are translated to a similar group from the native package manager when the package is generated. Valid groups are listed in the table below.
@starttable{.5, .5}
@addtableheaderrow{Package Group}
    @addtableheadercol{Description}
@endtablerow

@addtablerow{Archiving}
    @addtablecol{Software used for archiving data.}
@endtablerow

@addtablerow{Communication}
    @addtablecol{Software used for communication.}
@endtablerow

@addtablerow{Databases}
    @addtablecol{Software related to databases.}
@endtablerow

@addtablerow{Development-languages}
    @addtablecol{Software related to any programming language.}
@endtablerow

@addtablerow{Development-libraries}
    @addtablecol{Libraries used for development.}
@endtablerow

@addtablerow{Development-tools}
    @addtablecol{Tools that can aid in developing software.}
@endtablerow

@addtablerow{Documentation}
    @addtablecol{Anything related to documentation.}
@endtablerow

@addtablerow{Editors}
    @addtablecol{Software used for editing text.}
@endtablerow

@addtablerow{File}
    @addtablecol{Software used for file managing.}
@endtablerow

@addtablerow{Games}
    @addtablecol{Anything related to games.}
@endtablerow

@addtablerow{Graphics}
    @addtablecol{Graphics software.}
@endtablerow

@addtablerow{Libraries}
    @addtablecol{Libraries that can be used for other software.}
@endtablerow

@addtablerow{Multimedia}
    @addtablecol{Anything related to multimedia applications.}
@endtablerow

@addtablerow{Network}
    @addtablecol{Software used for networking.}
@endtablerow

@addtablerow{Perl}
    @addtablecol{Perl related software.}
@endtablerow

@addtablerow{Shells}
    @addtablecol{Commandline shells.}
@endtablerow

@addtablerow{Sound}
    @addtablecol{Anything related to sound, such as mp3 players.}
@endtablerow

@addtablerow{System}
    @addtablecol{System adminstration tools.}
@endtablerow

@addtablerow{Text}
    @addtablecol{Tools related to text processing.}
@endtablerow
@endtable

@item pkg.license
This (optional) variable should contain a @ref{Strings,,string} describing the used software license.
@item pkg.maintainer
This variable should contain a @ref{Strings,,string} describing the author's of the installer, usually with an e-mail address after that.
@item pkg.name
This variable should contain a @ref{Strings,,string} describing the name of the package to be installed. Usually this is a simple, lowercased name without spaces.
@item pkg.register
A boolean variable which tells to enable or disable package registration. When unspecified it defaults to @code{true}.
@item pkg.release
This variable contains the release version. This can be seen as the version of the installer itself. In other words it's only bumped when the installer itself has changed, but the software it's going to install is not. When unspecified it defaults to @code{1}.
@item pkg.setkdeenv
If this boolean variable is set to @code{true}, the shell variable @var{KDEDIRS} is set up so that KDE programs can be executed normally. Usually you want to enable this for any KDE software. Default: @code{false}.
@item pkg.summary
A @ref{Strings,,string} variable containing a small (not more than one line) description of the software.
@item pkg.version
This variable should contain a @ref{Strings,,string} containing the version of the software to be installed.
@item pkg.url
This (optional) variable should contain a @ref{Strings,,string} describing an URL to the software's homepage.
@end table

To define shell variables in binary scripts, the @code{pkg.addbinenv} function should be used. This function accepts three (string) arguments. The first is the name of the variable and the second the value for this variable. The third argument is optional, if specified it should contain one of the binaries specified in @code{pkg.bins}. When the third argument is specified, the given variable is only set for this binary script, otherwise the variable is set for every binary script.@*
@*
An example of usage from the previously discussed variables and the @code{pkg.addbinenv} function is shown below.
@codeblock{pkg.name = "test"
pkg.version = "1.0a"
pkg.release = "1"
pkg.maintainer = "Rick Helmus <rhelmus_AT_gmail.com>"
pkg.url = "www.rick-soft.org"
pkg.bins = @{ "bin/test" @}
pkg.license = "GPLv2"
pkg.description = [[
This package is nothing more than a test package.
The description field can contain multiple lines, as is shown here
]]
pkg.summary = "A test package"
pkg.group = "File"
pkg.destdir = "/usr/local/share"
pkg.bindir = "/usr/local/bin"
pkg.register = true
pkg.setkdeenv = false
pkg.setenv("TEST_VER", "1")}


@section Third Lua Script: @file{run.lua}
The third Lua script is used to control the installer. Although this file is optional, it's pretty common to have one. Generally speaking, the following things can be accomplished using this file:
@itemize @bullet
@item Configuring installation screens.
@item Creating new installation screens.
@item Controlling the installation process.
@end itemize

There are 2 (optional) functions that are called automaticly. The first is called @code{Init()} which is called just after the installer launches and is used for initialization. In this function you can set the destination path for the installation files and configure or create new installation screens. The second function is called @code{Install()} and is called as soon as the installation begins. This function controles the installation process.

The file layout generally looks like this:
@codeblock{function Init()
    @minus{}@minus{} Set the install destination path
    @minus{}@minus{} Create new installation screens
    @minus{}@minus{} Set which screens to use
end
@*
function Install()
    @minus{}@minus{} Do pre-install things (ie asking the root password)
    @minus{}@minus{} Extract the installation files
    @minus{}@minus{} Do post-install things (ie compile the extracted files)
end}

The above items are discussed below.

@subsection Setting the install destination path
The @code{install.destdir} variable is used to specify a destination path for the installation files. Generally there are three choices: use a static directory (ie /usr), let the user specify it through the @code{SelectDirScreen} (see below) or point it to a temporary directory. The latter is accomplished by assigning the variable to the returned path from @ref{install.gettempdir}. The main purpose for a temporary directory is that the installation files need to be used for further installation (@emph{ie} compiling).


@subsection Installation screens
As discussed before, installation screens are meant to let the user interact with the installer. You can use @emph{predefined} screens or create new screens. The following predefined screens exist:
@anchor{instscreens}
@table @code
@vindex WelcomeScreen
@item WelcomeScreen
The screen that is usually shown at first. This screen can be used to display a graphic image (defined via @code{intropic}, see @ref{config.lua}) and display an introduction message (via the @file{welcome} file, see @ref{welcome license finish, this section}). If this file doesn't exist the screen won't be displayed.
@vindex LicenseScreen
@item LicenseScreen
Is used to display a license agreement specified through the @file{license} file (see @ref{welcome license finish, this section}). If this file doesn't exist the screen won't be displayed.
@vindex SelectDirScreen
@item SelectDirScreen
This screen lets the user select a directory that will be stored in the @code{install.destdir} variable.
@vindex InstallScreen
@item InstallScreen
When this screen is shown the installation begins and displays the current status. Obviously every installer should have one.
@vindex FinishScreen
@item FinishScreen
Displays the message defined through the @file{finish} file (see @ref{welcome license finish, this section})). If this file doesn't exist the screen won't be displayed.
@end table

To tell which installation screens you want to use and in what order you should put them in the @code{install.screenlist} @ref{Tables,, table}. The screen at the first table entry is shown first, then the second entry is shown etc. By default @code{install.screenlist} contains all the predefined screens.@*
@*

@subsection Creation of new installation screens
Besides using the predefined screens, new screens can be created aswell. The primary reason for creating new screens is to let the user be able to configure certain settings which affect the installation process. To create a new screen we call the @ref{install.newscreen} function. This function accepts one optional @ref{Strings,,string} which is used to give this screen a title. The function returns a variable pointing to a @ref{Classes,,class} which we can use to modify the screen. The screen can contain several @emph{widgets}. Here is a table showing them:
@*
@starttable{.33,.33,.33}
@addtableheaderrow{Widget}
    @addtableheadercol{Description}
    @addtableheadercol{Function}
@endtablerow

@addtablerow{Check box}
    @addtablecol{One or more options that the user can enable.}
    @addtablecol{@ref{screen:addcheckbox}}
@endtablerow

@addtablerow{Config menu}
    @addtablecol{A menu that will let the user configure certain parameters in a logic way.}
    @addtablecol{@ref{screen:addcfgmenu}}
@endtablerow

@addtablerow{Directory Selector}
    @addtablecol{Adds an inputfield to specify a directory path and a button next to it to open a directory browser.}
    @addtablecol{@ref{screen:adddirselector}}
@endtablerow

@addtablerow{Image}
    @addtablecol{Shows an image file. The image is scaled if it's size is over 300x200 px. Valid file formats are: png, jpeg, gif and bmp.}
    @addtablecol{@ref{screen:addimage}}
@endtablerow

@addtablerow{Input Field}
    @addtablecol{A single line inputfield where the user can specify text.}
    @addtablecol{@ref{screen:addinput}}
@endtablerow

@addtablerow{Label}
    @addtablecol{Shows one or more lines of text.}
    @addtablecol{@ref{screen:addlabel}}
@endtablerow

@addtablerow{Menu}
    @addtablecol{A menu (or listbox) widget that lets the user select an item from a list.}
    @addtablecol{@ref{screen:addmenu}}
@endtablerow

@addtablerow{Progressbar}
    @addtablecol{Bar showing the progress of a certain process.}
    @addtablecol{@ref{screen:addprogressbar}}
@endtablerow

@addtablerow{Radiobutton}
    @addtablecol{A list of options from which the user can enable one.}
    @addtablecol{@ref{screen:addradiobutton}}
@endtablerow

@addtablerow{Textfield}
    @addtablecol{Widget that is used to show multiple lines of text. Lets the user scroll it when necessary.}
    @addtablecol{@ref{screen:addtextfield}}
@endtablerow

@endtable
For a detailed explanation of a widget see the links shown in the @samp{Function} column.@*
@*

@subsubsection Controlling and Tracking Screen Activation
By defining a @code{canactivate} function inside the screen's class we can tell if this screen is able to activate or not. When the function returns @code{false} this screen is skipped and a next screen will be checked. If the function returns @code{true} the screen will be activated, this is default behaviour.@*
@*
When an @code{activate} function is defined inside the screen's class it will be called when the screen is actually activated. Note that @code{canactivate} may be called multiple times, for this reason put any code that is required when the screen is activated in the @code{activate} function and not in the @code{canactivate} function.


@subsubsection Widget Placement
The widgets are placed vertically in order. When there is no room for a widget the screen is split into one or more @emph{subscreens}. Each subscreen has the same title as the original screen and has a @emph{counter} that shows current subscreen in the form X/Y where X is the current screen and Y the total number of subscreens. When the widget does not fit into a new subscreen or does not fit horizontally an error will be thrown. If a widget fits or not depends on each frontend and how the widget is configured. For this reason always verify the installer for each frontend!

Widgets can be horizontally grouped aswell. To do this a special @emph{group widget} needs to be created which will hold one or more widgets. The @ref{screen:addgroup} function creates a new group widget and returns a variable pointing to the group's @ref{Classes,,class}. The same functions for install screens are used to add widgets to a group widget. However these functions are called via the group's own class, @emph{ie} @code{group:addinput} (where @code{group} is a group widget variable).

@subsubsection Tracking Widget Behaviour
Commonly you may want to keep track of your widgets, for example to handle datachanges or verify user input. For this 2 functions can be defined @emph{in the widget class}. The first function, called @code{datachanged}, is called by the widget as soon as the user changes any data from the widget (@emph{ie} when the user selects a menu option). The second function, called @code{verify}, is called when the user presses the @samp{Next} button. When this function returns @code{false} the corresponding widget will get focus and the current installation screen remains active.

@subsubsection Example
An example @code{Init} function is shown below, which covers anything we just discussed.
@codeblock{@minus{}@minus{} Example run.lua file
function Init()
    install.destdir = install.gettempdir()
@*
    myscreen = install.newscreen("Hello!\\nYou can use this screen to configure some settings.")
@*
    function myscreen:canactivate()
        return true @minus{}@minus{} This is the default behaviour
    end
@*
    function myscreen:activate()
        @minus{}@minus{} Show messagebox when screen is activated
        gui.msgbox("Hello")
    end
@*
    namefield = myscreen:addinput("Your name")
@*
    function namefield:datachanged()
        @minus{}@minus{} Display messagebox as soon user changes any data from the inputfield
        gui.msgbox("Datachanged!")
    end
@*
    function namefield:verify()
        if (#namefield:get() == 0) then @minus{}@minus{} Empty string?
            gui.msgbox("Please type something")
            return false @minus{}@minus{} Don't go any further
        end
        return true @minus{}@minus{} Proceed as usual
    end
@*
    @minus{}@minus{} Group 2 widgets next to eachother
    group = myscreen:addgroup()
    check1 = group:addlabel("Left label.")
    check2 = group:addlabel("Right label.")
@*
    install.screenlist = @{ WelcomeScreen, myscreen, InstallScreen @}
done}

This function does the following things:
@itemize @bullet
@item
The @code{install.destdir} variable is set so that files are extracted to a temporary directory.
@item
A new screen is created, with the following title
@quotation
Hello!@*
You can use this screen to configure some settings.
@end quotation
@item
A @code{canactivate} and an @code{activate} function is defined for the screen. The first function tells that the screen may be displayed (this is the default and is only shown here for example usage). The second function will show a messagebox as soon as the screen is activated.
@item
An inputfield widget is created on our new screen labeled with "Your name". We define 2 functions to keep track of any datachanges and to verify if the user typed anything.
@item
Two label widgets are created and grouped next to eachother.
@item
Finally we define which screens should be shown and in which order. In our case first the welcome screen will be displayed, following by our custom screen and ending with the installation screen.
@end itemize

@subsection The installation process
By defining an @code{Install()} function we can control the installation proces. If this function is not defined a default is generated and looks like this:
@codeblock{function Install()
    install.extractfiles()
end}
The @ref{install.extractfiles} function is used to extract the installation files to the path defined by @code{install.destdir}.@*
@*
There are various Lua functions that can be used for installation. Files can be read or created with the @ref{io, io package}, there are functions that work with the OS (Operating System) of the user in the @ref{os, os package}.@*
@*
A common thing is to execute various shell commands. For this three functions are generally used:
@table
@item @ref{install.execute}
This function will execute a shell command and show all the generated output in a window.
@item @ref{install.executeasroot}
As @code{install.execute}, but using @samp{su} to execute it as the root user. If the root password is not given yet the user will be asked to type it.
@item @ref{install.askrootpw}
Asks the user to type the root password. If this has been done before the function doesn't do anything. Mostly this function is used somewhere at the beginning of the @code{Install} function so that the user knows root access is required before the installation begins and can abort if he or she wants to.
@end table

To let the user know whats happening there are three functions that can be used:
@table
@item @ref{install.print}
Displays a given string on the status window from the install screen.
@item @ref{install.setstatus}
Can be used to set a short status message on the top of the install screen.
@item @ref{install.setstepcount}
Sets how many @emph{steps} the installation has. Follow the link for more information.
@end table

To finish this section here is an example of an @code{Install()} function.
@codeblock{@minus{}@minus{} Example Install() function
function Install()
    install.setstepcount(2) @minus{}@minus{} Note that extracting files counts automaticly as one step
    install.extractfiles()
    install.setstatus("Executing random command")
    install.execute("ls -a") @minus{}@minus{} Contents of directory pointed by install.destdir variable will be displayed
@*
    @minus{}@minus{} Example of how to use data from the widget used in the example from previous section.
    gui.msgbox("Your name is: ", namefield:get())
end}

We start with defining the number of installation steps (2). Then the installation files are extracted to the directory that is defined by the @code{install.destdir} variable (see previous section). Then the status message is changed and a random shell command is executed. The last line shows how to retrieve a value with the @ref{input:get, get method function} from the inputfield class.


@subsection Package Mode
When using Package Mode, besides creating a @file{package.lua} file we have to set up a few things in @file{install.lua} aswell.

@subsubsection Temporary Package Directory
As described in the previous chapter (described @ref{pkgmode,,here}) the files to be installed need to be placed in the @emph{temporary package directory}. To retrieve the location of this directory the @code{install.getpkgdir} Lua function is used.@*
@*
For some installations it might be enough to set @code{install.destdir} to this location. The packaged files are extracted to the temporary package directory and are used directly for installation.@*
@*
@comment UNDONE
For other installations, it might be necessary to first extract any files to a different place (setting @code{install.destdir} with @code{install.gettempdir()}) and place the files to be installed in the temporary package directory later. A good example is when software has to be compiled. An example of this case is shown in tutorial 4.

@subsubsection Generating the package
After @code{install.extractfiles} is called in the @code{Install()} function inside @file{install.lua}, @code{install.generatepkg()} should be called. This function will do the actual packaging and installing of the software.@*
Note: This function should always be called @emph{after} @code{install.gendesktopentries()}.

@subsubsection Specific Installation Screens
A few predefined installation screens exist specificly for Package Mode. These are listed below.
@table @code
@item PackageToggleScreen
Lets the user enable or disable package registration (setting @code{pkg.register}). This screen is not shown incase the installer is unable to register a package.
@item PackageDirScreen
This screen lets the user specify the locations for the data and binary directory (let the user set @code{pkg.destdir} and @code{pkg.bindir}).
@item SummaryScreen
This screen is usually put just after the @code{InstallScreen}. It will show the user some info about the installed software, which files are installed and how the software can be uninstalled.
@end table
Like any other installation screens, these screens should be placed inside the @code{install.screenlist} variable.

@subsubsection Retrieving the Data and Binary directories
In some cases during installation, you may need to retrieve the real paths to the data or binary directory. For this the functions @code{pkg.getdatadir()} and @code{pkg.bindir()} exists. Both functions accept one optional (string) argument. The @code{pkg.getdatadir} function will simply combine this argument with the path of the data directory. The @code{pkg.getbindir} function use it's argument to return the path to the binary script used for the given binary (relative to the data directory). If no argument is given to one of these functions, @code{pkg.getdatadir} simply returns the path to the data directory and @code{pkg.getbindir} returns the path the binary directory.@*
@*
A good example for using these functions is for the creation and installation of desktop menu entries. This is best illustrated in an example:
@codeblock{function Init()
    @minus{}@minus{} ...
    install.menuentries["test"] = install.newdesktopentry(pkg.getbindir("bin/test"),
                                                          pkg.getdatadir("logo.png"),
                                                          "Utility")
    @minus{}@minus{} ...
end
@*
function Install()
    @minus{}@minus{} ...
    install.gendesktopentries(not os.writeperm(pkg.getdatadir()))
    @minus{}@minus{} ...
end}
At first, in the @code{Init()} function, a new desktop menu entry is created. The @code{pkg.getbindir} function is used to retrieve the location of the binary script that is used to launch @file{bin/test} inside the data directory. The @code{pkg.getdatadir} is used to retrieve the location of a logo inside the data directory.@*
After that @code{install.gendesktopentries} is called to install the desktop menu entry. To see if the entry needs to be installed globally, the write permissions of the data directory are checked. If the user cannot write to it, it is assumed the installation went with root access and therefore the package was not installed locally.


@subsection Using @samp{runtime files}
Any files that were put in the @file{extra_files/} directory can be accessed during or before the installation through the @ref{install.extrafilespath} function. This function returns a path to where you can find these files. The function accepts one optional argument containing a @ref{Strings, string} describing a filename. This filename is purely for convience and is simply appended to the returned value. Example: assuming we put a file called @file{readme.txt} in the @file{extra_files/} directory, we can access it as follows:
@codeblock{readmefilepath = install.extrafilespath("readme.txt")}

@subsection Translations
@emph{Any text} that is used by installation screens, widgets or functions indirectly using these (such as @ref{install.setstatus}) can be translated. This also includes option names from widgets such as radiobuttons or menus. Generally speaking: any text that is displayed, besides installation output, can be translated. As discussed before (@pxref{Translations}) the @file{strings} file is used to translate various strings. To translate text used from the @file{run.lua} file, simply add any strings to the @file{strings} file from the desired language in your project directory.



@node Creating Installers
@chapter Creating Installers

@section Introduction
In this chapter the creation of an installer is discussed. The previous chapters discussed Nixstaller and Lua basics. In this chapter we will use these in practise.


@section Projects
A project for an installer is nothing more than a directory with a certain file layout. This layout generally looks like this:
@itemize @bullet
    @item @file{Project Directory/}
    @itemize @bullet
        @item @file{lang/}
        @itemize @bullet
            @item @file{<language name>/}
            @itemize @bullet
                @item @file{strings}
                @item @file{welcome}
                @item @file{license}
                @item @file{finish}
            @end itemize
        @end itemize
        
        @item @file{files_all/}
        @item @file{files_<os>_all/}
        @item @file{files_all_<arch>/}
        @item @file{files_<os>_<arch>/}
        @item @file{files_extra/}

        @item @file{welcome}
        @item @file{license}
        @item @file{finish}
        
        @item @file{config.lua}
        @item @file{run.lua}
    @end itemize
@end itemize
All these files and directories except @file{config.lua} are optional.


@section The @file{lang} Directory
This directory should contain a subdirectory for every language that you want to supply for translations used by the installer. Nixstaller comes with Dutch translations and English 'translations'. The English 'translations' are used to modify English strings in Nixstaller. You can find the languages in the @file{lang/} directory from the Nixstaller directory. Simply copy these directories to your @file{lang/} directory in your project directory to include them. @*
@*
The previous chapter explained what the @file{strings} file is. Translated version of the @file{welcome}, @file{license} and @code{finish} files can be put in each language-subdirectory.


@section The @file{files_} Directories
As mentioned in the file structure above, there are 4 "@file{files_}" directory types:
@table @strong
@item @file{files_all/}
In this directory you should put all the files to be installed. These will be extracted for any OS and CPU architecture.
@item @file{files_<os>_all/}
In this directory you can put files that will only be extracted if the user's system equals to @samp{<os>}. The @samp{<os>} part should be replaced by a lowercased version from the output of @command{uname} shell command. Some examples: @file{files_linux_all/}, @file{files_sunos_all/}.
@item @file{files_all_<arch>/}
Similar to the previous item, @file{files_<os>_all/}, this directory should contain all the files that need to be installed for a CPU architecture specified by @samp{<arch>}. The @code{<arch>} part should be replaced by either @samp{x86} for Intel 32 bit compatible systems or replaced by the output from the shell command @command{uname -m}. Note that currently there are only @samp{x86} frontend binaries available.
@item @file{files_<os>_<arch>/}
A combination of the previous two. Examples: @file{files_linux_x86/}, @file{files_freebsd_x86/}.
@item @file{files_extra/}
This directory contains any files needed at runtime. Examples are graphics or text files to show. The files can be accessed with the @ref{install.extrafilespath} lua function.
@end table


@section The @file{welcome}, @file{license} and @file{finish} Files
These files were already discussed in the @ref{Basics,,basics chapter}. Simply put them in the root of your project directory.


@section The @file{config.lua} and @file{run.lua} Files
Lua scripting files were discussed in the @ref{Lua Scripts,,previous chapter}. Simply put the files in the root of the project directory.

@anchor{genprojdir.sh}
@section Automaticly Generating Project Directories
As of version 0.3, nixstaller ships a script called @file{genprojdir.sh}. This script is able to save you lot of copying by generating a project directory automaticly. The script handles the following things:
@itemize @bullet
@item Creation of a basic directory layout.
@item Language copying.
@item Copy graphics used by the @code{cfg.intropic} and @code{cfg.logo} lua variables to the right place in the project directory.
@item Generating a @file{config.lua} file based on defaults and/or commandline parameters.
@item Generate a @file{install.lua} based on defaults.
@end itemize

The script accepts the following commandline parameters:

@starttable{.5,.5}
@addtableheaderrow{Parameter}
    @addtableheadercol{Description}
@endtablerow

@addtablerownowrap{--help, -h}
    @addtablecol{Displays usage}
@endtablerow

@addtablerownowrap{--appname, -n <name>}
    @addtablecol{Sets @code{cfg.appname}. Default: MyApp}
@endtablerow

@addtablerownowrap{--arch <arch1>[, <arch2>, ...]}
    @addtablecol{Sets @code{cfg.targetarch} to one or more following arguments (<arch1>, <arch2> etc). Default: x86}
@endtablerow

@addtablerownowrap{--archtype, -a <type>}
    @addtablecol{Sets @code{cfg.archivetype} to <type>. Default: lzma.}
@endtablerow

@addtablerownowrap{--deflang, -d <lang>}
    @addtablecol{Sets @code{cfg.defaultlang} to <lang>. Default: english}
@endtablerow

@addtablerownowrap{--frontends, -f <fr1>[, <fr2>, ...]}
    @addtablecol{Sets @code{cfg.frontends} to one or more following arguments (<fr1>, <fr2> etc). Default: gtk fltk ncurses.}
@endtablerow

@addtablerownowrap{--intropic, -i <picture>}
    @addtablecol{Copies the file <picture> to the @file{extra_files/} directory and sets @code{cfg.intropic} accordingly. Default: none.}
@endtablerow

@addtablerownowrap{--languages, -l <l1>[, <l2>, ...]}
    @addtablecol{Sets @code{cfg.languages} to one or more following arguments (<l1>, <l2> etc). Default: english dutch.}
@endtablerow

@addtablerownowrap{--logo <file>}
    @addtablecol{Copies the file <logo> to the @file{extra_files/} directory and sets @code{cfg.logo} accordingly. Default: a default logo (shipped with Nixstaller).}
@endtablerow

@addtablerownowrap{--os, -o <os1>[, <os2>, ...]}
    @addtablecol{Sets @code{cfg.targetos} to one or more following arguments (<os1>, <os2> etc). Default: current OS.}
@endtablerow

@endtable

Note that this script should be called within the main Nixstaller directory.



@anchor{Creating the Installer}
@section Creating the Installer
After you have fully setup your project directory it's time to build the installer script.@*
@*
This is pretty easy and is done via a shell script. It's important to call this script from the main directory of Nixstaller. The script is called @command{geninstall.sh} and has one required argument and one optional argument. The first argument is the path to the project directory, the second is the name of the installer script. The default name is @samp{setup.sh}.@*
@*
Here is an example that shows the shell commands that need to be executed when the path to the Nixstaller directory is @file{/home/rick/nixstaller} and the project directory is at @file{/home/rick/code/setup}:
@codeblock{cd /home/rick/nixstaller
./geninstall.sh /home/rick/code/setup}
The resulting script, @samp{setup.sh}, is placed in the current directory.


@section Examples
For examples of project directory layouts see the @samp{example/} directory in the main Nixstaller directory. The @ref{Tutorials, tutorials} will also present some examples step by step.


@node Tutorials
@chapter Tutorials

@anchor{first tutorial}
@section First Tutorial: A Simple Installer
This first tutorial describes the steps that need to be done to create a simple installer.@*
@*
We want to let the installer be able to do the following things:
@itemize @bullet
@item Let the user select a language.
@item Show a short introduction message.
@item Let the user select a destination directory (or in other words, let the user define the @code{install.destdir} variable).
@item Extract the installation files to the selected directory.
@end itemize

@subsection Project Directory
To set up a project directory we use @ref{genprojdir.sh}. This script will create the directory layout for us. Assuming our project directory is called @file{setup/}, call the script like this (@emph{from the main Nixstaller directory}):
@codeblock{./genprojdir.sh -n "My Software 1.0" setup/}
This creates the project directory, including dutch translations (default) and basic Lua script files. The generated Lua scripts already tell by default that the @code{SelectDirScreen} (@pxref{instscreens, this}) should be used and that the installation files need to be extracted to the destination directory. The only thing we have to do is create an introduction message and copy the files that should be installed.

@subsection Introduction Message
Create a text file called @file{welcome} and put a text of choice in it, for example:
@quotation
This will install random software, press next to continue.
@end quotation
The file is placed in the @file{setup/} directory.

@subsection Installation Files
For this installer we simply provide one text file called @file{README}. Create the @file{README} file (put some random text in it if you want) and save it to the @file{setup/files_all/} directory.

@subsection Creating the installer
If all went fine the directory structure should look like this:
@itemize @bullet
    @item @file{setup/}
    @itemize @bullet
        @item @file{lang/}
        @itemize @bullet
            @item @file{dutch/}
            @itemize @bullet
                @item @file{strings}
            @end itemize
            @item @file{english/}
            @itemize @bullet
                @item @file{strings}
            @end itemize
        @end itemize
        @itemize @bullet
            @item @file{files_all/}
            @itemize @bullet
                @item @file{README}
            @end itemize
        @end itemize
        @item @file{files_extra/}
        @item @file{welcome}
        @item @file{config.lua}
        @item @file{run.lua}
    @end itemize
@end itemize

Now call @file{geninstall.sh} from the main Nixstaller directory and supply the project directory as first argument (@pxref{Creating the Installer}). This should supply you with an installer called @file{setup.sh}.

@section Second Tutorial: A More Advanced Installer: Cube
In this tutorial we'll be making a slightly more advanced installer for the game @uref{http://www.cubeengine.com/, Cube}. The installer has the following tasks:
@itemize @bullet
@item Run on Linux and FreeBSD systems.
@item Let the user select a language.
@item Show a short introduction message describing Cube.
@item Let the user select a destination directory.
@item Let the user choose to install a script to his or her home directory that will launch Cube.
@item Install the files and optionally create the launcher script.
@end itemize

@subsection Project Directory
Again we use @file{genprojdir.sh} to create an initial project directory. This time we will call it @samp{cube}. Here is the command: (again, call this from the main Nixstaller directory)
@codeblock{./genprojdir.sh -o freebsd linux -n Cube cube/}
We've limited the supporting operating systems to Linux and FreeBSD, simply because there are only Cube binaries for these 2 systems.@*
@*
Next create the @file{welcome} file with the following contents:
@codeblock{This installer will install Cube to your computer.
Cube is an open source FPS (First Person Shooter) which supports both single play and networked games.
Another main feature is the easy ingame map editing (online too!).}

@subsection @file{run.lua}
This time we want to edit the @file{run.lua} file. A generated version was already created. Modifying this file to our needs, it will look like this:
@codeblock{function Init()
    screen = install.newscreen("Installation options")
    scriptbox = screen:addradiobutton("Install launcher script to your home directory that launches Cube?",
                                      @{ "Yes", "No" @})
@*
    install.screenlist = @{ WelcomeScreen, SelectDirScreen, screen, InstallScreen @}
end
@*
function Install()
    install.extractfiles()
@*
    if (scriptbox:get() == "Yes") then
        local filename = string.format("%s/cube.sh", os.getenv("HOME"))
        script = io.open(filename, "w")
@*
        if (not script) then
            install.print("Failed to create launcher script")
            return @minus{}@minus{} Exit from function
        end
@*
        script:write(string.format(
[[#!/bin/sh
cd %s/cube/
./cube_unix
]], install.destdir))
        script:close()
@*
        os.chmod(filename, 700)
    end
end}

The default comments in the file are omitted, you may keep them if you want. The generated version also sets the @code{install.destdir} variable. As this is set to a default value, we don't really need it and is therefore kept out. @*
@*
First we define an @code{Init()} function. This is called when the installer starts. In this function a new installer screen is created via @ref{install.newscreen}. Then a radiobutton widget is added to this screen through the @ref{screen:addradiobutton} function. At last we define the install screens that should be used by putting them in the @code{install.screenlist} variable. Since we don't want a license or finish message shown we left these screens out.@*
@*
The second function, @code{Install()}, is called when the Installation Screen is activated. When @ref{install.extractfiles} is executed all the installation files are extracted to the directory assigned to the @code{install.destdir} variable. After that we check what the user chose from the radiobutton from our install screen. If it's @samp{"Yes"} then the script will be made. First we create the filename and assigning it to the local variable @code{filename}. Then the file is opened (and created if it doesn't exist yet). If there were no errors the script is written to file and the file is closed. Note that the @code{[[]]} block threats the part between it as a string and that newlines are automaticly included to this string (@pxref{Strings}). The @ref{os.chmod} function alters the permissions of the script file so that it can be executed.

@subsection Creating the Installer
Assuming that the project directory is called @file{cube/} the layout of this directory should look like this:

@itemize @bullet
    @item @file{cube/}
    @itemize @bullet
        @item @file{lang/}
        @itemize @bullet
            @item @file{dutch/}
            @itemize @bullet
                @item @file{strings}
            @end itemize
            @item @file{english/}
            @itemize @bullet
                @item @file{strings}
            @end itemize
        @end itemize
        @item @file{files_all/}
        @itemize @bullet
            @item @file{cube/}
            @itemize @bullet
                @item @emph{Cube files}
            @end itemize
        @end itemize
        @item @file{files_extra/}
        @item @file{welcome}
        @item @file{config.lua}
        @item @file{run.lua}
    @end itemize
@end itemize

The @file{cube/} subdirectory from the @file{files_all/} directory comes from the @file{cube_2005_08_29_unix.tar.gz} file. This file can be obtained through the @uref{http://www.cubeengine.com,Cube website}.@*
@*
Now call @file{geninstall.sh} from the Nixstaller directory, supply it with 2 arguments: the first should be the path to your project directory, the second @file{cube.sh}. After some waiting (the default lzma compression takes some time) you should now have an installer called @file{cube.sh}.

@section Third Tutorial: Installer for Vim
In the last tutorial we make a fairly advanced installer for the advanced text editor @uref{http://www.vim.org, Vim}. The installer should have the following features:
@itemize @bullet
    @item Run on every OS that Nixstaller supports (linux, freebsd, netbsd, openbsd and sunos).
    @item Let the user select a language.
    @item Show a welcome screen with the Vim logo and a short message.
    @item Let the user configure several compilation settings:
    @itemize @bullet
        @item The prefix path that is used as a base to install the files to (defaults to @file{/usr}).
        @item Which script languages to support for Vim commands.
        @item Which toolkits should be checked to use for @samp{gvim} (graphical vim).
        @item Integration support for Sun Studio, NetBeans and Sniff.
        @item Edit several environment variables that affect compilation.
    @end itemize
    @item Extract the files to a temporary directory and configure, compile and install Vim.
    @item Show the README after installation.
@end itemize

@subsection Project Directory
Again we start with creating the project directory:
@codeblock{./genprojdir.sh -i <pathtovimlogo>/vim48x48.png -o freebsd linux netbsd openbsd sunos -a "VIM 7.1" vim/}
The @samp{<pathtovimlogo>} part should be replaced to the path were the vim logo is located. The file can be found in the directory @file{vim70/runtime/} from the Vim 7 distribution.@*
@*
Next copy this text to the @file{welcome} file:
@codeblock{This installer will guide you through the installation of Vim.
After you have read the following text press the Next button to start the installation.
@*
What Is Vim?
@*
Vim is a highly configurable text editor built to enable efficient text editing. It is an improved version
of the vi editor distributed with most UNIX systems.
Vim is often called a "programmer's editor," and so useful for programming that many consider
it an entire IDE. It's not just for programmers, though. Vim is perfect for all kinds of text editing,
from composing email to editing configuration files.
@*
(From www.vim.org)}
@*
To show the README after installation we include the @samp{FinishScreen}. This screen will display the contents of a file called @file{finish} which should be placed in the project directory. Just copy the @file{README} file from the vim package to the project directory and rename it to @samp{finish}.


@subsection @file{run.lua}
Now we start with the advanced things. The file will be quite big compared to the previous tutorials. The biggest part comes from parsing the configuration options and translating them to install commands. The file will contain several functions, these are discussed one at a time.

@subsubsection Function @code{Init()}
The file starts with;
@codeblock{function Init()
    install.destdir = install.gettempdir()
@*
    screen = install.newscreen("Configuration options for Vim installation")
@*
    prefixfield = screen:adddirselector("Base destination directory for Vim. This directory will be " ..
                                           "used to populate subdirectories such as bin/ to store executables " ..
                                           "and etc/ for configuration files.", "/usr")
@*
    scriptbox = screen:addcheckbox("Vim can use several scripting languages for command interpreting. "..
                                      "Please note that the selected languages need to be installed in " ..
                                      "order to work.", @{ "MzScheme", "perl", "python", "ruby", "tcl" @})
@*
    guibox = screen:addcheckbox("Vim can use several different GUI frontends. You can specify here which " ..
                                   "toolkits can be used to find a suitable GUI. If the toolkit cannot be used " ..
                                   "it will be skipped and the next is checked.", @{ "GTK", "GTK2", "Gnome", "Motif", "Athena (XAW)", "nexTaw" @})
    guibox:set(1, 2, 3, 4, 5, 6, true)
@*
    idebox = screen:addcheckbox("Vim can be integrated in several Integrated Development Environments (IDEs). " ..
                                   "Here you can select for which you want to include support.",
                                   @{ "Sun Visual Workshop", "NetBeans", "Sniff Interface" @})
    idebox:set(2, true)
@*
    advmenu = screen:addcfgmenu("Advanced compiler options. If you don't know what these do just leave them blank.")
    advmenu:addstring("CC", "Used C compiler")
    advmenu:addstring("CFLAGS", "Custom compiler flags (ie -O2)")
    advmenu:addstring("CPPFLAGS", "Custom preprocessor flags (ie -I/usr/local/include)")
    advmenu:addstring("LDFLAGS", "Custom linker flags (ie -L/usr/local/lib)")
@*
    install.screenlist = @{ WelcomeScreen, screen, InstallScreen, FinishScreen @}
end}
Thats already some text to read :-) We start with setting the @code{install.destdir} variable to a temporary directory.@*
@*
After that a new installation screen is created and assigned to the @code{screen} variable. Then the widgets are created through the @ref{screen:addcheckbox} and @ref{screen:addcfgmenu} functions. Note that the descriptions are splitted with the @code{..} operator. This operator concatenates 2 strings and we use it purely here to make the code lines shorter. The last widget acts like a configuration menu. In this menu the user can select several parameters and edit them.@*
@*
The last line defines the install screens we want to show.

@subsubsection Function @code{getprefixconf()}
We create a new function that will return a string that is used as an argument to the @code{configure} command, which is used in the @code{Install()} function. The argument is used to set the prefix directory. Here is the function:
@codeblock{function getprefixconf()
    return string.format("@minus{}@minus{}prefix=%s", prefixfield:get())
end}

@subsubsection Function @code{getscriptconf()}
As the previous function; returns a string that is used by the @code{configure} command. This function will return the arguments related to the configuration of embedded scripting languages:
@codeblock{function getscriptconf()
    local ret = "" @minus{}@minus{} Need to initialize variable as a string, otherwise concatting it won't work
@*
    if (scriptbox:get("MzScheme")) then
        ret = ret .. "@minus{}@minus{}enable-MzScheme "
    end
    if (scriptbox:get("perl")) then
        ret = ret .. "@minus{}@minus{}enable-perl "
    end
    if (scriptbox:get("python")) then
        ret = ret .. "@minus{}@minus{}enable-python "
    end
    if (scriptbox:get("ruby")) then
        ret = ret .. "@minus{}@minus{}enable-ruby "
    end
    if (scriptbox:get("tcl")) then
        ret = ret .. "@minus{}@minus{}enable-tcl "
    end
@*
    return ret
end}
The first line is important: Lua needs to know that a variable is used as a string, otherwise the concat operator(@code{..}) won't work. Simply assigning an empty string will do the job. Another important thing to notice is the trailing space from the concatenated strings: this makes it easier to construct one string from various function calls (which is done later).@*
@*
As an example, if the user enabled @samp{perl} and @samp{ruby} then the function would return this string: "@minus{}@minus{}enable-perl @minus{}@minus{}enable ruby ".

@subsubsection Function @code{getguiconf()}
This function is very similar to the previous function, but returns a string to be used for toolkit configuration that is used for @samp{gvim} (graphical vim). Here is the code:
@codeblock{function getguiconf()
    local ret = ""
@*
    if (not guibox:get("GTK")) then
        ret = ret .. "@minus{}@minus{}disable-gtk-check "
    end
    if (not guibox:get("GTK2")) then
        ret = ret .. "@minus{}@minus{}disable-gtk2-check "
    end
    if (not guibox:get("Gnome")) then
        ret = ret .. "@minus{}@minus{}disable-gnome-check "
    end
    if (not guibox:get("Athena (XAW)")) then
        ret = ret .. "@minus{}@minus{}disable-athena-check "
    end
    if (not guibox:get("nexTaw")) then
        ret = ret .. "@minus{}@minus{}disable-nextaw-check "
    end
@*
    return ret
end}
Note that we check if an option is disabled instead of enabled. This is because these options are enabled by default.

@subsubsection Function @code{getideconf()}
This function, similar to the previous 2, is used to get a string to be used for IDE integration:
@codeblock{function getideconf()
    local ret = ""
@*
    if (idebox:get("Sun Visual Workshop")) then
        ret = ret .. "@minus{}@minus{}enable-workshop "
    end
    if (not idebox:get("NetBeans")) then
        ret = ret .. "@minus{}@minus{}disable-netbeans "
    end
    if (idebox:get("Sniff Interface")) then
        ret = ret .. "@minus{}@minus{}enable-sniff "
    end
@*
    return ret
end}

@subsubsection Function @code{getconfigureopts()}
This function returns the string that should be given as a shell argument to the @code{configure} command. The function uses the previous three functions, seperated by a space, to form the right string. This is the function:
@codeblock{function getconfigureopts()
    return getprefixconf() .. " " .. getscriptconf() .. " " .. getguiconf() .. " " .. getideconf()
end}

@subsubsection Function @code{handleadvmenu()}
This function will set several shell environment variables that can be configured through the @samp{Advanced compilation options} menu. Before a variable is set, it will be checked if the user didn't leave it blank. This is done because if the environment variable was already set (ie because the user set it in the shell from where the installer was executed) it would be cleared otherwise. Here is the function code:
@codeblock{function handleadvmenu()
    if (#advmenu:get("CC") > 0) then
        os.setenv("CC", advmenu:get("CC"))
    end
    if (#advmenu:get("CFLAGS") > 0) then
        os.setenv("CFLAGS", advmenu:get("CFLAGS"))
    end
    if (#advmenu:get("CPPFLAGS") > 0) then
        os.setenv("CPPFLAGS", advmenu:get("CPPFLAGS"))
    end
    if (#advmenu:get("LDFLAGS") > 0) then
        os.setenv("LDFLAGS", advmenu:get("LDFLAGS"))
    end
end}
The length operator, @samp{#}, is used to get the string length from each variable. If it's more than zero than the string isn't blank and it is used to set the environment variable.

@subsubsection Function @code{Install()}
The last function will do the actual installation. Here is how it looks like:
@codeblock{function Install()
    local prefix = prefixfield:get()
    handleadvmenu()
@*
    @minus{}@minus{} 1: Extracting Files (Automaticly set by install.extractfiles)
    @minus{}@minus{} 2: ./configure
    @minus{}@minus{} 3: make
    @minus{}@minus{} 4: make install
    install.setstepcount(4)
@*
    if (os.writeperm(prefix) == false) then
        install.askrootpw()
    end
@*
    install.extractfiles()
    os.chdir("vim70/")
@*
    install.setstatus("Configuring Vim for this system")
    install.execute(string.format("./configure %s", getconfigureopts()))
@*
    install.setstatus("Compiling Vim")
    install.execute("make")
@*
    install.setstatus("Installing files")
    if (os.writeperm(prefix) == false) then
        install.executeasroot("make install")
    else
        install.execute("make install")
    end
end}

At first the prefix directory is stored to the local @code{prefix} variable.@*
@*
After that the options from the @samp{Advanced compilation options} menu are processed.@*
@*
Then the stepcount is set. Each step is documented by the comments shown above the @ref{install.setstepcount} function.@*
@*
Then we check if we got write access to the prefix directory. If not we need root access later and we ask the password here.@*
@*
After the files are extracted through the @ref{install.extractfiles} function we change directory to the @file{vim70/} directory. The status message is changed so that the user knows whats going on and the @code{configure} command is executed with the right arguments.@*
@*
After configuration, @code{make} is called to start the compilation and the status message is changed again.@*
@*
After @code{make} is done the install process is started. If the prefix directory is write protected for the current user we call @code{make install} as root, otherwise it's executed as the current user.

@subsubsection Everything Put Together
The @file{run.lua} file is now completely discussed and should look like this:
@codeblock{function Init()
    install.destdir = install.gettempdir()
@*
    screen = install.newscreen("Configuration options for Vim installation")
@*
    prefixfield = screen:adddirselector("Base destination directory for Vim. This directory will be " ..
                                           "used to populate subdirectories such as bin/ to store executables " ..
                                           "and etc/ for configuration files.", "/usr")
@*
    scriptbox = screen:addcheckbox("Vim can use several scripting languages for command interpreting. "..
                                      "Please note that the selected languages need to be installed in " ..
                                      "order to work.", @{ "MzScheme", "perl", "python", "ruby", "tcl" @})
@*
    guibox = screen:addcheckbox("Vim can use several different GUI frontends. You can specify here which " ..
                                   "toolkits can be used to find a suitable GUI. If the toolkit cannot be used " ..
                                   "it will be skipped and the next is checked.", @{ "GTK", "GTK2", "Gnome", "Motif", "Athena (XAW)", "nexTaw" @})
    guibox:set(1, 2, 3, 4, 5, 6, true)
@*
    idebox = screen:addcheckbox("Vim can be integrated in several Integrated Development Environments (IDEs). " ..
                                   "Here you can select for which you want to include support.",
                                   @{ "Sun Visual Workshop", "NetBeans", "Sniff Interface" @})
    idebox:set(2, true)
@*
    advmenu = screen:addcfgmenu("Advanced compiler options. If you don't know what these do just leave them blank.")
    advmenu:addstring("CC", "Used C compiler")
    advmenu:addstring("CFLAGS", "Custom compiler flags (ie -O2)")
    advmenu:addstring("CPPFLAGS", "Custom preprocessor flags (ie -I/usr/local/include)")
    advmenu:addstring("LDFLAGS", "Custom linker flags (ie -L/usr/local/lib)")
@*
    install.screenlist = @{ WelcomeScreen, screen, InstallScreen, FinishScreen @}
end
@*
function getprefixconf()
    return string.format("@minus{}@minus{}prefix=%s", prefixfield:get())
end
@*
function getscriptconf()
    local ret = "" @minus{}@minus{} Need to initialize variable as a string, otherwise concatting it won't work
@*
    if (scriptbox:get("MzScheme")) then
        ret = ret .. "@minus{}@minus{}enable-MzScheme "
    end
    if (scriptbox:get("perl")) then
        ret = ret .. "@minus{}@minus{}enable-perl "
    end
    if (scriptbox:get("python")) then
        ret = ret .. "@minus{}@minus{}enable-python "
    end
    if (scriptbox:get("ruby")) then
        ret = ret .. "@minus{}@minus{}enable-ruby "
    end
    if (scriptbox:get("tcl")) then
        ret = ret .. "@minus{}@minus{}enable-tcl "
    end
@*
    return ret
end
@*
function getguiconf()
    local ret = ""
@*
    if (not guibox:get("GTK")) then
        ret = ret .. "@minus{}@minus{}disable-gtk-check "
    end
    if (not guibox:get("GTK2")) then
        ret = ret .. "@minus{}@minus{}disable-gtk2-check "
    end
    if (not guibox:get("Gnome")) then
        ret = ret .. "@minus{}@minus{}disable-gnome-check "
    end
    if (not guibox:get("Athena (XAW)")) then
        ret = ret .. "@minus{}@minus{}disable-athena-check "
    end
    if (not guibox:get("nexTaw")) then
        ret = ret .. "@minus{}@minus{}disable-nextaw-check "
    end
@*
    return ret
end
@*
function getideconf()
    local ret = ""
@*
    if (idebox:get("Sun Visual Workshop")) then
        ret = ret .. "@minus{}@minus{}enable-workshop "
    end
    if (not idebox:get("NetBeans")) then
        ret = ret .. "@minus{}@minus{}disable-netbeans "
    end
    if (idebox:get("Sniff Interface")) then
        ret = ret .. "@minus{}@minus{}enable-sniff "
    end
@*
    return ret
end
@*
function getconfigureopts()
    return getprefixconf() .. " " .. getscriptconf() .. " " .. getguiconf() .. " " .. getideconf()
end
@*
function handleadvmenu()
    if (#advmenu:get("CC") > 0) then
        os.setenv("CC", advmenu:get("CC"))
    end
    if (#advmenu:get("CFLAGS") > 0) then
        os.setenv("CFLAGS", advmenu:get("CFLAGS"))
    end
    if (#advmenu:get("CPPFLAGS") > 0) then
        os.setenv("CPPFLAGS", advmenu:get("CPPFLAGS"))
    end
    if (#advmenu:get("LDFLAGS") > 0) then
        os.setenv("LDFLAGS", advmenu:get("LDFLAGS"))
    end
end
@*
function Install()
    local prefix = prefixfield:get()
    handleadvmenu()
@*
    @minus{}@minus{} 1: Extracting Files (Automaticly set by install.extractfiles)
    @minus{}@minus{} 2: ./configure
    @minus{}@minus{} 3: make
    @minus{}@minus{} 4: make install
    install.setstepcount(4)
@*
    if (os.writeperm(prefix) == false) then
        install.askrootpw()
    end
@*
    install.extractfiles()
    os.chdir("vim70/")
@*
    install.setstatus("Configuring Vim for this system")
    install.execute(string.format("./configure %s", getconfigureopts()))
@*
    install.setstatus("Compiling Vim")
    install.execute("make")
@*
    install.setstatus("Installing files")
    if (os.writeperm(prefix) == false) then
        install.executeasroot("make install")
    else
        install.execute("make install")
    end
end}

@subsection Creating the Installer
The project directory should have the following structure:

@itemize @bullet
    @item @file{vim/}
    @itemize @bullet
        @item @file{lang/}
        @itemize @bullet
            @item @file{dutch/}
            @itemize @bullet
                @item @file{strings}
            @end itemize
            @item @file{english/}
            @itemize @bullet
                @item @file{strings}
            @end itemize
        @end itemize
        @item @file{files_all/}
        @itemize @bullet
            @item @file{vim70/}
            @itemize @bullet
                @item @emph{Vim files}
            @end itemize
        @end itemize
        @item @file{files_extra/}
        @itemize @bullet
            @item @file{vim48x48.png}
        @end itemize
        @item @file{welcome}
        @item @file{finish}
        @item @file{config.lua}
        @item @file{run.lua}
    @end itemize
@end itemize

Calling @file{geninstall.sh} from the Nixstaller directory with the path to project directory as first argument and @samp{vim70.sh} as second argument should produce the installer.



@node Compilation
@chapter Compilation

@section Introduction
This chapter is important for people who want to compile the frontends used by Nixstaller. Some reasons may be if you changed the source code or you're porting to a new platform for example. There are some things to watchout for, therefore if you really need to compile then read this chapter as a whole.

@section Libraries

@subsection Dynamic vs Static
Dynamic libraries are good because they reduce size from the executable and when they are updated it affects the executable aswell. Drawbacks are mainly conflicting version numbers. If the major library version changes the executable cannot use it anymore.@*
@*
For this reason most libraries are linked staticly. This will add size to the resulting binaries, but they can run on many different systems. There are however a few libraries linked dynamicly, because they cannot or it's unreasonable to link them staticly. The C library (@samp{libc}) and the C++ libraries are examples of dynamicly linked libraries.

@subsection Required Libraries
@starttable{.25, .25, .25, .25}
@addtableheaderrow{Library}
    @addtableheadercol{Where to get it}
    @addtableheadercol{Used by}
    @addtableheadercol{Dynamic or Static}
@endtablerow

@addtablerow{GTK2 (libgobject-2.0 libglib-2.0 libpango-1.0 libgdk-x11-2.0 libgdk_pixbuf-2.0 libgtk-x11-2.0)}
    @addtablecol{@uref{http://www.gtk.org/}}
    @addtablecol{GTK2 frontend}
    @addtablecol{Dynamic}
@endtablerow

@addtablerow{zlib (libz)}
    @addtablecol{@uref{http://www.zlib.net/}}
    @addtablecol{FLTK frontend}
    @addtablecol{Static}
@endtablerow

@addtablerow{png (libpng)}
    @addtablecol{@uref{http://www.libpng.org/pub/png/libpng.html}}
    @addtablecol{FLTK frontend}
    @addtablecol{Static}
@endtablerow

@addtablerow{jpeg (libjpeg)}
    @addtablecol{@uref{http://www.ijg.org/}}
    @addtablecol{FLTK frontend}
    @addtablecol{Static}
@endtablerow

@addtablerow{FLTK (libfltk, libfltk_images)}
    @addtablecol{@uref{http://www.fltk.org/}}
    @addtablecol{FLTK frontend}
    @addtablecol{Static}
@endtablerow

@addtablerow{X11 (libX11, libXext, libXft)}
    @addtablecol{Locally or @uref{http://www.x.org/}}
    @addtablecol{FLTK frontend}
    @addtablecol{Dynamic}
@endtablerow

@addtablerow{ncurses (libncurses, libncurses++)}
    @addtablecol{@uref{http://www.gnu.org/software/ncurses/ncurses.html}}
    @addtablecol{ncurses frontend}
    @addtablecol{Static}
@endtablerow

@addtablerow{Lua (liblua)}
    @addtablecol{@uref{http://www.lua.org/}}
    @addtablecol{Core}
    @addtablecol{Static}
@endtablerow

@addtablerow{GCC libs (libc, libstdc++, libm, libgcc, libutil)}
    @addtablecol{@uref{http://gcc.gnu.org/}}
    @addtablecol{Core}
    @addtablecol{libutil static, the rest dynamic}
@endtablerow

@endtable

All the static libraries with the exception from @file{libutil.a} needs to be copied to the @file{src/lib/[osname]/[archname]} directory. The @samp{[osname]} refers to the lowercased output from the command @command{uname}. @samp{archname} refers to either @samp{x86} or the output from @command{uname -m}. The main reason for putting the static libraries in a seperate directory is that 'clean' versions can be compiled and used. 'clean' in the way that the libraries have no CPU specific optimizations.@*
@*
The search path to X11 libraries defaults to @file{/usr/X11R6/lib}. This can be changed by the @samp{xlibsdir} parameter passed to SCons, which is discussed later.@*
@*
The search path to GTK2 libraries defaults to @file{/usr/lib}. This can be changed by the @samp{gtklibsdir} parameter passed to SCons, which is also discussed later.@*

@subsection Headers
All the header files from the static libraries can be found in the @file{src/include/} directory. You normally don't have to bother with these. The path to the X11 headers can be specified with the @samp{xincdir} parameter passed to SCons (discussed later). The included GTK2 headers are from the older 2.4 version. This ensures that the frontend runs on systems with GTK+ 2.4 or later.

@subsection Notes
In the @file{src/libs/[osname]/[archname]/} directories you can find a @file{notes} file that contain several notes about which library versions are used and how they were compiled. It's recommended that the same library versions are used incase you want to compile your own.

@section SCons
@uref{http://www.scons.org/, SCons} is used as built system to compile Nixstaller. Atleast version @samp{0.96.91} is required. SCons depends on @uref{http://www.python.org, python} so make sure to install that aswell.@*
@*
To start the compilation simply execute @command{scons} from the @file{src/} directory.@*
@*
SCons has several options that will affect the compilation, to see these run @command{scons --help} in the @file{src/} directory.@*
@*
There are also a few build targets:
@table @strong
@item stripbins
Strips all symbols from the binaries.
@item tardist
Creates a tar.gz file containing the full Nixstaller distribution. Note that new files need to be added to the @code{distfiles_user} variable at the beginning of the @file{SConstruct} file.
@item setupdist
Creates an installer for Nixstaller.
@end table

After compilation is done the binaries will be put in the @file{bin/} directory. The directory structure looks like this:
@itemize @bullet
    @item @emph{osname/}
    @itemize @bullet
        @item @emph{archname/}
        @itemize @bullet
            @item @emph{libc.so.X/}
            @itemize @bullet
                @item @emph{libstdc++.so.X/}
                @itemize @bullet
                    @item @file{lzma}
                    @item @file{fltk}
                    @item @file{gtk}
                    @item @file{ncurs}
                @end itemize
                @item @file{edelta}
                @item @file{lzma-decode}
            @end itemize
        @end itemize
    @end itemize
@end itemize

The binaries are each put on seperate @samp{libc} and, incase of C++ binaries, in seperate @samp{libstdc++} directories aswell. The reason for this is that they are linked dynamicly. To make sure that an installer works on many systems, different binaries with different linked library versions need to be included. For this reason it's important to compile on different versions of an Operating System. For example FreeBSD 5.X uses @file{libc.so.5} and @file{libstdc++.so.4} while FreeBSD 6.X is using @file{libc.so.6} and @file{libstdc++.so.5}. In order to let an installer run on both FreeBSD 5 and 6 the binaries are compiled on both systems and put in their own subdirectory inside @file{bin/}. When the installer is started (and obviously created when the binaries were in place) it will then choose the right binaries for the users system.@*
@*
Besides the frontends there are some other binaries. Here is an explanation for each of them:
@table @file
@item lzma
Binary used to @emph{encode} the install files using the lzma algorithm. This file is not included in the installer.
@item fltk
The FLTK frontend.
@item gtk
The GTK frontend.
@item ncurs
The ncurses frontend.
@item edelta
This binary is used to create @samp{deltas} or @samp{binary diffs} from frontend binaries. The @samp{diffs} are made from binaries for the same OS and CPU architecture but from different @file{libc} and/or @samp{libstdc++} versions. Note that this version differs from the @uref{http://www.diku.dk/~jacobg/edelta/, original version} because it's modified in such way that it doesn't use compression (which makes the binary smaller and allows us to use other compression methods than gzip).
@item lzma-decode
@emph{Decodes} lzma encoded files. This is a much smaller version of the normal @file{lzma} binary and is included in the installer.
@end table




@node Miscallenous
@chapter Miscallenous

@section Credits
@itemize @bullet
@item @uref{http://www.kdevelop.org/, KDevelop}: Great IDE which I use for programming.
@item @uref{http://www.scons.org, SCons}: Great alternative to GNU's autotools.
@item @uref{http://www.kde.org, KDESU}: Much of the code using @samp{su} is based on this KDE project.
@item @uref{http://www.megastep.org/makeself/, makeself}: Engine for the self-extracting installer.
@item @uref{http://quanta.kdewebdev.org/, Quanta+}: Good HTML editor used for the website.
@item @uref{http://www.texinfo.org, texinfo} and texi2html: Used to create this documentation.
@item @uref{http://www.berlios.de, BerliOS}: Project hosting.
@item @uref{http://www.diku.dk/~jacobg/edelta/, edelta}: Used to create @samp{binary diffs} to decrease the size of frontend binaries.
@item @uref{http://www.7-zip.org/sdk.html, lzma}: Very good compression algorithm.
@item @strong{InternetNightmare}: Suggestions, testing, feedback.
@item @strong{offer}: Suggestions, bug reporting, feedback.
@end itemize


@section Feedback
For suggestions, questions, bugs etc you can reach me through the following ways:
@itemize @bullet
@item E-Mail: rhelmus_AT_gmail.com
@item Use the @uref{http://nixstaller.berlios.de/forum/index.php, online forums}
@item Instant Message: rick_helmus8_AT_hotmail.com (MSN), 224332897 (ICQ) or rhelmus_AT_gmail.com (Google Talk).
@item For bugs: the @uref{http://developer.berlios.de/projects/nixstaller/, BerliOS project page}.
@end itemize




@node Lua Basics
@appendix Lua Basics

@section Introduction
Lua (@url{http://www.lua.org}) is used for configuring properties of the @emph{Install Package} and to control the installation process. Lua is a simple and easy to learn scripting language. In this appendix a brief guide is given about Lua. Another good resource is the @uref{http://www.lua.org/pil,Lua Book}. Note that the online version describes version @emph{5.0} while Nixstaller uses @emph{5.1}. Though not much has been changed, especially not the basics.


@section Lua Basics
@subsection Comments
Lua files can contain @emph{comments}. Comments are for example used to describe pieces of code or to quickly 'disable' some code.

Some examples:
@codeblock{@minus{}@minus{} This is a comment line, comment lines always start with @samp{@minus{}@minus{}}
a = b + 5     @minus{}@minus{} Comment can be after a code line aswell
@minus{}@minus{} b = b + 1   @minus{}@minus{} A 'disabled' line}

There can also be @emph{comment blocks}:
@codeblock{@minus{}@minus{}[
Text between the two square brackets is comment.
This is useful if you want to write a few lines or disable multiple code lines.
@minus{}@minus{}]}

@subsection Variables
To store data @emph{variables} are used. A variable name is a combination of letters, underscores and/or numbers. Note that the variable name cannot start with a number.
To create a variable you simply assign data to it. To remove a variable you assign @code{nil} to it.

@subsubsection Types
Variables are not bound to a single type(typeless, languages as C are typed). There are various types in the Lua environment:
@table @strong
@anchor{Numbers}
@item Numbers
Numbers can be both a decimal type or a integral type. Examples:
@codeblock{a = 15
b = 1.5}
@anchor{Strings}
@item Strings
Strings are used to store an array of characters. The text used for a string should be either enclosed by single quotes ('') or double quotes (""). Example:
@codeblock{text1 = "Hello"}
If you want to assign lots of text you can also use the @samp{[[} and @samp{]]} operators. These will add all the text between them, including newlines. Example:
@codeblock{longtext = [[Hello
this
is
a string
with newlines]]}
Special characters such as newlines and (double)quotes need to be 'escaped'. This means that you need to put a backslash (@samp{\}) and another character next to it, which will be replaced by another character. Here are some most used @samp{escape sequences}:
@table @samp
@item \n
Will be replaced by a newline.
@item \t
Will be replaced by a horizontal tab.
@item \v
Will be replaced by a vertical tab.
@item \\
Will be replaced by a backslash.
@item \'
Will be replaced by a single quote.
@item \"
Will be replaced by a double quote.
@end table
Note that escape sequences are ignored with the @code{[[} and @code{]]} operators.

@item Boolean
A Boolean is either @code{true} or @code{false}. They are used to enable/disable flags and test them in conditional lines. Example:
@codeblock{a = true
b = false}
@item Tables
Tables are a generic type and can be used in many different ways. @xref{Tables} for a detailed explanation.
@item Functions
Functions can also be stored in variables. @xref{Functions} for more info.
@item @samp{@strong{nil}}
As said before, @code{nil} is used to delete a variable. @code{nil} is also sometimes used to indicate @samp{Nothing}. Example:
@codeblock{a = nil    @minus{}@minus{} a will now be collected by Lua's garbage collector}
@end table

@subsubsection Operators
Operators are used to operate on variables. For example to multiply 2 numbers or to add (concat) 2 strings to each other. The following table lists every operator and its function. The items are shown in order of priority.
@starttable{.25,.25,.25,.25}
@addtableheaderrow{Operator}
    @addtableheadercol{Used on}
    @addtableheadercol{Effect}
@endtablerow

@addtablerow{@code{^}}
    @addtablecol{Numbers}
    @addtablecol{Calculates the power}
@endtablerow

@addtablerow{@code{not}, @code{-}, @code{#}}
    @addtablecol{Numbers}
    @addtablecol{@code{not} returns @code{true} when an expression is false (@pxref{Testing variables and values, this}).@*
The minus in this case is the operator used for negative values.@*
The @samp{#} is used to retrieve the number of entries in a @ref{Tables, table} or the length of a @ref{Strings, string}.}
@endtablerow

@addtablerow{@code{/}, @code{*}}
    @addtablecol{Numbers}
    @addtablecol{Arithmetic operations (@abbr{resp.} divide, multiply)}
@endtablerow

@addtablerow{@code{+}, @code{-}}
    @addtablecol{Numbers}
    @addtablecol{Arithmetic operations (@abbr{resp.} add, substract)}
@endtablerow

@addtablerow{..}
    @addtablecol{Strings}
    @addtablecol{Concats 2 strings}
@endtablerow

@addtablerow{@code{>}, @code{<}, @code{>=}, @code{<=}, @code{==}, @code{~=}}
    @addtablecol{Strings, Numbers, Tables}
    @addtablecol{Used to compare values @*
@xref{Testing variables and values}}
@endtablerow

@addtablerow{@code{and}}
    @addtablecol{Anything}
    @addtablecol{Checks if 2 expressions are @code{true} @*
@xref{Testing variables and values}}
@endtablerow

@addtablerow{@code{or}}
    @addtablecol{Anything}
    @addtablecol{Checks if 1 of 2 expressions is @code{true} @*
@xref{Testing variables and values}}
@endtablerow
@endtable

Parenthesis(@samp{()}) can be used to give an expression the highest priority.

Some examples:
@codeblock{a = 5 * 2       @minus{}@minus{} a = 10
b = 20 / 5      @minus{}@minus{} b = 4
c = (a + b) * 2 @minus{}@minus{} c = 28
d = 5^2         @minus{}@minus{} d = 25
txt1 = "Hello"
txt2 = "World"
txt = txt1 .. " ".. txt2    @minus{}@minus{} txt = "Hello World"}
Note that the @samp{..} operator can convert numbers to strings aswell:
@codeblock{n = 5
txt = "The number is: " .. n    @minus{}@minus{} txt = "The number is: 5"}

@anchor{Testing variables and values}
@subsection Testing variables and values

@subsubsection Operators for testing
In lua there are a few operators to test variables and values:
@table @strong
@item <
Less than
@item >
More than
@item ==
Equal to (@strong{a single @samp{=} does not compare, just assign})
@item ~=
Unequal to
@item <=
Less or equal to
@item >=
More or equal to
@item and
Tests if 2 expressions are @code{true}
@item or
Tests if one of 2 expressions is @code{true}
@item not
Tests if a expression is not @code{true}
@end table

All of these work on @code{numbers} and @code{strings}.The equal and not equal operators also work on @code{tables}.

When a test succeeds @code{true} will be returned, when it fails @code{false} will be returned. Except for @code{or} and @code{and}. @code{or} will return the first expression if its true, otherwise the second. @code{and} will return the first expression if its false, otherwise the second.

Here are some examples:
@codeblock{a = 55
b = 100
c = a > b    @minus{}@minus{} c = false
@*
text1 = "Apple"
text2 = "Orange"
c = text1 < text2   @minus{}@minus{} c = true (alphabetical comparisation)
@*
c = 5 > 2 and "5" < "2"   @minus{}@minus{} false (second expression is false)}

@anchor{and or trick}
As mentioned, the @code{or} and @code{and} operators will return one of the expressions. With that knowledge a nice trick can be made:
@codeblock{a = 5
b = 2
c = 6
d = 12
n = (a > b) and c or d   @minus{}@minus{} n = d(12)}
This might look a bit odd. If you're a C (or C++) programmer you may recognize this: it's similar to @code{(expr) ? a : b}. If you're not, here is what happens:
@itemize @bullet
@item @code{(a > b)}: this is false,
@item @code{... and c}: this is ignored since the previous expression was false. The first expression is returned (@code{false}).
@item @code{... or d}: The previous expression was @code{false}, so @code{or} will return @code{d} (12).
@item @code{n = ...}: @samp{12} was returned, so @code{n} is now @samp{12}.
@end itemize

If you find this confusing, you can use @ref{If statements, if statements} instead. This little trick is mainly used as a shortcut.

@anchor{If statements}
@subsubsection If statements
@code{if statements} are used to test some expression and if @code{true} it will execute some other code.
The general syntax is like this:
@codeblock{if expr1 then
    @minus{}@minus{} Code here for when expr1 is true
elseif expr2 then
    @minus{}@minus{} Code here for when expr2 is true and expr2 isn't
else
    @minus{}@minus{} Code here for when expr1 and expr2 are not true
end}

The @code{elseif} and @code{else} part is optional. The keyword @code{end} is used to end the @samp{if-then block}.
An expression is false when the value is @code{false} or @code{nil}. In any other case it's @code{true}.

@strong{NOTE}: In some other (scripting) languages zero (@samp{0}) and an empty @code{string} are @code{false}, however this is not the case in Lua.

Here are some examples (with comments) to illustrate some usage of if statements.
@codeblock{n = false
if n then
    @minus{}@minus{} Impossible
else
    @minus{}@minus{} Do something here
end
@*
@minus{}@minus{} This is the same as the @ref{and or trick}
if (a > b) then
    n = c
else
    n = d
end
@*
if (msg == "yes") and (not flag) then
    flag = true
elseif (msg == "no") and (flag) then
    flag = false
end}

@strong{Note}: I used parenthesis(@samp{()}) around some expressions and will in later examples. This is merely for clarity in most cases. In above examples the parenthesis don't have any effect.

@subsection Loops
@emph{Loops} are used to execute some code lines more than once. In the following sections the different kind of loops available in Lua are explained.

@subsubsection @code{while} loops
The @code{while} loop looks like this:
@codeblock{while expr1 do
    @minus{}@minus{} Do some code
end}

As long as @samp{expr1} is not @code{false} it will execute the code in the @samp{while-do-end} block.
Here is a short example:
@codeblock{n = 1
while (n <= 10) do
    @minus{}@minus{} Some code
@*
    n = n + 1
end}
In this example the @code{while} loop repeats itself until @code{n} is more than @samp{10}.

@subsubsection @code{repeat} loops
Another loop is the @samp{repeat-until} loop. This will repeat the code block @emph{until} some expression is @code{true}.
Example:
@codeblock{n = 1
repeat
    @minus{}@minus{} Some code
@*
    n = n + 1
until n > 10}
This does exactly the same as the @code{while} example. So why choose @code{repeat} over @code{while}? A reason is when you want to execute the code in the block atleast once. With a @code{while} loop the expression has to be @code{true} before the loop can even begin. With the @code{repeat} - @code{until} statement however it will check the expression at the end of the block and therefore execute the code atleast once.

@subsubsection @code{for} loops
There are 2 kind of @code{for} loops: the @emph{numeric} and the @emph{generic}. We will discuss the first here, the @emph{generic} @code{for} loop will be explained @ref{Traversing Tables, here}.

The @emph{numeric} @code{for} loop looks like this:
@codeblock{for var=expr1,expr2,expr3 do
    @minus{}@minus{} Some code
end}

@table @emph
@item var=expr1
This will assign @emph{expr1} to the variable @code{var}. Note that this variable @strong{only} exists in the @code{for} loop.
@item expr2
As long as @emph{expr2} is unequal to @code{var} the loop repeats itself.
@item expr3
This is optional. @emph{expr3} is used to specify how much @code{var} should increment (or decrement incase a negative value is specified). If not specified it defaults to @samp{1}.
@end table

Now some examples:
@codeblock{for n=1,10 do
    @minus{}@minus{} Some code here that will be executed 10 times
end
@*
for n=2,20,2 do
    @minus{}@minus{} Some code that will be executed 10 times. (n = incremented by 2 each time)
end}

Here are some points to remember with @code{for} loops:
@itemize @bullet
@item As been said the variable used for the loop only exists inside the loop. If you need the value outside the loop you should copy it to another variable.
@item All the three expressions are evaluated just once. This is important to know when you use @anchor{Functions, functions} for an expression.
@item Do not modify the variable used by the @code{for} loop by hand.
@end itemize

@subsubsection @code{break}
To escape from a loop in Lua you can use @code{break} (or @ref{Return values, return}).
Here is an example:
@codeblock{n = 1
while (true)  @minus{}@minus{} Infinite loop
    if (n == 50) then
        break @minus{}@minus{} Not infinite afterall
    end
    n = n + 1
end}
This will escape from the loop when n equals to @samp{50}.
Note that you can only use @code{break} at the end of a code block. In this case it was at the end of the @samp{if-then} block. If this wasn't the case Lua would throw an error.

@anchor{Functions}
@subsection Functions
@emph{Functions} are a way to create @samp{commands}. With functions a piece of code can be executed on all kinds of places.

@subsubsection Basics
Before a function can be used you have to @emph{declare} it:
@codeblock{function funcname(args)
    @minus{}@minus{} Code
end}
@table @emph
@item funcname
This is how the function will be called.
@item args
Which @emph{arguments} or @emph{parameters} this function expects.
@end table

@subsubsection Functions arguments
Some functions may need data from the caller. To pass this data @emph{function parameters} are used. These are variables which are @emph{local} (not exist outside the function) to this function. Here is an example to acclompish this:
@codeblock{counter = 0
@*
function increment(n) @minus{}@minus{} Function that increments @samp{counter} by @code{n}
    counter = counter + n
end
@*
@*
increment(5)
@minus{}@minus{} counter is now 5
increment(-2)
@minus{}@minus{} counter is now 3}
You can also specify multiple function arguments: just seperate them with a comma (@samp{,}).@*
@*
If the user doesn't specify one or more parameters then they will be @code{nil}. With that info we can make it so that some arguments have default values incase they are not given by the caller. For example:
@codeblock{function increment(n)
    if (not n) then
        n = 1
    end
    counter = counter + n
end}
Now if @code{increment} isn't specified with any arguments (@samp{increment()}) it will increment @code{counter} by @samp{1}. We can also use a shorter syntax using the @code{or} operator:
@codeblock{function increment(n)
    n = n or 1
    counter = counter + n
end}
Operator @code{or} will return the second expression if the first is @code{false} or @code{nil}, thus defaults to @samp{1}.@*
@*
Functions can also have a variable number of arguments. @xref{Variadic Functions} for more info.

@anchor{Return values}
@subsubsection Return values
When a function is called it can also return data to the caller. Here is how it generally looks:
@codeblock{function func()
    @minus{}@minus{} Code here
    return arg1, arg2, arg3 @minus{}@minus{} etc
end}

Unlike some other language, lua has the feature to return multiple values. Here are some examples about returning values:
@codeblock{function sum(a, b)
    return a + b
end
@*
function f()
    return "Hello", " ", "World"
end
@*
@*
n1 = 5
n2 = 10
n3 = sum(n1, n2)    @minus{}@minus{} n3 = 15
@*
str1, str2, str3 = f() @minus{}@minus{} str1 = "Hello", str2 = " ", str3 = "World"}

@subsection Local variables
For now mostly @emph{global} variables were used. There is another type of variable: the @emph{local} variable. The variable used in a numeric @code{for} loop is local, so are the function arguments. Local variables only exist in a code block (and the underlying code blocks). To create local variables you have to @emph{define} them with the @code{local} keyword. Local variables are mostly used inside functions, so that they don't corrupt the global environment.
As usual, here are some examples:
@codeblock{function f()
    local a             @minus{}@minus{} a will only exist in this function
    local b, c          @minus{}@minus{} More variables can be defined at once
    local c, d = 5, 6   @minus{}@minus{} And can also be assigned: c = 5, d = 6
@*
    @minus{}@minus{} Some code
end
@*
count = 0    @minus{}@minus{} Global variable
@*
function g()
    local count     @minus{}@minus{} Overide count
    count = 1       @minus{}@minus{} Modify our own count
end
@*
@minus{}@minus{} count is still 0 here}
As shown above @code{local} variables can have the same name as a existing global variable. In such cases @code{local} variables have a higher priority then underlying global variables.


@section Advanced Lua
In this section some of the more advanced features of Lua will be shown. Atleast the first 2 sections about tables are important. For less advanced installers these might be enough for now.

@subsection Functions As Variables
Functions are also a variable type. The way we did to create functions so far is actually a shortcut to assign a function to a (global) variable:
@codeblock{function f()
    @minus{}@minus{} ...
end}
Is essentially the same as:
@codeblock{f = function()
    @minus{}@minus{} ...
end}

With that knowledge some interesting things can be made. For example, a function can be passed to another function:
@codeblock{function sum(a, b)
    return a + b
end
@*
x = 0
@*
function modifyx(func, val1, val2)
    x = func(val1, val2)
end
@*
modifyx(sum, 1, 1)
@minus{}@minus{} x is now 2}

Another example is to use @emph{anonymous functions}. These are, as the name suggests, functions without a name. A good reason to use them is when you want to pass (a simple) function like we did above. Here is the anonymous version:
@codeblock{x = 0
@*
function modifyx(func, val1, val2)
    x = func(val1, val2)
end
@*
modifyx(function(a, b)
            return a + b
        end, 1, 1)
@minus{}@minus{} x is now 2}
This does essentially the same, just with an anonymous function.

@anchor{Tables}
@subsection Tables
Tables are generic types also called @emph{objects}. Tables can be used to create new datatypes, store blocks of data (arrays) and even for OOP(Object Orientated Programming). Not all features of tables are described. Just the few that are in the authors opinion important to know for now. A good reference for lua tables is the @uref{http://www.lua.org,Lua Book}.

@subsubsection Creating A @code{table}
Before we go in to details, lets start with how to create a table. Unlike other types, you have to @emph{construct} tables. The simplest way of doing this is like this:
@codeblock{t = @{ @}}
The 2 curley braces are the key to construct a new table. There are other ways to construct a table, these will be handled in the next sections.@*
@*
Another thing to remember is that variables can only @emph{point} to a table. The following example shows an error:
@codeblock{t = @{ @}   @minus{}@minus{} Construct a new table
t2 = t    @minus{}@minus{} Copy table (ERROR)}
In this example, @code{t2} will @strong{not} be a copy of @code{t}. Instead @code{t2} will @emph{point} to the same table as @code{t} does. @*
@*
When all references to a table are gone, for example by setting @code{t} and @code{t2} to @code{nil}, the table will be removed by Lua's garbage collector.

@subsubsection Tables Seen As An Array
As been said, tables can be used in many ways. Lets start with the @emph{array} like feature. You can see an array like a datablock. This block can expanded, indexed and traversed. Here are the usual examples:
@codeblock{
t = @{ @} @minus{}@minus{} Construct new table
@minus{}@minus{} Create 3 table entries
t[1] = 5
t[2] = 6
t[3] = 7}
In this example the table referenced by @code{t} has 3 entries. Each are @emph{indexed} by numbers: @code{t[1]} points to 5, @code{t[2]} to 6 and @code{t[3]} to 7. Unlike languages such as C the arrays from Lua can be indexed with any type (except @code{nil}). And as usual, the data can be from any type and @code{nil} can be used to remove the data. Some more examples:
@codeblock{t = @{ @}
t["Name"] = "Rick"
t["Phone"] = 123456789
t["Country"] = "The Netherlands"}
This time we used @code{string}s to index a table. Mixes of types can be used for indexing aswell.@*
@*
Usually though we use numbers only as indexes. Records (see below) are mainly used for strings. When you use numbers to index an array it's recommended to start with @samp{1} instead of @samp{0} like some other languages do. A reason for this is that most Lua functions that operate on tables (or arrays) expect that @samp{1} is the first index.

@subsubsection Table Seen As A Record
As explained in the previous section tables can be @emph{indexed}. Another way to assign data to a table is by using @emph{records}. This is the general syntax:
@codeblock{tablename.fieldname}
And an example:
@codeblock{t = @{ @}
t.Name = "Rick"
t.Phone = 123456789
t.Country = "The Netherlands"}
Looks familiar? It's infact the same as the example shown with the array indexed by strings. In other words
@codeblock{t["field"] = 1}
is the same as
@codeblock{t.field = 1}
The reason for this alternative syntax is to have a shortcut specifically for records

@anchor{modules}
@subsubsection Table Seen As A Package
Another popular way is to use tables for @emph{packages} or @emph{modules}. A good example are the Lua libraries discussed later. 
A package is basicly a record which is defined somewhere else. This record contains mostly functions and sometimes other variables. As said before,functions are a variable type. Using that knowledge we can create a package like this:
@codeblock{mypackage = @{ @}
mypackage.f = function()
                @minus{}@minus{} Some code
              end
mypackage.v = "Hello World"
@*
mypackage.f()    @minus{}@minus{} Call f() from mypackage}
For functions in packages Lua has a shortcut:
@codeblock{@minus{}@minus{} Same as above
function mypackage.f()
    @minus{}@minus{} Some code
end}

@anchor{Classes}
@subsubsection Table Seen As A Class
Tables can also be threaded as @emph{classes}. Simply put, these are data types much like records; they have their own variables, called @emph{members} and their own functions, called @emph{methods}. Each class has to be created, mostly through another function.@*
@*
In this guide we'll skip the details about defining new classes and terms such as inheritance. Instead the only thing that is discussed is how to use them, since a few functions from the Lua Library deal with classes.@*
@*
Usually calling function methods from a class is slightly different than that from packages: with packages you used the @samp{.} operator, with classes you use the @samp{:} operator instead.@*
@*
Here follows an example using the @code{io} package from the Lua library. @xref{io} where all the IO functionality is discussed.
@codeblock{@minus{}@minus{} The following line opens the file 'myfile.txt' for reading (specified by "r").
@minus{}@minus{} The io.open function returns a class that can be used to operate on the opened file.
file = io.open("myfile.txt", "r")
@*
@minus{}@minus{} One of the methods of the class is read(), using this function we can read everything from the file to a string:
text = file:read("*all")
@*
@minus{}@minus{} And when we're done, we use the close method to close the file and free the used resources:
file:close()}

@anchor{Traversing Tables}
@subsubsection Traversing Tables
To traverse a table we can use the @emph{generic} @code{for} loop combined with a @emph{iterator function}. The syntax looks like this:
@codeblock{for vars in expression do
    @minus{}@minus{} Code
end}
@table @emph
@item vars
These are 1 or more variables (depending on the used iterator). Multiple variables are as usual seperated with a comma.
@item expression
Normally the iterator function
@end table
So what is an iterator function? To say it easy: when you call it, it will return the next entry of a table. It can do so because it will store its current state by each call. There are different kinds of iterators in Lua. We'll discuss 2 types here and some others are explained in the @ref{Lua Library Reference}.@*
@*
The first we discuss is the @code{pairs} function. This function, combined with a (generic) @code{for} loop, can traverse @emph{any} table. Here is a example:
@codeblock{t = @{ @}
t[1] = 55
t[2] = 105
t.name = "Rick"
@*
for i,v in pairs(t) do
    print("Table entry: " .. i)
    print("Contains: " .. v)
end}
You might be wondering where @code{print} comes from. It's a Lua function which prints text to the standard output (usually a terminal). This function is discussed further @ref{print, here} @*
@*
Running the program it produced the following output:
@codeblock{Table entry: 1
Contains: 55
Table entry: 2
Contains: 105
Table entry: name
Contains: Rick}
As you can see the first variable (@code{i}) is used to store the current index of the table. The second variable (@code{v}) is used to store the value of the current entry. @*
@*
The second iterator function is @code{ipairs}. This function is almost identical to @code{pairs}. The only difference is that it will @emph{only} list numeric indexes. This is useful for arrays. If we change the above example to use @code{ipairs} instead of @code{pairs} it will produce the following output:
@codeblock{Table entry: 1
Contains: 55
Table entry: 2
Contains: 105}
As you can see it omits the @code{"name"} index. Note that, as other Lua functions, @code{ipairs} expects that @samp{1} is used as the first index for an array.

@subsubsection Table Constructers
For now we only used one way to construct tables. Another way is to assign data right away when the table is constructed. For this you can use different ways to acclompish this. @*
@*
The first way is specifically for arrays indexed by numbers, example:
@codeblock{array = @{ 5, 10, "Hello World" @}}
This is equivalent to
@codeblock{array = @{ @}
array[1] = 5
array[2] = 10
array[3] = "Hello World"}
As you see, it starts with index @samp{1}.
@*
Another way is handy for records and such:
@codeblock{record = @{ Name="Rick", Country="The Netherlands" @}
@minus{}@minus{} or like this:
record2 = @{ "Name"="Rick", "Country"="The Netherlands" @}}
which would be equivalent to
@codeblock{record = @{ @}
record.Name = "Rick"
record.Country = "The Netherlands"
@minus{}@minus{} or like this:
record2["Name"] = "Rick"
record2["Country"] = "The Netherlands"}
@*
Table constructors can be nested, like this:
@codeblock{table = @{ @{5, 10@}, @{15, 20@} @}
print(table[1][1], table[1][2])   @minus{}@minus{} prints @samp{5     10}
print(table[2][1], table[2][2])   @minus{}@minus{} prints @samp{15    20}}

@subsubsection The @samp{#} operator
There is one special operator for Lua tables: the @samp{#} operator. This operator return the number of entries with a numeric index in a table. It stops counting if the next index has no value (@code{nil}).@*
@*
Example:
@codeblock{t = @{ 5, 10, 15 @}
print("t got " .. #t .. " elements")    @minus{}@minus{} Prints "t got 3 elements"
t[5] = 25
print("t got " .. #t .. " elements")    @minus{}@minus{} Prints "t got 3 elements", because index 4 is nil}

@anchor{Variadic Functions}
@subsection Variadic Functions
@emph{Variadic functions} are functions with a @emph{variable} number of arguments. Here is a example that displays how to use them:
@codeblock{function f(...)
    for i, v in pairs(arg) do
        print("Arg " .. i .. " contains " .. v)
    end
end
@*
f("Hello", " ", "World")}
When executed, the following output is produced:
@codeblock{Arg 1 contains Hello
Arg 2 contains
Arg 3 contains World
Arg n contains 3}
@table @emph
@item @samp{...}
This is a way to say to Lua that you don't know which arguments are to be expected.
@item arg
In variadic functions this variable is an array with all passed arguments.
@item n
As you may have noticed from the output there is also an entry called @samp{n}. This holds the total number of arguments in the array.
@end table
@*
You can also pass the arguments to another function:
@codeblock{function f(...)
    @minus{}@minus{} Do some stuff
    @*
    print(...)    @minus{}@minus{} The print function is also variadic
end}




@node Lua Library Reference
@appendix Lua Library Reference

In the previous appendix we discussed the basics of Lua. In this chapter we start with the Lua library. The Lua library contains many different functions. Most are inside @ref{modules}. A special note for people who already know Lua: Nixstaller has lots of additional functions added to existing modules, so this section is handy to read for everyone.@*
@*
For each function a definition will be given with a description beneath it. In the definition the expected arguments for this function are given aswell. Optional arguments are between square brackets, three dots (@samp{...}) means that it is a variadic function. If an argument has a default value it will be shown with @samp{=val} right next to the argument.


@section String Functions
In this section we will discuss functions that can modify strings, get info from strings, format strings, search strings etc. All these functions are in the @code{string} package. @*
@*
Note that a string itself is @emph{immutable}. This means that once a string is created, you cannot modify it (well you can delete it by reassigning the variable to @code{nil}). For this reason every function that will operate on strings will return a new (sub)string. Some functions use @emph{string indexes}. A string starts always at index @samp{1}. A negative index is used to start counting backwards, meaning that @samp{-1} equals to the string length, @samp{-2} equals to the string length-1 etc.

@subsection Basic String Functions
We start with the more easy and common functions.

@luafunc string.byte (s [, i=1 [, j=i]])
This will return the byte codes (such as ASCII values) used from string @code{s} starting with index @code{i} till @code{j}. Byte codes can differ from platform to platform.
@endluafunc

@luafunc string.char (...)
Expects numeric arguments which are byte values (for example returned from @code{string.byte}). It will return a string consisting of each argument converted to the corresponding character. @*
Example:
@codeblock{print (string.char(string.byte("Hello World", 1, -1)))   @minus{}@minus{} Prints Hello World}
@endluafunc

@luafunc string.len (s)
Returns the length of the string @code{s}. The @samp{#} operator does the same.
@endluafunc

@luafunc string.lower (s)
Returns a lowercased version of string @code{s}. Characters that don't have a lowercased version are untouched.
@endluafunc

@luafunc string.upper (s)
Returns a uppercased version of string @code{s}. Characters that don't have an uppercased version are untouched.@*
Example:
@codeblock{s = "Hello World!"
print(string.lower(s))    @minus{}@minus{} Prints hello world!
print(string.upper(s))    @minus{}@minus{} Prints HELLO WORLD!}
@endluafunc

@luafunc string.rep (s, n)
Returns a string that is a copy of string @code{s} replicated @code{n} times.@*
Example:
@codeblock{print(string.rep("A", 5))    @minus{}@minus{} Prints AAAAA}
@endluafunc

@luafunc string.reverse (s)
Returns a reversed version of string @code{s}.
@endluafunc

@luafunc string.sub (s, i [, j=-1])
Returns a @emph{substring} from string @code{s} starting at index @code{i} till index @code{j}. When @code{i} is negative it will start at the end.@*
Examples:
@codeblock{s = "Hello World"
print(string.sub(s, 2))    @minus{}@minus{} Prints ello World
print(string.sub(s, 1, 2)) @minus{}@minus{} Prints He
print(string.sub(s, -5))   @minus{}@minus{} Prints World}
@endluafunc

@luafunc string.format (s, ...)
This function returns a string that is formatted according to rules similar to the C functions from the @code{printf} family. The first argument should be a string which can be formatted according to some rules. These rules are specified in the form of @emph{modifiers}. These modifiers have the following syntax:
@codeblock{%[flags][width][.precision]type}

@table @samp
@item %
The first token should always be a percent sign (@samp{%}).
@item [flags]
Optional. For numeric types only. Can be one of these:
@table @samp
@item +
Used to force the usage of the @samp{+} or @samp{-} character in numbers.
@item -
When a width is given (see below) uses left alignment instead of right alignment.
@item #
Alternate form. In the authors opinion not really important. See the man pages of @code{printf} if you're interested.
@item 0
(as in zero) If a width is given (see below), it will use zeros instead of blanks for padding.
@end table
@item [width]
Optional. If a number is given it will make the converted text atleast @samp{n} wide by filling it with spaces if necessary.
@item [.precision]
Optional. Should be a number. The meaning depends on the type and is given below for each one.
@item type
This specifies what the control modifier should do and can be one of the following:
@table @samp
@item %s
Will be replaced by a string. If a precision is given it will use that as a max string length.
@item %d
@item %i
@item %u
Will be replaced by a round number. If a precision is given it will use that as a minimum digit count (adding zeros if necessary).
@item %o
Will be replaced with an octal number. If a precision is given it will use that as a minimum digit count (adding zeros if necessary).
@item %x
@item %X
Will be replaced with a hexadecimal number. Use @samp{%X} for capital characters. If a precision is given it will use that as a minimum digit count (adding zeros if necessary).
@item %e
@item %E
Will be replaced with a number with scientific notation. @samp{%E} is for a capital exponent character (@samp{E}). If a precision is specified it will use as a maximum of numbers to appear after the decimal point.
@item %f
Will be replaced by a @emph{floating point} or @emph{real} number. That is simply said a number which can contain a decimal point. If a precision is specified it will use as a maximum of numbers to appear after the decimal point.
@item %g
@item %G
The same as @samp{%e} and @samp{%E} or @samp{%f}. This depends on the given precision, which is 6 by default. If the exponent of the number is below -4 or above the precision @samp{%e} (or @samp{%E}) is used. Otherwise @samp{%f} will be used.
@item %q
Will produce a string that is @samp{safe} for Lua. This means that special characters such as newlines, quotes, backslashes etc are properly escaped.
@end table
@end table
The returned string from @code{string.format} will contain all the result(s) from the control modifier(s), at the place where the control modifier(s) orginally were placed. Each control modifier will use the next given function argument.@*
@*
To clear things up, here are some examples:
@codeblock{name = "Rick"
age = 21
print(string.format("Hello you are %s and %d years old.", name, age))    @minus{}@minus{} Prints "Hello you are Rick and 21 years old."
f = 12.25/5.55
@minus{}@minus{} The first %f will be replaced with @samp{2.207207}, the second with @samp{2.21})
print(string.format("The result of 12.25 / 5.55 = %f or shortened: %.2f", f, f))
print(string.format("An aligned number: %3d", 5))    @minus{}@minus{} Prints "An aligned number:   5"}

@endluafunc

@subsection Advanced String Functions
Lua has a few advanced functions to find and replace (sub)strings. For now I will skip these and just point you to the right sections: @uref{http://www.lua.org/pil/20.html,This chapter in the Lua book} and parts of the @uref{http://www.lua.org/manual/5.1/,Lua Manual}.


@section Table Functions
Lua has a few functions to help you when working with tables. These functions are all in the @emph{table} module.

@luafunc table.concat (t, [, sep=""[, i=1[, j=#t]]])
Returns a string that has all elements of table @code{t} next to eachother. Each entry can be seperated by the string @code{sep}. The @code{i} and @code{j} variables are used to indicate a starting and ending index.
Examples:
@codeblock{t = @{ "Hello", "World", "!" @}
t2 = @{ 5, 10, 15 @}
s = table.concat(t)    @minus{}@minus{} s = "HelloWorld!"
s2 = table.concat(t, " ")    @minus{}@minus{} s2 = "Hello World !"
s3 = table.concat(t2, ", ", 2)    @minus{}@minus{} s3 = "10, 15"}
@endluafunc

@luafunc table.insert (t[, p], x)
This function only works with arrays with numeric indexes. The function will insert variable @code{x} into table @code{t} at position @code{p}. When only 2 function arguments are given the second will be used as value to insert and the position will be at the end of the table.
Examples:
@codeblock{t = @{ "Apples", "Oranges" @}
table.insert(t, 1, "Bananas")    @minus{}@minus{} t = @{ "Bananas", "Apples", "Oranges" @}
table.insert(t, "Melons")        @minus{}@minus{} t = @{ "Bananas", "Apples", "Oranges", "Melons" @}}
@endluafunc

@luafunc table.maxn (t)
This function only works with arrays that have numeric indexes. The function loops through the whole table to find the highest used index.
@endluafunc

@luafunc table.remove (t[, p=#t])
Removes the entry from table @code{t} at position @code{p}. The entry that is removed is used as return value.
Example:
@codeblock{t = @{ 5, 10, 15 @}
table.remove(t, 1)    @minus{}@minus{} t = @{ 10, 15 @}
table.remove(t)       @minus{}@minus{} t = @{ 10 @}}
@endluafunc

@luafunc table.sort (t[, c])
Only works with arrays with numeric indexes. This function will sort all the entries from the table @code{t}. The optional argument @code{c} can be used to specify a function that is a replacement of the @samp{<} operator. This function is called to check if one table entry is smaller than another. The function recieves 2 arguments, the first and second entry, and should return @code{true} if the first entry is less than the second.
Examples:
@codeblock{fruits = @{ "Lemon", "Apple", "Orange" @}
table.sort(fruits)    @minus{}@minus{} fruits = @{ "Apple", "Lemon", "Orange" @}
@*
function comp(e1, e2)
    return e1 > e2    @minus{}@minus{} Reversed sorting
end
@*
table.sort(fruits, comp)    @minus{}@minus{} fruits = @{ "Orange", "Lemon", "Apple" @}}
@endluafunc


@section Math Functions
Lua supports many different math related functions through the @code{math} module. Since not many of these functions are important for Nixstaller only a few are discussed.

@luafunc math.abs (n)
Returns the absolute value of @code{n}
@endluafunc

@luafunc math.fmod (x, y)
Returns the modulus (remainder) of x and y.
@endluafunc

@luafunc math.max (n, ...)
Returns the biggest value from the given arguments.
@endluafunc

@luafunc math.min (n, ...)
Returns the smallest value from the given arguments.
@endluafunc

@luafunc math.random ([l[, h]])
If no arguments are given returns a @samp{random} number between 0 and 1. If @code{l} is given it will return a random number (rounded) between 1 and @code{l}. If both @code{l} and @code{h} are given it will return a random number between these values.
@endluafunc

@luafunc math.randomseed (n)
Sets the @samp{seed} for the @code{math.random} function. For each seed an unique series of numbers will be returned by the @code{math.random} function. So if the seed is always the same (ie not changed) @code{math.random} will always return the same values. To get @samp{real} random numbers a way is to set the seed to the system time when the Lua script is started. The system time can be retrieved by the @ref{os.time} function.
@endluafunc


@anchor{os}
@section Functions That Interact With The OS
In the @code{os} package you can find functions that will handle OS specific things. Nixstaller has included some extra functions to this module.@*
@*
On failure (ie a file doesn't exist), some functions will return 2 things: @code{nil} and a string containing an error message. On success these functions will return @code{true}. With this you can easily handle errors like so:
@codeblock{@minus{}@minus{} Function taken from internal Nixstaller code
@minus{}@minus{} (ThrowError is just a function that cleans some stuff up and calls error())
function RequiredCopy(src, dest)
    local stat, msg = os.copy(src, dest)
    if (not stat) then
        ThrowError("Error could not copy required file %s to %s: %s", src, dest, msg or "(No error message)")
    end
end}

@defvr Variable os.arch
This is a string containing the name of the current CPU architecture, such as x86 or x86_64.
@end defvr

@defvr Variable os.osname
This is a string containing the name of the current Operating System.
@end defvr

@luafunc os.chdir (d)
Tries to change the current directory to directory @code{d}. On failure it will return @code{nil} and the error message, on success it will return @code{true}.
@endluafunc

@anchor{os.chmod}
@luafunc os.chmod (f, p)
Changes the permissions from file or directory @code{f} using the unix like permission bits taken from string @code{p}. On failure it will return @code{nil} and a string containing the error message, on success it will return @code{true}.
Example:
@codeblock{os.chmod("mydir/", "777")    @minus{}@minus{} The directory 'mydir' has now full access for everyone}
@endluafunc

@luafunc os.clock ()
Returns the time used by the CPU in seconds.
@endluafunc

@luafunc os.copy (f[, ...], d)
Copies the file @code{f} to destination @code{d}. If @code{d} is a directory it will copy the file to that directory, if @code{d} is a file it will overwrite the contents of that file with the contents of @code{f}. You can also specify 3 or more arguments: in this case the last argument, @code{d}, should be a directory and all the previous arguments files that should be copied to this directory.
examples:
@codeblock{os.copy("file1", os.getenv("HOME"))         @minus{}@minus{} Copies 'file1' to the users home directory
os.copy("file1", "file2")                   @minus{}@minus{} Replaces 'file2' with 'fil1'
os.copy("file1", "file2", "file3", "/tmp")  @minus{}@minus{} Copies 'file1', 'file2' and 'file3' to /tmp}
@strong{Note}: The source and destination files/directories should exist or else Lua will throw an error and abort the program.
For (other) copy failures @code{nil} and the error message will be returned. On success @code{true} is returned.
@endluafunc

@luafunc os.difftime (t2, t1)
Returns the difference in seconds from @code{t2} and @code{t1}. Mostly this is the same as @code{t2 - t1}.
@endluafunc

@luafunc os.execute (c)
Executes the shell command @code{c}. This function returns the exit code from the executed command. It's recommended to use @ref{install.execute}.
@endluafunc

@anchor{os.exit}
@luafunc os.exit ()
Terminates the program.
@endluafunc

@luafunc os.fileexists (f)
Returns @code{true} if the file or directory @code{f} exists.
@endluafunc

@luafunc os.filesize (f)
Returns the filesize in bytes of file @code{f} or @code{nil} plus the error message on failure.
@endluafunc

@luafunc os.getcwd ()
Returns a string containing the current directory. On failure it will return @code{nil} and the error message.
@endluafunc

@luafunc os.getenv (v)
Returns a string containing the value of the shell variable @code{v}. If this variable does not exists, @code{nil} will be returned.
@endluafunc

@luafunc os.isdir (f)
Returns @code{true} if @code{f} is a directory.
@endluafunc

@luafunc os.log (s, ...)
Logs the text from string @code{s} and all the function arguments after that, using @code{syslog}. You can use this function to debug for example.
@endluafunc

@luafunc os.mkdir (d[, m="0777"[, b])
Tries to create the directory @code{d}. If @code{m} is given it should be a string with the unix style permission bits. If @code{b} is @code{true} the @samp{umask} of the current system will be ignored. See the manual page of @code{umask} for details. The function will return @code{nil} and an error message on failure, on success it will return @code{true}.
Example:
@codeblock{@minus{}@minus{} Creates directory in the users home directory with rwx access for the user only.
os.mkdir(os.getenv("HOME") .. "/.myconfig", "700")}
@endluafunc

@luafunc os.mkdirrec (d[, m="0777"[, b])
Tries to create directory @code{d} and its parent directories if non existant. @code{m} and @code{b} have the same function as with @code{os.mkdir}. Returns @code{nil} and an error message on failure, on success it will return @code{true}.
@endluafunc

@luafunc os.readperm (f)
Returns @code{true} if the file or directory @code{f} can be read.
@endluafunc

@luafunc os.remove (f)
Removes the file or directory @code{f}. Directories needs to be empty to be removed. On error it returns @code{nil} and a string containing the error message. On success @code{true} will be returned.
@endluafunc

@luafunc os.rename (f, f2)
Renames the file or directory @code{f} to @code{f2}. On error it will return @code{nil} and a string containing the error message, on success @code{true}.
@endluafunc

@luafunc os.setenv (e, v[, o=true])
This function is used to change or add a shell environment variable. The name of this variable is specified by the argument @code{e}. The value should be a string and is specified by @code{v}. The optional argument, @code{o}, is used to specify if the value should be overwritten incase the variable already exists.
@endluafunc

@anchor{os.time}
@luafunc os.time ()
Returns the current system time. This can for example be used as an argument for @code{math.randomseed}. There is also a second version which will put information in a table, such as the current day and month. For this see the @uref{http://www.lua.org/manual/5.1/,Lua Manual}.
@endluafunc

@luafunc os.tmpname ()
Returns a random file name which can be used for files in the @code{/tmp} directory. This only returns a filename; you still have to create it (see the io package) and remove it manually.
@endluafunc

@luafunc os.writeperm (f)
Returns @code{true} if the file or directory @code{f} has write access for the current user.
@endluafunc


@anchor{io}
@section I/O Functions
The @code{io} package provides several Input/Output functions. As with some functions from the @code{os} package, some functions return @code{nil} and a string containing an error message on failure and @code{true} on success.@*
@*
At first some functions of the @code{io} package will be discussed. After that the @code{file} class will be explained. Instead of adding examples for most functions, this section ends with a few bigger examples. This is because most functions need eachother.

@luafunc io.dir (d)
This function is a function iterator (@pxref{Traversing Tables}) that is used to scan directory @code{d}. On success the function will return a string containing the next file or directory name. On failure (ie. the directory does not exist) it will return @code{nil} and a string containing the error message.@*
Example:
@codeblock{@minus{}@minus{} This will list every file and directory in the current directory
for d in io.dir(".") do
    print(d)
end}
@endluafunc

@anchor{io.open}
@luafunc io.open (f[, m="r"])
Tries to open the file @code{f}. The optional argument @code{m} defines how to open the file. This should be a string containing one of these:
@table @code
@item "r"
Opens the file in read mode. All reads start from the beginning of the file. Fails if the file doesn't exist.
@item "w"
Opens the file in write mode. If the file exists all the previous contents will be removed first. The file will be created if the file doesn't exist.
@item "r+"
Opens the file for reading and writing. The previous contents will be kept and reading/writing will start at the beginning. Fails if the file doesn't exist.
@item "w+"
Opens the file for writing and reading. The file will be cleared if it exists or created if it doesn't exist. Writing/Reading starts from the beginning.
@item "a"
Opens the file in append mode. If a file exists it the contents will be kept and writing starts from the end of the file. If the file doesn't exist it will be created.
@item "a+"
Opens the file in append and read mode. This is the same as the "a" option except that a file can be read aswell (reading also starts at the end of the file).
@end table
A @samp{b} can be appended to the mode string indicating that it's a binary file. This isn't necessary on most UNIX like systems though because binary and text files are threaded equally.@*
@*
On success, this function will return a @emph{file handle}. This is a @ref{Classes, class} with member functions to operate on the file. File handles are discussed @ref{File Handles, here}. When the file could not be opened, @code{nil} and an error message is returned.
@endluafunc

@luafunc io.popen (c[, m="r"])
This will execute the shell command @code{c} in a seperate process. The function returns a @emph{file handle} like @code{io.open} does. More on file handles @ref{File Handles, here}.@*
@*
If @code{m} is "r" all data from the command that is written to the standard output can be read. If "w" is specified the standard input from the file is linked to the data provided from writes.
@endluafunc

@luafunc io.tmpfile ()
Creates a temporary file and returns a @emph{file handle}. This file has a random name and is opened as "r+b" (@pxref{io.open}). On exit the file is removed automaticly.
@endluafunc

@luafunc io.type (t)
This function checks the file handle @code{f}. If the file is opened it will return the string "file", if it's closed "closed file" or @code{nil} if @code{t} is not a file handle.
@endluafunc

@anchor{File Handles}
@subsection File Handles
File handles are @ref{Classes, classes} that can operate on files, such as reading or writing. They are returned from @code{io.open}, @code{io.popen} and @code{io.tmpfile}. The file handle class is referred with the name @code{file} each time below.

@luafunc file:close ()
Closes the file. When a file is closed you cannot read or write from/to it anymore. Note that each file eventually is closed automaticly.
@endluafunc

@luafunc file:flush ()
Normally writes are @emph{buffered}. This function forces to write and clean the buffer.
@endluafunc

@luafunc file:lines ()
This is an iterator function (@pxref{Traversing Tables}) that can be used in a generic @code{for} loop to get each line from the file. Note that the trailing newlines are deleted from the output.
@endluafunc

@luafunc file:read (...)
This file is used to read from the file. The used arguments should be one of the following formats:
@table @strong
@item "*n"
Reads a number and will return it.
@item "*a"
Reads the whole file and returns it as a string.
@item "*l"
Reads and returns (the rest of) a line, without a trailing newline.
@item A number
Reads the specified amount of bytes and returns it as a string.
@end table
If no function arguments are used, the @samp{*l} option is used. This function is variadic, so multiple formats can be specified in one call. On error @code{nil} is returned.
@endluafunc

@luafunc file:seek ([b="cur"[, o=0]])
This function can be used to set/get the current file position. This position is used to start reading or writing. The parameter @code{b} is used to specify a base location and @code{o} is a number which specifies the offset from that. @code{b} can be any of these strings:
@table @strong
@item "set"
The base is at the beginning of the file.
@item "cur"
The base starts from the current location.
@item "end"
The base starts from the end of the file.
@end table
The return value is the position after the change has been applied. So @code{file:seek("set")} will return @samp{0}, @code{file:seek("cur")} returns the current position and @code{file:seek("end")} the end position. Note that this function does not work with file handles gained from the @code{io.popen} function.
@endluafunc

@luafunc file:setvbuf (m[, s=?])
Writing to a file is @emph{buffered}. This is to gain performance. The first parameter, @code{m}, is a string which defines how to buffer:
@table @strong
@item "no"
Writes are unbuffered, meaning the data will be written immediately.
@item "full"
Writes are fully buffered, this is the default. Data will only be written when the buffer is full, @code{file:flush} is called or when the file is closed.
@item "line"
Like "full", but the data is also written after each newline.
@end table
The optional @code{s} argument specifies the buffer size in bytes. By default this is a value which suids the system the most.
@endluafunc

@luafunc file:write (...)
Writes each function argument to the file. Numbers and strings are valid argument types.
@endluafunc

@subsection Examples
Here follow a few examples of the IO related functions that were discussed.@*
@*
@codeblock{@minus{}@minus{} This code will open a file, read and display its contents and close it
f, msg = io.fopen("test.txt", "r")    @minus{}@minus{} f will contain the file handle, msg an error message on failure
@*
@minus{}@minus{} File could not be opened? (ie doesn't exists)
if (not f) then
    print("Could not open file: " .. msg)
    os.exit()    @minus{}@minus{} @xref{os.exit}
end
@*
print(f:read("*a"))
@*
f:close()
}
@*
Here is another example showing how to copy a file; it reads one line and writes it to a second file
@codeblock{@minus{}@minus{} Function that copies the contents of file src to file dest
function copy(src, dest)
    local f_src = io.open(src, "r")
    local f_dest = io.open(dest, "w")
@*
    if (not f_src or not f_dest) then
        print("Error opening files")
        return
    end
@*
    for line in f_src:lines() do
        f_dest:write(line)
@*
        @minus{}@minus{} lines() will not return the trailing newline, so we have to add it manually
        f_dest:write("\\n")
    end
@*
    f_src:close()
    f_dest:close()
end}
@*
The last example is about @code{io.popen}:
@codeblock{@minus{}@minus{} This code will execute @samp{ls -a} and print its output
cmd = io.popen("ls -a", "r")
@*
if (cmd) then
    local line = cmd:read()
    while (line) do
        print(line)
        line = cmd:read()
    end
    cmd:close()
else
    print("Could not execute command")
end
@*
This will 'open' the unix command @samp{cat} and feed it some data:
cmd = io.popen("cat", "w")
@*
if (cmd) then
    for i=1,10 do
        cmd:write("Line " .. i .. "\\n")
    end
else
    print("Could not execute command")
end}


@section Install Package
This section describes all the install related functions and variables. They are obviously Lua extensions so you won't find them in any other Lua manual. It's recommended that you read @ref{Creating Installers} first.

@subsection The @code{install} Module

@defvr Variable install.destdir
Variable that is used to set the destination directory for the @ref{install.extractfiles} function.
@end defvr

@defvr Variable install.screenlist
Variable that should be used to specify the installation screens to be used. Can contain classes created by the @ref{install.newscreen} function and one of these predefined variables:
@itemize @bullet
@item WelcomeScreen
@item LicenseScreen
@item SelectDirScreen
@item InstallScreen
@item FinishScreen
@end itemize
By default @code{install.screenlist} is set like this:
@codeblock{install.screenlist = @{ WelcomeScreen, LicenseScreen, SelectDirScreen, InstallScreen, FinishScreen @}}
@end defvr

@anchor{install.extrafilespath}
@luafunc install.extrafilespath ([f])
This function returns a path to where the files are located which were placed in the @file{extra_files/} directory from the project directory. The optional string argument @code{f} is used for convience and is simply appended to the returned path.@*
For example, if a file called @file{README} was placed in the @file{extra_files/} directory before the installer was created, we can access it as follows:
@codeblock{readmefile = install.extrafilespath("README")}
@endluafunc

@luafunc install.getlang ()
The function returns a string with the currently loaded language.
@endluafunc

@anchor{install.gettempdir}
@luafunc install.gettempdir ()
This function is used to assign a temporary directory the the @code{install.destdir} variable. Setting @code{install.destdir} to a temporary directory is useful for installers that need to do additional tasks with the installation files such as compilation.
@endluafunc

@subsubsection Functions used in the @code{Init} function
Following functions should only be used within the @code{Init} function.

@anchor{install.newscreen}
@luafunc install.newscreen ([t])
This function will return a class for a new @emph{installation screen}. The members of this class are described @ref{screen,,here}. The optional argument, @code{t}, specifies a (short) title for this screen.
@endluafunc

@subsubsection Functions used in the @code{Install} function
Following functions should only be used within the @code{Install} function.

@anchor{install.askrootpw}
@luafunc install.askrootpw ()
This function will ask the user to type the systems root password. Normally this is done automaticly if,
@itemize @bullet
@item @code{executeasroot()} is called,
@item when @code{install.destdir} is set to a directory which cannot be written to by the user.
@end itemize
A good reason to call this functions is when you're sure the script will execute one or more commands as root @emph{after} @code{install.extractfiles()} is called. This way the user can abort if he or she doesn't want to or cannot type the root password before the installation begins.@*
@*
When this function is called more than once it won't do anything (the password is cached).
@endluafunc

@anchor{install.execute}
@luafunc install.execute (c[, r=true[, p="/bin:/usr/bin:/usr/local/bin:/usr/X11R6/bin:."]])
This function will execute the shell command defined by string @code{s}. The optional argument, @code{r}, tells that the installation should be aborted when the command failes to execute. With the optional argument @code{p} you can specify a value which is used to change the @code{PATH} shell variable before the command is executed. For longer shell commands it might be handy to use the @code{[[} and @code{]]} operators (@pxref{Strings}).@*
@*
This function writes all the output from the command to a status window so the user can see whats happening. Because of this it's better to use this command instead of @code{os.execute}. Another reason is that @code{os.execute} will block all user input when it's called, so that for example the user cannot abort the installation without manually killing it.@*
@*
Note that when @code{install.destdir} is unwritable for the current user and the user agreed to continue as root, @code{install.execute} will run the shell command as root.
@endluafunc

@anchor{install.executeasroot}
@luafunc install.executeasroot (c[, r=true[, p="/bin:/usr/bin:/usr/local/bin:/usr/X11R6/bin:."]])
This function does essentially the same as @code{install.execute}, but using the @code{su} command to execute it as root. When the root password is not given yet it will ask the user to do so.
@endluafunc

@anchor{install.extractfiles}
@luafunc install.extractfiles ()
This function will extract all installation files to the directory that was specified by the global variable @code{install.destdir}. This function will automaticly call @code{install.setstatus()} to notify the user that the files are extracted. Each file which was extracted is printed on the screen, and the progress bar is updated properly.
@endluafunc

@anchor{install.lockscreen}
@luafunc install.lockscreen (c, b, n)
This function will lock or unlock the Cancel, Back and Next button. If @code{c} is @code{true} the Cancel button is locked, when @code{b} is @code{true} the Back button is locked and when @code{n} is @code{true} the Next button is locked. When @code{false} is given a button is unlocked.
@endluafunc

@anchor{install.print}
@luafunc install.print (s)
Prints the message specified by argument @code{s} on the status window from the install screen.
@endluafunc

@anchor{install.setstatus}
@luafunc install.setstatus (s)
You can use this function to specify a (short) message of the current status of the installation. This way the user can see what the installer is doing. @*
Example:
@codeblock{@minus{}@minus{} Somewhere inside the Install() function
@minus{}@minus{} ...
install.setstatus("Copying files")
os.copy(file1, file2, "/usr/local/share")}
@endluafunc

@anchor{install.setstepcount}
@luafunc install.setstepcount (n)
This function is used to specify how many @emph{steps} the installation has, specified by parameter @code{n}. This is used to divide the progress bar and to put a text in the form of (x/X) on the screen, where @samp{x} is the current step and @samp{X} the total count of steps. On each @code{install.setstatus} call the current step will be incremented by one. By default the step count is 1.@*
@*
Note that @code{install.extractfiles} will call this function aswell, so you most lickely want to increment @code{n} by one.
@endluafunc

@anchor{screen}
@subsection The @code{screen} class
The class described here is returned after a call to @code{install.newscreen}. The function definitions below use @samp{screen} as classname, though you should replace that name with the name of the variable that contains the class.

@anchor{screen:addcfgmenu}
@luafunc screen:addcfgmenu ([t])
Creates a new @samp{config menu}. The string parameter @code{t} sets a title. The menu is used to let the user configure certain parameters. These parameters can be paths (configured through a file manager), strings, boolean flags (can be enabled or disabled) or a list with options. The function will return a class containing function methods to add parameters. These are described @ref{cfgmenu, here}.
@endluafunc

@anchor{screen:addcheckbox}
@luafunc screen:addcheckbox (t, o)
Adds a checkbox widget to the install screen. The argument @code{t} can be used to set a title (simply use "" for no title). The second argument, @code{o}, should be an array containing strings which specify the name for each option. The function will return a class with the following members (chkbox is just a name that should be replaced by the variable containing the class):
@luafunc chkbox:get (o)
Returns @code{true} if the option @code{o} is enabled or @code{false} when disabled. @code{o} can be a string containing the option name or can be an option number.
@endluafunc
@luafunc chkbox:set (o, ..., e)
This variadic function enables or disables one or more options. The first argument, @code{o}, and the rest before argument @code{e} are the option numbers or strings containing the option names to enable or disable. If @code{e} is @code{true} the option(s) are enabled, if @code{false} they will be disabled.@*
@*
Example:
@codeblock{mybox:set(1, 3, true) @minus{}@minus{} Enable first and third option
mybox:set("Option", false) @minus{}@minus{} Disables the option @emph{Option}}
@endluafunc

@endluafunc

@anchor{screen:adddirselector}
@luafunc screen:adddirselector ([t[, d=os.getenv("HOME")]])
This function will add an inputfield which holds the current selected directory name and a button next to it which will launch a file dialog. This way the user can either select a directory by typing it or by browsing. Argument @code{t} sets an optional title and argument @code{d} sets an initial directory, defaulting to the user's home directory. The function will return a class with the following methods (where dirsel should be replaced by the actual variable name):
@luafunc dirsel:get ()
Returns a string containing the current selected directory.
@endluafunc
@luafunc dirsel:set (d)
Sets the directory to string @code{d}.
@endluafunc
@endluafunc

@anchor{screen:addgroup}
@luafunc screen:addgroup ()
Creates a new @samp{group widget}. This widget is used to position widgets horizontally next to eachother. To add a widget to the group you simple have to create a widget via the group's member functions. These member functions are equal to the widget creation functions from the @code{screen} class itself.@*
Example:
@codeblock{group = myscreen:addgroup()
img = group:addimage("graphics.jpeg")
text = group:addlabel("Thanks for downloading my software!")}
@endluafunc

@anchor{screen:addimage}
@luafunc screen:addimage (f)
This widget displays an image loaded from file @code{f}. The image is scaled down incase it's larger than 300x200 px. Valid formats are: png, jpeg, gif and bmp.
@endluafunc

@anchor{screen:addinput}
@luafunc screen:addinput ([l[, t[, m=1024[, v[, tp="string"]]]])
This will add an input field to the install screen. The parameter @code{l} is used to specify a label (text which is put in front of the input field). The parameter @code{t} specifies a title (set to "" for none). @code{m} specifies the max character count that can be typed. @code{v} specifies an initial value. The last parameter, @code{tp}, specifies the type of the inputfield and can be one of these:
@table @strong
@item "string"
The user can type any (alphanumeric) character as input.
@item "number"
The user can type any number but not fractions.
@item "float"
The user can type any number including fractions.
@end table
The function will return a class with the following method functions (input should be replaced with the actual variable name which points to this class):
@anchor{input:get}
@luafunc input:get ()
Returns the current value hold by the input field.
@endluafunc
@luafunc input:set (s)
Sets the current value to the string @code{s}.
@endluafunc
@luafunc input:setlabelwidth (n)
This function sets a fixed labelwidth to @code{n} characters. This function is typically used to let multiple inputfields start at the same horizontal position, by setting their labelwidth to the same value. The default value is @samp{15}.
@endluafunc
@endluafunc

@anchor{screen:addlabel}
@luafunc screen:addlabel (l)
This widget displays a simple text label with the text specified by argument @code{l}. The function returns a class with the following method (replace label with the actual variable name):
@luafunc label:set (l)
Sets the label text to string @code{l}.
@endluafunc
@endluafunc

@anchor{screen:addmenu}
@luafunc screen:addmenu (t, o)
This function will add a menu (or listbox) widget to the install screen. The parameter @code{t} specifies a title (set to "" for none). The parameter @code{o} should be an array containing string entries with the options that can be selected. Note that depending on the frontend the given options may be sorted when presented to the user. The function returns a class with the following methods (menu should be replaced by the variable that is pointing to the class):
@luafunc menu:get ()
Returns the name of the option that is enabled.
@endluafunc
@luafunc menu:set (o)
Selects the option @code{o}, which can be an array index or string with the option name.
@endluafunc
@endluafunc

@anchor{screen:addprogressbar}
@luafunc screen:addprogressbar ([t])
This function adds a progressbar to the install screen. The optional string argument @code{t} is used for a title. The function returns a class with the following method (replace progbar with the actual variable name):
@luafunc progbar:set (v)
The argument @code{v} should be a number between 0 and 100. This number tells how many percent of the bar should be filled (0: empty, 100: full).
@endluafunc
@endluafunc

@anchor{screen:addradiobutton}
@luafunc screen:addradiobutton (t, o)
This function will add a radio button widget to the install screen. The parameter @code{t} specifies a title (set to "" for none). The parameter @code{o} should be an array containing string entries with the options that can be selected. This function will return a class with the following methods (radio should be replaced by the variable that is pointing to the class):
@luafunc radio:get ()
Returns the name of the option that is enabled.
@endluafunc
@luafunc radio:set (o)
Enables the option @code{o}, which can be an array index or string with the option name.
@endluafunc
@endluafunc

@anchor{screen:addtextfield}
@luafunc screen:addtextfield ([t="", [w=false])
This widget is used to display multiple lines of text. When necessary, the user can scroll through the text lines. The optional argument @code{t} sets a title. Optional argument @code{w} enables or disables word wrapping. The function returns a class with the following methods (replace textfield with the actual variable name):
@luafunc textfield:add (s)
Adds the text from the string argument @code{s}.
@endluafunc
@luafunc textfield:load (f)
Loads a file and appends its content. The filename is specified by string argument @code{f}.
@endluafunc
@luafunc textfield:clear ()
Clears all the text.
@endluafunc
@luafunc textfield:follow (f)
If argument @code{f} is @code{true} @samp{follow mode} is enabled, when @code{f} is @code{false} it's disabled. When follow mode is enabled, the widget will always display the last text lines. 
@endluafunc
@endluafunc


@anchor{cfgmenu}
@subsection The @code{config menu} Class
This (sub)section describes the @code{config menu} class, which is created by @ref{screen:addcfgmenu}. This menu is used to let the user configure various parameters through a menu. A type for these parameters is specified so that the user can change them in a logic way; file paths with a file manager, parameters with predefined options through a listbox etc.
The class contains the following methods (replace cfgmenu with the variable name pointing to the class):

@luafunc cfgmenu:addbool (p, d[, v=false])
This function will add a parameter that can be enabled or disabled by the user. Argument @code{p} should be a @code{string} containing the name of the parameter. Argument @code{d} should be a @code{string} with a description. The optional argument @code{v} is a @code{boolean} telling the initial value: @code{true} if enabled, @code{false} when disabled.
@endluafunc

@luafunc cfgmenu:adddir (p, d[, v])
This function adds a parameter that will contain a @code{string} that holds a directory path. The user can modify this through a file browser. Argument @code{p} should be a string containing the parameter name, @code{d} a string with a description and @code{v} a string with an initial path.
@endluafunc

@luafunc cfgmenu:addlist (p, d, l[, v])
This function adds a parameter which the user can edit with a predefined list of options. @code{p} specifies the variable name, @code{d} a description and @code{l} should be an array with strings for each option name. The optional variable @code{v} is a string with the initial value.
@endluafunc

@luafunc cfgmenu:addstring (p, d[, v])
This function adds a parameter that can the user can modify through an input field. Argument @code{p} sets the parameter name, @code{d} the description and @code{v} should be a string with the initial value.
@endluafunc

@luafunc cfgmenu:get (p)
Returns the value from parameter @code{p}. If the type of @code{p} is a boolean, @code{true} will be returned when the parameter is enabled and @code{false} if disabled. In all other cases a @code{string} will be returned.
@endluafunc


@section GUI Functions
There are several functions available through the @code{gui} package which interact with the user. Like the @code{install} package, all of these functions should only be called in the @code{Install} function (@pxref{Creating the Installer}).

@luafunc gui.choicebox (m, b1, b2[, b3])
Creates a window that will show the message identified by function argument @code{m}. @code{b1}, @code{b2} and (optionally) @code{b3} is each a string used for a button name (so the window can have 2 or 3 buttons). On failure the function will return the number of the last button (@samp{3}). On success the number of the clicked button is returned.
Examples:
@codeblock{@minus{}@minus{} somewhere in the Install() function
gui.choicebox("Could not copy file, what should I do?", "Abort", "Retry", "Ignore") @minus{}@minus{} 3 buttons
@*
@minus{}@minus{} ....
gui.choicebox("Could not execute command, what do you want?", "Ignore", "Abort") @minus{}@minus{} 2 buttons}
@endluafunc

@luafunc gui.msgbox (m, ...)
Will display a dialog with the text specified by argument @code{m}. The variadic arguments can be used to concat other texts to this message.@*
Example:
@codeblock {gui.msgbox("Thank you for downloading myapp 0.1! For updates please check www.myapp.org")}
@endluafunc

@luafunc gui.warnbox (m, ...)
The same as @code{gui.msgbox}, but used to alert the user. For example in ncurses the dialog has another color (red) and with the FLTK frontend a warning sign will be shown.
@endluafunc

@luafunc gui.yesnobox (m, ...)
This function will show a dialog with a message used from parameter @code{m} and arguments after that if available (will concat text). The dialog has a yes and a no button. If the user presses "No" @code{false} will be returned, if "Yes" @code{true} is returned.
Example:
@codeblock{@minus{}@minus{} Somewhere in Install() 
if (gui.yesnobox("Do you want to install some add-ons?")) then
    @minus{}@minus{} Copy some files
end}
@endluafunc


@section Other Functions
The last few functions are not in any package but are global functions.

@defvr Variable version
This variable contains a string used to identify the current Nixstaller version. The current value is "0.2.2".
@end defvr

@luafunc assert (f[, ...[, m="Assert failed!"]])
This function is mainly used to debug Lua scripts. If @code{r} is @code{false} or @code{nil} this function will call @code{error} with @code{m} as argument. If @code{r} is another value the function will return @code{r} and the variadic arguments between @code{f} and @code{m} (if existant). This is mostly used in combination with functions that will return @code{nil} on error (many functions from the @code{os} package do this for example).@*
Example:
@codeblock{assert(os.rename("file1", "file2"))    @minus{}@minus{} If this function fails the script will be aborted}
@endluafunc

@luafunc dofile (f)
Executes the Lua script specified by argument @code{f}. You can use this if you want to split script files for example.@*
Example:
@codeblock{if (os.osname == "linux") then
    dofile("linux.lua")
elseif (os.osname == "solaris") then
    dofile("solaris.lua")
else
    dofile("generic.lua")
end}
@endluafunc

@luafunc error (m[, l=1])
This function will abort the install and display an error specified by string @code{m} prefixed with the script name and line number. The optional argument, @code{l}, is used to specify the function level which is used when displaying the error: if it's @samp{0} no line number will be displayed, @samp{1} is used for the current line number (default), @samp{2} for the line number of the function that called the current function etc. @*
Example:
@codeblock{if (not os.copy("file.txt", "somedir/")) then
    error("Could not copy file")
end}
@endluafunc

@luafunc ipairs (t)
Iterator function that can be used to traverse an array with numeric indexes. Returns 2 values: the first is the current array index and the second is the current entry at that array index. When the next entry is @code{nil}, the function will return @code{nil}. This way it will terminate a generic for loop. Argument @code{t} specifies the table to use.@*
Example:
@codeblock{t = @{ 5, 10, 15, 20 @}
for i, e in ipairs(t) do
    print(string.format("t[%d] = %d", i, e))
end}
Results in
@codeblock{t[1] = 5
t[2] = 10
t[3] = 15
t[4] = 20}
@endluafunc

@luafunc pairs (t)
As the above function as @code{ipairs} (well mostly, see the @uref{http://www.lua.org/manual/5.1, Lua manual for details}). This function also accepts other key index types than numbers.@*
Example:
@codeblock{t = @{ @}
t.name = "Rick"
t.age = 21
t.country = "The Netherlands"
for i, e in pairs(t) do
    print(string.format("t.%s = %s", i, e))
end}
Results in
@codeblock{t.name = Rick
t.age = 21
t.country = The Netherlands}
@endluafunc

@anchor{print}
@luafunc print (s[, ...])
This function will print all the given arguments to the standard output (usually the terminal). Since the ncurses frontend already uses the terminal it will call @code{os.log} instead. This function is mainly only used for debugging, since the user probably won't notice the output.
@endluafunc

@luafunc unpack (t[, i=1[, j=#t]])
Returns each entry from table @code{t}. This table should be an array with numeric indexes. @code{i} and @code{j} specify the range to use.@*
Example:
@codeblock{t = @{ "Hello", " ", "World" @}
print(unpack(t))    @minus{}@minus{} Prints "Hello World"}
@endluafunc




@node License
@appendix License
Nixstaller is licensed under the GPLv2 license:

@quotation
Copyright (C) 2006, 2007 Rick Helmus (rhelmus_AT_gmail.com)

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any later
version. 

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details. 

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 51 Franklin
St, Fifth Floor, Boston, MA 02110-1301 USA
@end quotation



@node Index
@unnumbered Index

@comment @unnumberedsec General
@comment @printindex cp


@unnumberedsec Nixstaller Variables
@printindex vr


@unnumberedsec Nixstaller Functions
@printindex fn

@bye
