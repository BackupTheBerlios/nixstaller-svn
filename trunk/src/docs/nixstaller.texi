\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename nixstaller.info
@settitle Nixstaller Manual
@c %**end of header

@macro luafunc{f}
@deffn Function \f\
@c @anchor{\f\}
@end macro


@macro endluafunc
@end deffn
@end macro

@titlepage
@title Nixstaller 0.4 Manual
@author Rick Helmus
@end titlepage

@c Output the table of the contents at the beginning.
@contents

@ifnottex
@node Top
@top About

This document describes how to use Nixstaller to create installers for UNIX like systems.

Here is a short description for what you can find in this document:
@menu
* Features:: What Nixstaller can do.
* Installation:: How to install Nixstaller.
* Quickstart:: If you're in a hurry or want a quick reference.
* Basics:: Explains the basics behind Nixstaller.
* Lua Scripts:: Explains how Nixstaller is scripted.
* Creating Installers:: How Installers are made.
* Tutorials:: Step by step guides for creating Installers.
* Compilation:: Info on compiling Nixstaller.
* Miscellaneous:: Credits and Feedback.
* Lua Basics:: Explains the basics of the Lua scripting language.
* Lua Library Reference:: Explains Most of the Lua Library Functions, including extensions from Nixstaller.
* License:: The Nixstaller license.
* Index:: Complete Index
@end menu
@end ifnottex

@c @include macros.texi

@ifhtml
    @include macros-html.texi
@end ifhtml

@ifnothtml
    @include macros-default.texi
@end ifnothtml


@node Features
@chapter Features

@section Main Features
Here is a list with the main features. Read further for more info to see what they do and how to use them.

@itemize @bullet
@item 3 different frontends used for the installer: @uref{http://www.fltk.org,FLTK}, @uref{http://www.gnu.org/software/ncurses/ncurses.html,ncurses} and @uref{http://www.gtk.org,GTK2}.
@item Support for most common UNIX like systems: NetBSD, Linux, FreeBSD, OpenBSD and Solaris 10/Nexenta (all x86, some x86_64).
@item An installer itself has the following features:
@itemize @bullet
@item Can be fully translated (no UTF yet). Translations for English and Dutch are supplied by default.
@item Different kind of installer screens:
@itemize @bullet
@item A screen where the user can select a language.
@item An introduction screen with an optional image and text.
@item A screen where the user can read/accept a provided license.
@item A screen where the user can select a destination directory to put the installation files.
@item A screen which shows the progress of the installation.
@item A screen which can show text after the installation.
@item A generic screen which can be made with a script.
@end itemize
Most screens are optional and can be shown in any particular order. New type of installation screens can be created manually.
@end itemize
@item Frontends are build in a way that they can be used on many different systems by linking less common libraries staticly.
@item The files can be packed with gzip-, bzip2 and lzma compression.
@item Installation files can be extracted to various directories; a temporary directory (useful for @samp{./configure && make && make install} like installers), a directory which can be selected by the user and a default directory.
@item @uref{http://www.lua.org,Lua} support is provided to configure the installer, create installation screens and program the installation procedure. This allows very flexible configurations.
@item A certain installation type, called @samp{Package Mode}, which allows software registration in the user's native package manager  (rpm, dpkg, pacman and slackware's tgz are currently supported). When Package Mode fails to register the software it will continue with the installation and supply an uninstallation script. Package Mode also features basic dependency handling.
@item Creation of desktop menu entries following the freedesktop standards.
@end itemize


@section Changelog
@subsection 0.3 @minus{}@minus{}> 0.4
@itemize @bullet
@item install.execute / install.executeasroot now return exit code from command
@item Fixed: accessing freed memory in Lua copy file function
@item Fixed: libsu not returning valid exit code
@item Fixed: GTK's textfield was editable
@item Fixed: GTK labels were using less width then possible
@item Added /sbin and /usr/sbin to default PATH for install.execute/install.executeasroot
@item screen:addscreenend() function
@item os.exitstatus() function
@item Fixed: os.chmod crashed when file doesn't exist
@item Fixed: geninstall.sh couldn't place installer in an absolute path
@item x86_64 support.
@item genprojdir.sh now defaults to current arch.
@item geninstall.sh/genprojdir.sh can now be used from any directory.
@item io.md5 lua function
@item Fixed: Overflow crash with lua textfield
@item Install summary screen
@item xdg-open functionality through lua function
@item utils package
@item Fixed: Usage of '%' in messageboxes, yesnoboxes etc might crash.
@item Dirselectors now translate '~/' as $HOME/ (suggested by Tomasz Sałaciński)
@item Increased size of aboutdialogs (suggested by Tomasz Sałaciński)
@item cfgmenu:set() function
@item Functionality to create xdg menu entries
@item sudo support
@item Fixed: geninstall incorrectly assumed logo to be in main project directory (should be in files_extra/)
@item Package Mode
@item Fixed: Lua messageboxes, warningboxes, choiceboxes and yesnoboxes were not using translations.
@item Fixed: Calling io.dir() frequently in a short time might result in too many open file descriptors.
@item OpenBSD 4.2 and FreeBSD 7 support.
@end itemize

@subsection 0.2.2 @minus{}@minus{}> 0.3
@itemize @bullet
@item Added missing ncurses buttonbar entries.
@item Fixed about not loading in file installation screen.
@item Users can now create directories as root from directory selectors
@item SelectDirScreen can now create directories with root access
@item input:setspacing is changed to input:setlabelwidth
@item input:set function
@item checkbox:get and checkbox:set now accept strings besides numbers as arguments.
@item radiobutton:set now accepts strings as arguments aswell
@item SConstruct now works with latest SCons (0.97)
@item Preparing/copying frontend binaries message in geninstall.lua
@item @minus{}@minus{}h/-h option in geninstall.sh
@item Fixed: Lua execution would stop UI updates
@item startupinstaller.sh now checks if a frontend is really launched
@item genprojdir.sh
@item startupinstaller.sh doesn't check for lzma binaries anymore when archivetype is not "lzma"
@item Fixed max intropicsize
@item files_extra/ support
@item Lua widget groups
@item FLTK layout: Logo support, screen header, white backgrounds, Xft font rendering
@item Fixed: Empty folders weren't included in installation files package
@item Fixed: Manual example code was using exit() instead of os.exit()
@item Fixed: Override os.exit() instead of exit()
@item Track widget behaviour with customly defined widget:datachanged() and widget:verify() lua functions.
@item Control screen activation with customly defined screen:canactivate() and screen:activate() lua functions.
@item Updated to Lua 5.1.2
@item Compiled FLTK with Xdbe and Xft support
@item install.newcfgscreen() changed to install.newscreen(). Docs now mentions 'screen class' instead of 'cfgscreen class'.
@item checkbox:get() and checkbox:set() now support both string and array number as argument
@item radiobutton:set() now accepts both a string and array number as argument
@item cfgmenu:addlist() now accepts argument with initial value
@item Widgets now check arguments on bounds
@item New lua widgets: menu, image, label, progressbar and textfield
@item GTK2 frontend
@item install.getlang() function
@item Temporary lzma archives are now unpacked to temporary directory instead of destdir.
@item install.lockscreen function
@item Fixed: Several su (used for root access) bugs on OpenBSD and FreeBSD.
@item OpenBSD 4.1 support
@item NetBSD 4.X support
@item Updated vim example for vim 7.1.
@end itemize

@subsection 0.2.1 @minus{}@minus{}> 0.2.2

@itemize @bullet
@item Fixed: startupinstaller.sh would not sort files (reported by Tero Pelander).
@item Fixed: geninstall.sh didn't check given commandline arguments anymore.
@item Fixed: Missing quotes in startupinstaller.sh (reported by Tero Pelander).
@item Startup message is now read from file.
@item New way of choosing frontends: instead of trying to find available C/C++ system libraries each frontend is checked with ldd for missing libraries (suggested by Tero Pelander).
@end itemize

@subsection 0.2 @minus{}@minus{}> 0.2.1

@strong{FLTK}
@itemize @bullet
@item Fixed: Welcome and License screen would not show up if only one language was available.
@end itemize

@strong{OVERALL}
@itemize @bullet
@item Fixed: Tried to default to english in case only one language was available even if this wasn't English.
@item Fixed: Startup script wouldn't detect libstdc++ on Gentoo (reported by Edward Rudd).
@item Startup script now defaults to Linux in case no frontends are found for the current OS and defaults to x86 in case no frontends are found for the current CPU arch.
@end itemize


@subsection 0.1.1 @minus{}@minus{}> 0.2

@strong{FLTK}
@itemize @bullet
@item Fl_File_Input instead of Fl_input for directory selectors
@end itemize
@strong{ncurses}
@itemize @bullet
@item Completely new frontend code, uses ncurses++ instead of CDK.
@item Upgraded to ncurses 5.6
@end itemize

@strong{OVERALL}
@itemize @bullet
@item License change: Removed CDK exception
@item Completely new configuration via Lua 5.1.1;
@itemize @bullet
    @item Configuration is split to 2 files (config.lua and run.lua instead of install.cfg).
    @item New installation screens can be created.
    @item The order of and which installation screens can be configured.
    @item Installers can now be programmed instead of just configured.
@end itemize
@item Support for OpenBSD and Solaris Express/Nexenta
@item lzma compression support and the default is changed from gzip to lzma.
@item edelta support for 'binary diffs' (reduces size)
@item New manual, made with texinfo and texi2html
@item Directory structure: source files are moved to src/ subdirectory, Nixstaller archives have all the files in a nixstaller subdirectory.
@item Removed SCons example, added Cube and Vim examples
@item C++ library (libstdc++) is now linked dynamicly (reduces size)
@item Shell commands executed during installation are now terminated when the frontend closes.
@item C++ exception support
@item Moved many duplicate frontend code to a single library
@item Removed NetBSD 1.6.2 support
@item Removed norwegian translations (outdated)
@end itemize

@subsection 0.1 @minus{}@minus{}> 0.1.1
@itemize @bullet
@item Fixed: Ncurses frontend crashes if only 1 language is available. 
@item Fixed: geninstall.sh couldn't detect current directory with older versions of ksh.
@item Added Norwegian language support.
@end itemize



@node Installation
@chapter Installation
The installation of Nixstaller is easy: just extract the files to a directory and you're done. You can either directly call any script from this directory, or add it to the $PATH environment variable.



@node Quickstart
@chapter Quickstart
@itemize @bullet
@item @ref{Installation, Install} Nixstaller.
@item Open up a terminal and create a project directory: @command{genprojdir.sh <projectdirhere>}
@item Edit @file{<projectdirhere>/config.lua} and optionally @file{<projectdirhere>/run.lua} or @file{<projectdirhere>/package.lua}.
@item Put some files in @file{<projectdirhere>/files_all/} and perhaps in @file{<projectdirhere>/files_linux_all}, @file{<projectdirhere>/files_freebsd_x86} etc.
@item @command{geninstall.sh <projectdirhere>/}
@item @command{./setup.sh}
@end itemize

Also read the @ref{Tutorials, tutorials}.



@node Basics
@chapter Basics

@section Introduction
This chapter will focus on basic background info on Nixstaller and it's features and is meant to give a idea how everything works. Most of the practical information is given in the next chapters.

@section Installation package
The final product of Nixstaller is an @emph{install package}. The package itself is simply a self-extracting archive in the form of a shell script. When the package (the shell script) is executed it will extract a few files to a temporary directory and will call another script. This second script will detect a usable frontend and calls it.
An install package itself contains the following files:
@itemize @bullet
@item Frontend(s). These binaries will do all the installation work. To allow the installer to run on various systems, multiple frontends can be included.
@item One or more lua scripts which tell what the installer should do.
@item Translation files. (optional)
@item Some text files used for displaying a introduction text, license info and/or a finish message. (optional)
@item One or more archive files containing the files to be used for the installation. Optionally, these files can be separated for various platforms. 
@item Other files needed at runtime, such as images, logos and any other files as specified by the install creator. (optional)
@end itemize

The items important for the install creator are discussed in this and following chapters.


@section Frontends
The @emph{frontend} is a program from which the user can interact. When the install package is executed by the user a suitable frontend will be launched. The ideal frontend is found by if the X environment is available, if required frontend dependencies are met and of course which frontends are included.

Currently there are 3 frontends for Nixstaller.
@ifhtml
The first is powered by @uref{http://www.fltk.org,FLTK}:

@c @image{fltk,,,,png}
@html
<img src="fltk.png" alt="FLTK frontend picture">
@end html

The second by @uref{http://www.gnu.org/software/ncurses/ncurses.html,ncurses}:

@c @image{ncurs,,,,png}
@html
<img src="ncurs.png" alt="ncurses frontend picture">
@end html

and the third by @uref{http://www.gtk.org/,GTK2}:

@html
<img src="gtk.png" alt="gtk frontend picture">
@end html

@end ifhtml
@ifnothtml
The first is powered by FLTK, the second is powered by ncurses and the third by GTK2.
@end ifnothtml
You can select which frontend(s) you want to include.@*
@*
The ncurses frontend is text based and should run on nearly all systems. It doesn't require X and has the least dependencies.@*
@*
The FLTK frontend is a graphical frontend. Some commonly available X11 libraries are required to run. Like the ncurses frontend, the FLTK frontend has very few dependencies and runs on many systems. @*
@*
The GTK2 frontend depends on GTK+ 2.4 or later. For this reason it may not run on every system. However, because it's dynamicly linked, it's also the smallest frontend.@*
@*
The selection of a frontend may depend on the package requirements: Is your software text based? The ncurses frontend might be enough. If your software however requires GTK2 it makes sense to only include this frontend. If size isn't a big issue you may aswell just include all the frontends and therefore increase the chance that the a suitable frontend will be found on various systems.


@section Unattended installations
As of version 0.5, Nixstaller also supports @emph{unattended installations}. These are, as the name suggests, installations who don't need any user interaction and are especially useful for automated (batch) installations. Instead of a frontend, commandline arguments are used to configure the installation process. The default is to have regular @emph{attended installations}, through configuration it's possible to make the installer only support unattended installations or both. In the latter case the user has to specify the @minus{}@minus{}unattended (or @minus{}u) commandline option to let installer run unattended.


@section Lua scripts
The installation itself is controlled by a few Lua scripts. @uref{http://www.lua.org,Lua} is a easy to learn, easy to use and flexible programming language. The specifics about the used Lua scripts are explained in the @ref{Lua Scripts} chapter.


@anchor{Translations}
@section Translations
The text used by the frontends can be translated via @emph{translation files}. The text strings for each language are each stored in a file called @file{strings} and will contain all (English) strings used by the installer with the translation below. Any line that starts with a @samp{#} will be ignored.

Currently there are already two translations: Dutch and English. You can find these in the @file{lang/} directory inside the main Nixstaller directory. You can 'translate' the English @file{'strings'} file in order to modify the English texts used by the installer.

Here is a example taken from the Dutch @file{strings} file:
@codeblock{License agreement
Licentie overeenkomst}

@samp{Licentie overeenkomst} is Dutch for @samp{License agreement}. It's very important that the English text (the first line) is exactly the same as used by the installer.
If you read further in this file you will see the following sentence:
@codeblock{Installation of %s complete!
Installatie van %s gereed!}

Notice the @samp{%s}? The @samp{%s} will be replaced by the installer with another string. This can be all kind of things, in this case it is the program name. What will be replaced is usually given in the form of a comment in the @file{strings} file itself.


@subsection Multiline translations
Some translations need more than one line. If this is the case the text should be put between 2 square brackets.
For example:
@codeblock{[
Directory does not exist
Do you want to create it?
]
[
Directory bestaat niet
Wilt u het aanmaken?
]}

If you want to put a @samp{]} in the translation itself you should put a backslash before it: @samp{\]}.

@subsection Translation configuration
Each translation can (and should) be configured through a Lua script (@pxref{Lua Scripts}). In this file variables such as the display name, auto detection and UTF-8 requirement can be defined.

@subsection Other things that can be translated
There are other things to be translated as well:
@itemize @bullet
@item The welcome message 
@item The license agreement 
@item The 'finish message' 
@item Text used by Lua scripts
@end itemize

The first 3 items will be explained in the next section. Lua scripts will be handled in the chapter @ref{Lua Scripts}.


@anchor{welcome license finish}
@section Welcome message, license agreement and the @samp{finish message}
@table @strong
@item Welcome message
This is the message that is displayed on the @samp{Introduction installscreen}.
@item License agreement
This is the text used to display the License Agreement.
@item Finish message
This is the message that is displayed after the installation has (successfully) finished.
@end table

Each of these items are stored in plain text files. The @emph{welcome message} in the file @file{welcome}, the @emph{license agreement} in a file called @file{license} and the @emph{finish message} in a file called @file{finish}. For translations of any of these texts there should be a translated copy of the file put in a separate directory. The chapter @ref{Creating Installers} describes the file layout and mentions where to put these files.

@section Other files
Other files include files needed during runtime (eg. when the installer is started, but not installing yet) and the files to be used during installation. Examples of runtime files are graphics such as a logo or text files that need to be displayed. The next chapter will cover how to specify these files.

@anchor{pkgmode}
@section Package Mode
Besides the @emph{regular} installation mode, Nixstaller supports an additional mode called @emph{Package Mode}.@*
@*
The first reason for using this mode is that it allows easier package managing of the software to be installed. This is accomplished by either registering the software on the users package manager system (eg. rpm) or by creating a script that is used to uninstall the software. Currently the following package managers are supported: rpm, dpkg (deb), pacman and slackware's installpkg. @*
@*
The second reason to use Package Mode is to allow dependency handling.

@subsection Dependencies
Most, if not all, software have dependencies on other files or software. Reasons include code sharing (to minimize disk and memory usage) or simply because they cannot be shipped with the software itself.

A common group are dependencies on shared libraries. Depending on these shared or dynamic libraries have the advantage that parts of common code can be shared by any software and the fact that updating such libraries (eg. to fix bugs) will affect any software depending on them. The latter is also one of the major drawbacks using dynamic libraries. Updates can introduce binary incompatibilities or, when a new major release is installed or when a library for some reason is removed, the software can't find it and simply won't work anymore.

One way to be sure that software works (and keeps working) on various systems, is to link any shared code @emph{static}. Doing so the code will be part of the executable itself. However this also removes the benefits of using shared libraries: the executable will be bigger, use (slightly) more memory and won't benefit of any library updates.

Nixstaller's dependency handling makes it possible to combine the best of both worlds. Any libraries (and related) files can be supplied with the installer. When the software is being installed, Nixstaller checks for any missing or incompatible libraries. In case these are found, they will be installed inside a separate directory inside the @emph{data directory} (described below). Installing libraries to a isolated place has the benefit that no problems will occur for example by package management (these often overwrite files without even asking to do so).

As software may have several, sometimes dozens, of dependencies the install package size may grow a lot. For this you can tell that the installer should download some or all dependencies separately. The obvious drawback is that the user needs an Internet connection in case the installer finds the need to install dependencies.

@anchor{simplefulldeps}
Some dependencies however cannot be supplied. An example would be the C library (libc). Doing so would in most cases simply result in crashes. Another reason why a dependency cannot be supplied is because it's simply too big to do so, take for example the KDE libraries. For this, Nixstaller allows the use of @emph{simple dependencies}. These dependencies, unlike the previously discussed @emph{full dependencies} don't supply anything by their self, but are purely used to verify what's on the user's system. When any problems are found, the user will be presented with a list of details and told to fix them (for example by using a package manager).

A combination of a full and simple dependency also exist: these will supply all or a part of any required files, but will only install when the dependency is actually available. This is useful for dependencies that cannot ship all files (think of configuration files which need to be set up) but are still able to provide any libraries in case they are incompatible. These dependencies are referred as @emph{non standalone full dependencies}.


@subsection How it works
During the installation, first all the files that should be installed are being placed inside a special directory, called the @emph{temporary package directory}. This directory will later be used for the actual installation, by either packaging the files and registering them with the local package manager or by simply copying them to the destination path. Whether a package is registered or not depends on user configuration, installer configuration and if there is support for the user's package manager.

After the files are placed inside the temporary package directory, dependencies will be checked. All dependencies that should be installed are placed in the temporary package directory aswell. Any dynamic libraries (coming from dependencies or from the 'main' software) must be placed inside a subdirectory called @file{lib/} inside the temporary package directory. Note that this process for dependencies will be done automatically by default.

When the actual installation begins, the files (from the temporary package directory) are not placed directly in the destination directory, but instead are placed in a subdirectory inside the destination directory. This subdirectory is referred as the @emph{data directory}. A common example of a data directory would be @file{/usr/local/share/<appname>}, in this case @file{/usr/local/share} is the destination directory. Some additional scripts will be installed to another directory, the @emph{binary directory}, that will launch an executable from the data directory. The scripts have the same name as the binary that they will run and can set up an environment (usually by setting one or more shell variables) so that the real executable is able run. Besides the @emph{binary scripts}, the binary directory is also used to store any uninstallation scripts (in case the software isn't registered by a package manager). Usually the binary directory is a directory who is defined inside the user's @var{PATH} variable (eg. /usr/local/bin).

Because dependencies are installed to a isolated place, most software needs to be aware of this in order to find them. One way to tell where dynamic libraries can be found, is by setting the @var{LD_LIBRARY_PATH} environment variable. This will be automatically done inside each of the binary scripts. As this software itself is not placed in a regular directory too, it's possible that measures have to be taken for that aswell. KDE programs for example need to have the variable @var{KDEDIRS} set (this can be done automatically aswell). Setting other environment variables is possible and will be discussed in the next chapter.


To summarize:
@itemize @bullet
@item All files, including dependencies, that should be installed are placed inside the @emph{temporary package directory}. All the dynamic libraries should be put in a @file{lib/} subdirectory inside this directory.
@item Depending on configurations and the user's system the files are being registered into the local package manager or simply copied.
@item All the files are installed to the @emph{data directory}, which is a subdirectory inside the destination directory.
@item The user should launch any executables via @emph{binary scripts}. These scripts will set up an environment and launch the actual executable.
@item Using Package Mode the user can uninstall the software via his system's package manager or via a script (which is located inside the binary directory).
@end itemize


@anchor{deskentries}
@section Desktop Menu Entries
Nixstaller can easily create and install so called @emph{.desktop} files that are used for menu entries on various window managers and desktop environments. The files are created according to the freedesktop specifications, more info @uref{http://standards.freedesktop.org/menu-spec/latest/,here}. When Package Mode is enabled the menu entries will be removed as soon as the user uninstalls the package. The next chapter discusses how to generate .desktop files.


@node Lua Scripts
@chapter Lua Scripts

@section Introduction
This chapter discusses how to use Lua for scripting the installer.

The creation and behaviour of the installer is controlled by several Lua scripts. If you're not familiar with Lua or programming in general it's recommended to read the appendix @ref{Lua Basics} or at least keep it close.@*
@*
The appendix @ref{Lua Library Reference} is a complete reference for all the Lua functionality (including extensions from Nixstaller). You will probably want to check this after you read this and the @ref{Tutorials,,tutorials chapter}.

@anchor{config.lua}
@section General configuration
Most of the general configuration such as the Software's name, what kind of compressing should be used, which languages to include, are handled in the project's @file{config.lua} file. In most cases this file autogenerated when a project directory is created (@pxref{Creating Installers}). All of the variables are inside the @code{cfg} module:
@table @code
@vindex cfg.appicon
@item cfg.appicon
An optional variable containing a @ref{Strings,,string} with the filename of a icon to use as a 'application icon' for the installer (this icon is mostly placed on the window border and taskbar). The files have to be formatted as XPM. The file should be placed in the @file{files_extra/} directory. If unspecified a default icon is used.
@vindex cfg.appname
@item cfg.appname
This variable is a @ref{Strings,,string} which should contain the name of your application.
@vindex cfg.archivetype
@item cfg.archivetype
This variable tells which type of compression is used for archiving the installation files. It can be one of these @ref{Strings,,strings}:
@table @code
@item "gzip"
Gzip is very fast at both compression and decompression.
@item "bzip2"
Bzip2 usually compresses better (makes the archive smaller) than gzip, but is slower and uses more memory.
@item "lzma"
LZMA compresses the best of all three. Compression is fairly slow, but decompression is rather fast.
@end table
If this variable is not specified it will default to "lzma". If you're testing your installer it might be a good idea to use "gzip" and switch to "lzma" when the installer is done. That way you have fast compression while testing and good compression for the user.
@vindex cfg.autolang
@item cfg.autolang
This @code{boolean} variable specifies whether the installer should try to automaticly select a language. When this fails or when this variable is set to @code{false} and when there are atleast two languages to choose from, the user will be asked to select a language. The default is @code{true}.
@vindex cfg.defaultlang
@item cfg.defaultlang
This variable should contain a @ref{Strings,,string} defining the default language. The default language is used to translate the language selection screen itself. The specified language must be one of the strings from the @code{languages} variable (see below). The default for this variable is "english" or the first valid language if English is not available.
@vindex cfg.frontends
@item cfg.frontends
This variable should point to an array (@pxref{Tables}) containing @ref{Strings,,strings} with the names of the frontends you want to include. Valid values are: "gtk", "fltk", "ncurses". The default is @code{@{ "gtk", "fltk", "ncurses" @}}.
@vindex cfg.intropic
@item cfg.intropic
An optional variable containing a @ref{Strings,,string} with the file name of a picture to use in the welcomescreen. Valid file formats are png, jpeg, bmp and gif. If the size is more than 300x200 px the image will be resized to fit. The file should be placed in the @file{files_extra/} directory or, for backward compatibility, in the main project directory.
@vindex cfg.languages
@item cfg.languages
An array (@pxref{Tables}) with @ref{Strings,,strings} containing the names of the languages to include for translations. The language names should be the same as the name of the subdirectories in the @file{lang/} directory from your project directory. The default is @code{@{ "english", "dutch" @}}.
@vindex cfg.logo
@item cfg.logo
An optional variable containing a @ref{Strings,,string} with the filename of a picture to use as a logo. Valid file formats are png, jpeg, bmp and gif. The file should be placed in the @file{files_extra/} directory. If unspecified a default logo is used.
@vindex cfg.mode
@item cfg.mode
Sets if the installer should be attended, unattended or both. Valid values are @code{"attended"} (default), @code{"unattended"} and @code{"both"}. When @code{"both"} is used, the user needs to pass the @minus{}@minus{}unattend (or @minus{}u) commandline option to start an unattended installation.
@vindex cfg.targetarch
@item cfg.targetarch
A variable that should contain an array (@pxref{Tables}) of @ref{Strings,,strings} for the CPU architectures this installer should support. Nixstaller currently only supports @samp{x86} and @samp{x86_64}. This variable will default to the current CPU arch when not specified.
@vindex cfg.targetos
@item cfg.targetos
An array (@pxref{Tables}) of @ref{Strings,,strings} holding the names of the OSs (Operating Systems) which the installer should support. The OS names should be the lower cased output from the shell command @command{uname}. If not specified the variable will default to the current OS.
@vindex cfg.unopts
@item cfg.unopts
This variable is a @ref{luamap, map} that holds all commandline arguments used by unattended installations. Each parameters has a @emph{long} and a (optional) @emph{short} name. The long name is used to index this map. The values in the map are @ref{records}, containing a few variables to configure the commandline argument. Each record can have the following fields:
@table @code
@item desc
Contains a description for this argument (used by the installer to give usage information).
@item optname
A parameter can be used to set values (see below). The @code{optname} variable contains a @code{string} containing a @emph{short} (few characters at most) name for the variable or setting that it will be used for. Like @code{desc} this variable is used to display usage information.
@item opttype
This variable is used to specify what kind of data this argument can be set. Valid values are: @code{"string"} (uses the given value directly), @code{"list"} (argument expects a comma seperated list, which will be automatically converted to a Lua table) and @code{nil} (None, this is the default). Note that when @code{opttype} is not @code{nil}, @code{optname} has to be set as well.
@item short
This variable should contain a string of exactly 1 character, and is used as a short alternative for this parameter.
@end table
To make things more clear, here is an example:
@codeblock{cfg.unopts["opt"] = @{ desc = "My first option.", short = "o" @}
cfg.unopts["varopt"] = @{ desc = "Second option, used to set a variable.", optname = "var", opttype = "string"  @} }
The user could then run the installer (assuming that cfg.mode is set to unattended) like this: @*
@command{./setup.sh -o --varopt "My user value"}
@end table

Finally there are a few functions inside the @code{cfg} module that can be used to add a few common commandline arguments for unattended installers. These are:
@luafunc cfg.adddestunopt ()
This function will add an option to set the destination directory (@code{install.destdir}, discussed further).
@endluafunc
@luafunc cfg.addlicenseunopts ()
This function will add two parameters: the first will print the license agreement and quit. The second will accept the license. When this function is called, the user must use the second parameter to start the installation.
@endluafunc
Besides these functions there is also the @code{pkg.addpkgunopts} function. This function is discussed in the next section.

Here is a final example @file{config.lua} file with all the above variables (excluding @code{cfg.unopts}):
@codeblock{@minus{}@minus{} Example showing most cfg variables
cfg.appicon = "myicon.xpm"
cfg.appname = "Test App"
cfg.archivetype = "gzip"
cfg.autolang = true
cfg.defaultlang = "english"
cfg.frontends = @{ "fltk" @}
cfg.intropic = "intro.png"
cfg.logo = "mylogo.png"
cfg.languages = @{ "english" @}
cfg.mode = "both"
cfg.targetarch = @{ "x86" @}
cfg.targetos = @{ "sunos", "netbsd", "linux" @}}

@section Package configuration
This file is only relevant when using @ref{pkgmode,,Package Mode}. Like @file{config.lua} this file is fairly simple and is only used for setting up Lua variables. All the variables are inside the @code{pkg} package. Descriptions of them are listed below.

@table @code
@vindex pkg.autosymmap
@item pkg.autosymmap
Symbol map files are not discussed yet, they are described @ref{symmap, here}. If set to @code{true} (the default), @code{geninstall.sh} will automaticly create a symbol map file if it's non existant. For this to work it's important that the @code{pkg.bins}, @code{pkg.libs} and @code{pkg.deps} fields are set up correctly. Note that this file is not saved to the project directory but directly inside the installer package itself.
@vindex pkg.bindir
@item pkg.bindir
This variable should contain a @ref{Strings,,string} describing the location of the binary directory. When unspecified, a reasonable default is chosen for the user's system (mostly @file{/usr/local/bin}).
@vindex pkg.bins
@item pkg.bins
This variable holds an array (@pxref{Tables}) with @ref{Strings,, strings} pointing to any executables, relative to the @emph{data directory}. These are used for the generation of @emph{binary scripts}.
@vindex pkg.deps
@anchor{pkg.deps}
@item pkg.deps
A @code{table} containing @code{strings} of all dependency names. Note that only @emph{direct} dependencies have to be specified here (ie. dependencies for the main software, not from other dependencies).
@vindex pkg.description
@item pkg.description
A description of the software to be installed. Usually not longer than a few sentences.
@vindex pkg.destdir
@item pkg.destdir
A @ref{Strings,,string} containing the destination directory for the data directory. When unspecified a reasonable default is chosen for the user's system (mostly @file{/usr/local/share}).
@vindex pkg.enable
@item pkg.enable
Boolean variable which tells whether Package Mode is enabled or not, default it's @code{false} (disabled).
@vindex pkg.externdeps
@anchor{pkg.externdeps}
@item pkg.externdeps
Table containing the names of all (including @emph{indirect}) dependencies that are external and need to be downloaded during installation. Note that each dependency given here, has to have their @code{baseurl} set for this to work (discussed later in this chapter).
@vindex pkg.group
@item pkg.group
This variable should contain a @ref{Strings,,string} describing a valid @emph{package group}. Some package managers assign to each package a package group. Nixstaller has it's own range of package groups, these are translated to a similar group from the native package manager when the package is generated. Valid groups are listed in the table below.
@starttable{.5, .5}
@addtableheaderrow{Package Group}
    @addtableheadercol{Description}
@endtablerow

@addtablerow{Archiving}
    @addtablecol{Software used for archiving data.}
@endtablerow

@addtablerow{Communication}
    @addtablecol{Software used for communication.}
@endtablerow

@addtablerow{Databases}
    @addtablecol{Software related to databases.}
@endtablerow

@addtablerow{Development-languages}
    @addtablecol{Software related to any programming language.}
@endtablerow

@addtablerow{Development-libraries}
    @addtablecol{Libraries used for development.}
@endtablerow

@addtablerow{Development-tools}
    @addtablecol{Tools that can aid in developing software.}
@endtablerow

@addtablerow{Documentation}
    @addtablecol{Anything related to documentation.}
@endtablerow

@addtablerow{Editors}
    @addtablecol{Software used for editing text.}
@endtablerow

@addtablerow{File}
    @addtablecol{Software used for file managing.}
@endtablerow

@addtablerow{Games}
    @addtablecol{Anything related to games.}
@endtablerow

@addtablerow{Graphics}
    @addtablecol{Graphics software.}
@endtablerow

@addtablerow{Libraries}
    @addtablecol{Libraries that can be used for other software.}
@endtablerow

@addtablerow{Multimedia}
    @addtablecol{Anything related to multimedia applications.}
@endtablerow

@addtablerow{Network}
    @addtablecol{Software used for networking.}
@endtablerow

@addtablerow{Perl}
    @addtablecol{Perl related software.}
@endtablerow

@addtablerow{Shells}
    @addtablecol{Commandline shells.}
@endtablerow

@addtablerow{Sound}
    @addtablecol{Anything related to sound, such as mp3 players.}
@endtablerow

@addtablerow{System}
    @addtablecol{System administration tools.}
@endtablerow

@addtablerow{Text}
    @addtablecol{Tools related to text processing.}
@endtablerow
@endtable

@vindex pkg.libs
@item pkg.libs
As @code{pkg.bins}, but for all main (dynamic) libraries (ie. libraries not coming from dependencies, but from the software itself). This field is used for dependency checking.
@vindex pkg.license
@item pkg.license
This (optional) variable should contain a @ref{Strings,,string} describing the used software license.
@vindex pkg.maintainer
@item pkg.maintainer
This variable should contain a @ref{Strings,,string} describing the author's of the installer, usually with an e-mail address after that.
@vindex pkg.name
@item pkg.name
This variable should contain a @ref{Strings,,string} describing the name of the package to be installed. Usually this is a simple, lower cased name without spaces.
@vindex pkg.register
@item pkg.register
A boolean variable which tells to enable or disable package registration. When unspecified it defaults to @code{true}.
@vindex pkg.release
@item pkg.release
This variable contains the release version. This can be seen as the version of the installer itself. In other words it's only bumped when the installer itself has changed, but the software it's going to install is not. When unspecified it defaults to @code{1}.
@vindex pkg.setkdeenv
@item pkg.setkdeenv
If this boolean variable is set to @code{true}, the shell variable @var{KDEDIRS} is set up so that KDE programs can be executed normally. Usually you want to enable this for any KDE software. Default: @code{false}.
@vindex pkg.summary
@item pkg.summary
A @ref{Strings,,string} variable containing a small (not more than one line) description of the software.
@vindex pkg.version
@item pkg.version
This variable should contain a @ref{Strings,,string} containing the version of the software to be installed.
@vindex pkg.url
@item pkg.url
This (optional) variable should contain a @ref{Strings,,string} describing an URL to the software's homepage.
@end table

@findex pkg.addbinopts
To define any commandline arguments for binary scripts, the @code{pkg.addbinopts} function is used. This function accepts 2 arguments: the first is the relative path to the binary being executed (equally defined as in @code{pkg.bins}), the second a @code{string} containing any commandline arguments. Note that this function can also be called inside @file{run.lua}, this may especially be useful in case the arguments need to be determined during installation.

@findex pkg.addbinenv
To define shell variables in binary scripts, the @code{pkg.addbinenv} function should be used. This function accepts three (string) arguments. The first is the name of the variable and the second the value for this variable. The third argument is optional, if specified it should contain one of the binaries specified in @code{pkg.bins}. When the third argument is specified, the given variable is only set for this binary script, otherwise the variable is set for every binary script.

@findex pkg.addpkgunopts
Finally the @code{pkg.addpkgunopts()} function is used to add a few common commandline arguments for unattended installations. These include parameters for: allow to overwrite a package, setting the binary and data directory, amount of download retries and some others. This function accepts one argument, if it's @code{true} the function will add a few arguments specific for dependency checking. @strong{Note:} Always call this function @emph{after} @code{pkg.register} is set.

An example of usage from the previously discussed variables and the @code{pkg.addbinenv} function is shown below.
@codeblock{pkg.enable = true @minus{}@minus{} Important
pkg.autosymmap = true
pkg.name = "test"
pkg.version = "1.0a"
pkg.release = "1"
pkg.maintainer = "Rick Helmus <rhelmus_AT_gmail.com>"
pkg.url = "www.rick-soft.org"
pkg.bins = @{ "bin/test" @}
pkg.libs = @{ "lib/libtest.so.1" @}
pkg.license = "GPLv2"
pkg.description = [[
This package is nothing more than a test package.
The description field can contain multiple lines, as is shown here
]]
pkg.summary = "A test package"
pkg.group = "File"
pkg.destdir = "/usr/local/share"
pkg.bindir = "/usr/local/bin"
pkg.register = true
pkg.deps = @{ "dep1", "dep2" @}
pkg.externdeps = @{ "dep2" @}
pkg.setkdeenv = false
pkg.addbinopts("bin/test", "@minus{}@minus{}some-argument")
pkg.addbinenv("TEST_VER", "1")
pkg.addpkgunopts(true)}


@section Installation process configuration
The Lua script @file{run.lua} is used to control the install process. Although this file is optional, it's pretty common to have one. Generally speaking, the following things can be accomplished using this file:
@itemize @bullet
@item Configuring the installation process itself, such as the creation and selection of installation screens.
@item Parsing any commandline arguments for unattended installs.
@item Executing and programming the installation process.
@end itemize

There are a few (optional) functions that are called automatically. First of all there are two initialization functions: @code{Init()} and @code{UnattendedInit()}. As the name suggests, both functions are used for initialization. The first is called during attended installations, while the second is called for unattended installations. This seperation is done because the initialization process commonly differs between both install modes. Both functions are (when existant) called as soon as the installer launches. When the installation starts the @code{Install()} function is called. This function contains all the code to commit the installation. Finally when the installer exits, the @code{Finish()} function will be called. This function can be used to clean things up. Notice that this function is also called when the installer aborts (for example the user cancelled the installation or an error occured). When this happens, the first argument given to this function will be @code{true}, otherwise it will be @code{false}.

The file layout generally looks like this:
@codeblock{@minus{}@minus{} For attended installations
function Init()
    @minus{}@minus{} Set the install destination path
    @minus{}@minus{} Create new installation screens
    @minus{}@minus{} Set which screens to use
end
@*
@minus{}@minus{} For unattended installations
function UnattendedInit()
    @minus{}@minus{} Set the installation path (if not given by the user)
    @minus{}@minus{} Parse any commandline arguments given.
end
@*
function Install()
    @minus{}@minus{} Do pre-install things (eg. asking the root password)
    @minus{}@minus{} Extract the installation files
    @minus{}@minus{} Do post-install things (eg. compile the extracted files)
end
@*
function Finish(err)
    @minus{}@minus{} Clean things up
    @minus{}@minus{} Possible launch a program when err is false
end
}

The above items are discussed below.

@subsection Setting the install destination path
The @code{install.destdir} variable is used to specify a destination path for the installation files. Generally there are three choices: use a static directory (eg. /usr), let the user specify it through the @code{SelectDirScreen} (see below) or point it to a temporary directory. The latter is accomplished by assigning the variable to the returned path from @ref{install.gettempdir}. The main purpose for a temporary directory is that the installation files need to be used for further installation (@emph{ie} compiling).


@anchor{deskentrieslua}
@subsection Creating Desktop Menu Entries
Nixstaller is able to create desktop menu entries to let the user easily launch any installed executables (see also @ref{deskentries,,this}). To accomplish this we have to create a new @ref{Tables,,table} which contain fields that can be used for the creation of a @file{.desktop} file. Any field that is defined inside this table is directly used inside the @file{.desktop} file.@*
For example:
@codeblock{deskentry = @{ @} @minus{}@minus{} Create a new table
deskentry.Name = "My application"}
When the @file{.desktop} file is generated, this table would be translated to the following:
@codeblock{Name = My Application}
@*
Any of these tables should be stored inside the @code{install.menuentries} variable. This variable itself is a table aswell, it is indexed by @ref{Strings,,strings} which represent the filename for this menu entry (without the .desktop part).@*
@*
Besides the @code{Name} field in our example, there are at least two other fields which are common to have. The @code{Icon} field is used to specify a path to a filename used for an icon. The @code{Categories} field can be used to specify to which category or categories this software belongs. Valid categories and more info about these and many other fields are described in the @uref{http://standards.freedesktop.org/menu-spec/latest/,desktop menu specification from the freedesktop project}.@*
@*
For convenience and because some fields are mandatory, it's better to use the @code{install.newdesktopentry} function to create a table. This function requires three arguments: the first is a path to the executable, the second argument is a path to a logo for the menu entry (use @code{nil} for none), the last argument describes one or more categories for this menu entry. This function will also automatically set the @code{Name} field to @code{cfg.appname}, the @code{Type} field to "Application" and the @code{Encoding} field to "UTF-8".@*
Here is some example usage:
@codeblock{@minus{}@minus{} This will create a new desktop entry, which will be stored to @file{myapp.desktop}
install.menuentries["myapp"] = install.newdesktopentry("/usr/local/bin/myapp",
                                                       "/usr/local/share/myapp/logo.png",
                                                       "Utility")}

The actual installation of the menu entries is controlled by the @code{install.gendesktopentries}, which is discussed later in this chapter.


@subsection Installation screens
As discussed before, installation screens are meant to let the user interact with the installer. You can use @emph{predefined} screens or create new screens. Obviously, unattended installations will not support any installation screens and will fail if you try to use them.

The following predefined screens exist:
@anchor{instscreens}
@table @code
@vindex WelcomeScreen
@item WelcomeScreen
The screen that is usually shown at first. This screen can be used to display a graphic image (defined via @code{intropic}, see @ref{config.lua}) and display an introduction message (via the @file{welcome} file, see @ref{welcome license finish, this section}). If this file doesn't exist the screen won't be displayed.
@vindex LicenseScreen
@item LicenseScreen
Is used to display a license agreement specified through the @file{license} file (see @ref{welcome license finish, this section}). If this file doesn't exist the screen won't be displayed.
@vindex SelectDirScreen
@item SelectDirScreen
This screen lets the user select a directory that will be stored in the @code{install.destdir} variable.
@vindex InstallScreen
@item InstallScreen
When this screen is shown the installation begins and displays the current status. Obviously every installer should have one.
@vindex FinishScreen
@item FinishScreen
Displays the message defined through the @file{finish} file (see @ref{welcome license finish, this section})). If this file doesn't exist the screen won't be displayed.
@end table

To tell which installation screens you want to use and in what order you should put them in the @code{install.screenlist} @ref{Tables,, table}. The screen at the first table entry is shown first, then the second entry is shown etc. By default @code{install.screenlist} contains all the predefined screens.@*
@*

@subsection Creation of new installation screens
Besides using the predefined screens, new screens can be created aswell. The primary reason for creating new screens is to let the user be able to configure certain settings which affect the installation process. To create a new screen we call the @ref{install.newscreen} function. This function accepts one optional @ref{Strings,,string} which is used to give this screen a title. The function returns a variable pointing to a @ref{Classes,,class} which we can use to modify the screen. The screen can contain several @emph{widgets}. Here is a table showing them:
@*
@starttable{.33,.33,.33}
@addtableheaderrow{Widget}
    @addtableheadercol{Description}
    @addtableheadercol{Function}
@endtablerow

@addtablerow{Check box}
    @addtablecol{One or more options that the user can enable.}
    @addtablecol{@ref{screen:addcheckbox}}
@endtablerow

@addtablerow{Config menu}
    @addtablecol{A menu that will let the user configure certain parameters in a logic way.}
    @addtablecol{@ref{screen:addcfgmenu}}
@endtablerow

@addtablerow{Directory Selector}
    @addtablecol{Adds an inputfield to specify a directory path and a button next to it to open a directory browser.}
    @addtablecol{@ref{screen:adddirselector}}
@endtablerow

@addtablerow{Image}
    @addtablecol{Shows an image file. The image is scaled if it's size is over 300x200 px. Valid file formats are: png, jpeg, gif and bmp.}
    @addtablecol{@ref{screen:addimage}}
@endtablerow

@addtablerow{Input Field}
    @addtablecol{A single line inputfield where the user can specify text.}
    @addtablecol{@ref{screen:addinput}}
@endtablerow

@addtablerow{Label}
    @addtablecol{Shows one or more lines of text.}
    @addtablecol{@ref{screen:addlabel}}
@endtablerow

@addtablerow{Menu}
    @addtablecol{A menu (or listbox) widget that lets the user select an item from a list.}
    @addtablecol{@ref{screen:addmenu}}
@endtablerow

@addtablerow{Progressbar}
    @addtablecol{Bar showing the progress of a certain process.}
    @addtablecol{@ref{screen:addprogressbar}}
@endtablerow

@addtablerow{Radiobutton}
    @addtablecol{A list of options from which the user can enable one.}
    @addtablecol{@ref{screen:addradiobutton}}
@endtablerow

@addtablerow{Textfield}
    @addtablecol{Widget that is used to show multiple lines of text. Lets the user scroll it when necessary.}
    @addtablecol{@ref{screen:addtextfield}}
@endtablerow

@endtable
For a detailed explanation of a widget see the links shown in the @samp{Function} column.@*
@*

@subsubsection Controlling and Tracking Screen Activation
By defining a @code{canactivate} function inside the screen's class we can tell if this screen is able to activate or not. When the function returns @code{false} this screen is skipped and a next screen will be checked. If the function returns @code{true} the screen will be activated, this is default behaviour.@*
@*
When an @code{activate} function is defined inside the screen's class it will be called when the screen is actually activated. Note that @code{canactivate} may be called multiple times, for this reason put any code that is required when the screen is activated in the @code{activate} function and not in the @code{canactivate} function.

@subsubsection Execute code when a screen is activated
To execute code during when the screen is activated, you should define a @code{update} function inside the screen class. This function will be called several times a second. You can use this to update widgets (for example enabling or disabling them) or check any background processes.

@subsubsection Widget Placement
The widgets are placed vertically in order. When there is no room for a widget the screen is split into one or more @emph{subscreens}. Each subscreen has the same title as the original screen and has a @emph{counter} that shows current subscreen in the form X/Y where X is the current screen and Y the total number of subscreens. When the widget does not fit into a new subscreen or does not fit horizontally an error will be thrown. If a widget fits or not depends on each frontend and how the widget is configured. For this reason always verify the installer for each frontend!

Widgets can be horizontally grouped aswell. To do this a special @emph{group widget} needs to be created which will hold one or more widgets. The @ref{screen:addgroup} function creates a new group widget and returns a variable pointing to the group's @ref{Classes,,class}. The same functions for install screens are used to add widgets to a group widget. However these functions are called via the group's own class, @emph{ie} @code{group:addinput} (where @code{group} is a group widget variable).

@subsubsection Tracking Widget Behaviour
Commonly you may want to keep track of your widgets, for example to handle data changes or verify user input. For this 2 functions can be defined @emph{in the widget class}. The first function, called @code{datachanged}, is called by the widget as soon as the user changes any data from the widget (@emph{ie} when the user selects a menu option). The second function, called @code{verify}, is called when the user presses the @samp{Next} button. When this function returns @code{false} the corresponding widget will get focus and the current installation screen remains active.

@subsubsection Widget activation
Each widget can be enabled or disabled. This is done via the @code{enable()} member function. This function requires one argument, which should be @code{true} or @code{false} to enable or disable the widget respectively.

@subsubsection Example
An example @code{Init} function is shown below, which covers anything we just discussed.
@codeblock{@minus{}@minus{} Example run.lua file
function Init()
    install.destdir = install.gettempdir()
@*
    myscreen = install.newscreen("Hello!\\nYou can use this screen to configure some settings.")
@*
    function myscreen:canactivate()
        return true @minus{}@minus{} This is the default behaviour
    end
@*
    function myscreen:activate()
        @minus{}@minus{} Show messagebox when screen is activated
        gui.msgbox("Hello")
    end
@*
    namefield = myscreen:addinput("Your name")
@*
    function myscreen:update()
        @minus{}@minus{} Enable widget when checkmyprocess() (some random example function) returns true
        if checkmyprocess() then
            namefield:enable(true)
        else
            namefield:enable(false)
        end
    end
@*
    function namefield:datachanged()
        @minus{}@minus{} Display messagebox as soon user changes any data from the inputfield
        gui.msgbox("Datachanged!")
    end
@*
    function namefield:verify()
        if (#namefield:get() == 0) then @minus{}@minus{} Empty string?
            gui.msgbox("Please type something")
            return false @minus{}@minus{} Don't go any further
        end
        return true @minus{}@minus{} Proceed as usual
    end
@*
    @minus{}@minus{} Group 2 widgets next to eachother
    group = myscreen:addgroup()
    check1 = group:addlabel("Left label.")
    check2 = group:addlabel("Right label.")
@*
    install.screenlist = @{ WelcomeScreen, myscreen, InstallScreen @}
end}

This function does the following things:
@itemize @bullet
@item
The @code{install.destdir} variable is set so that files are extracted to a temporary directory.
@item
A new screen is created, with the following title
@quotation
Hello!@*
You can use this screen to configure some settings.
@end quotation
@item
A @code{canactivate} and an @code{activate} function is defined for the screen. The first function tells that the screen may be displayed (this is the default and is only shown here for example usage). The second function will show a messagebox as soon as the screen is activated.
@item
An inputfield widget is created on our new screen labeled with "Your name". We define 2 functions to keep track of any data changes and to verify if the user typed anything.
@item
An @code{update} function is defined inside the screen calls to enable or disable the inputfield widget.
@item
Two label widgets are created and grouped next to eachother.
@item
Finally we define which screens should be shown and in which order. In our case first the welcome screen will be displayed, following by our custom screen and ending with the installation screen.
@end itemize

@subsection Handling commandline arguments
As said, unattended installations use a seperate function (@code{UnattendedInit()}) for initialization. A common thing to do in this function is to handle any given commandline arguments. As described at the start of this chapter, commandline arguments are configured through the @code{cfg.unopts} variable. This same variable is also used to use them during installation. Any given commandline arguments will have their @code{value} record variable set, depending on their @code{opttype}. When the @code{opttype} is set to @code{"string"} then @code{value} will also be a @code{string}. When @code{opttype} is set to @code{"list"} then @code{value} will be a table (array). In case @code{opttype} was not set (or is set to @code{nil}), @code{value} will be @code{true} incase the commandline argument was given.

Here is an example @code{UnattendedInit()} function:
@codeblock{function UnattendedInit()
    local myvar = cfg.unopts["myvar"].value or "default" @minus{}@minus{} See @ref{and or trick}
    if cfg.unopts["myswitch"].value then
        enableswitch = true
    end
end}

@subsection The installation process
By defining an @code{Install()} function we can control the installation process. If this function is not defined a default is generated and looks like this:
@codeblock{function Install()
    install.extractfiles()
end}
The @ref{install.extractfiles} function is used to extract the installation files to the path defined by @code{install.destdir}.@*
@*
There are various Lua functions that can be used for installation. Files can be read or created with the @ref{io, io package} and there are various functions that work with the OS (Operating System) of the user in the @ref{os, os package}.@*
@*
A common thing is to execute various shell commands. For this three functions are generally used:
@table
@item @ref{install.execute}
This function will execute a shell command and show all the generated output in a window.
@item @ref{install.executeasroot}
As @code{install.execute}, but the command is executed as the root user. If the root password is not given yet the user will be asked to type it.
@item @ref{install.askrootpw}
Asks the user to type the root password. If this has been done before the function doesn't do anything. Mostly this function is used somewhere at the beginning of the @code{Install} function so that the user knows root access is required before the installation begins and can abort if he or she wants to.
@end table

To let the user know what is happening there are three functions that can be used:
@table
@item @ref{install.print}
Displays a given string on the status window from the install screen.
@item @ref{install.setstatus}
Can be used to set a short status message on the top of the install screen.
@item @ref{install.setstepcount}
Sets how many @emph{steps} the installation has. Follow the link for more information.
@end table

If you've created any desktop menu entries, the @ref{install.gendesktopentries} function needs to be called to install them. This function is usually called after @code{install.extractfiles} and before @code{install.generatepkg} (the latter function is only used for Package Mode and is discussed later). The @code{install.gendesktopentries} function needs one boolean argument. If this argument is @code{true} the desktop entries are installed globally (accessible to any user), when it is @code{false} the entries are only installed for the current user. One way to decide if the entries should be installed globally or not, is to check if the destination directory is writeable for the user. If this directory is writeable it can be assumed that the install went locally (and thus the function argument should be @code{false}).
In the @file{run.lua} file you could use something like the code below to achieve this.
@codeblock{install.gendesktopentries(not os.writeperm(install.destdir)}

To finish this section here is an example of an @code{Install()} function.
@codeblock{@minus{}@minus{} Example Install() function
function Install()
    install.setstepcount(2) @minus{}@minus{} Note that extracting files counts automatically as one step
    install.extractfiles()
    install.setstatus("Executing random command")
    install.execute("ls -a") @minus{}@minus{} Contents of directory pointed by install.destdir variable will be displayed
@*
    @minus{}@minus{} Example of how to use data from the widget used in the example from previous section.
    gui.msgbox("Your name is: ", namefield:get())
end}

We start with defining the number of installation steps (2). Then the installation files are extracted to the directory that is defined by the @code{install.destdir} variable (see previous section). Then the status message is changed and a random shell command is executed. The last line shows how to retrieve a value with the @ref{input:get, get method function} from the inputfield class.


@subsection The @code{Finish()} function
As been said, this function will be called as soon as the installation ends. The function will be called with one argument which is @code{true} in case the installation did not end normally (for example the user aborted the installation or an error occured). You can use this function to clean any temporary resources or launch another program for example. The latter happens in the given example:
@codeblock{function Finish(err)
    if not err then
        @minus{}@minus{} The ampersand (@samp{&}) is important, this keeps the software running when the installer exits
        os.execute("/usr/bin/guiapp &")
    end
end}
@strong{Note}: You cannot use any GUI functions (ie. functions from the @code{gui} package) inside this function.


@subsection Unattended installations
As some functionality requires user interaction, these are not available when the installer runs unattended. This may important when @code{cfg.mode} is set to @code{"both"}, where both installation types are possible. The @code{install.unattended} variable is set to @code{true} when the installer runs unattended. By checking this variable, you will have to make sure that no missing functionality is used during unattended installs. Functionality that @emph{cannot} be used during unattended installations:
@itemize @bullet
@item Installation screens
@item Functions from the @code{gui} package.
@item @ref{install.lockscreen}
@end itemize
Also note that when @code{install.askrootpw()} or @code{install.executeasroot()} is called during unattended installs, these functions will fail and print a message in case the installer does not run as the root user. This way the installer will be forced to run as the root user.


@subsection Package Mode
When using Package Mode, besides creating a @file{package.lua} file we have to set up a few things in @file{run.lua} aswell.

@subsubsection Temporary Package Directory
As described in the previous chapter (described @ref{pkgmode,,here}) the files to be installed need to be placed in the @emph{temporary package directory}. To retrieve the location of this directory the @code{install.getpkgdir} Lua function is used.@*
@*
For some installations it might be enough to set @code{install.destdir} to this location. The packaged files are extracted to the temporary package directory and are used directly for installation.@*
@*
For other installations, it might be necessary to first extract any files to a different place (setting @code{install.destdir} with @code{install.gettempdir()}) and place the files to be installed in the temporary package directory later. A good example is when software has to be compiled.

@subsubsection Generating the package
After @code{install.extractfiles} is called in the @code{Install()} function inside @file{run.lua}, @code{install.generatepkg()} should be called. This function will do the actual packaging and installing of the software.@*
Note: This function should always be called @emph{after} @code{install.gendesktopentries()}.

@subsubsection Specific Installation Screens
A few predefined installation screens exist specifically for Package Mode. These are listed below.
@table @code
@vindex PackageToggleScreen
@item PackageToggleScreen
Lets the user enable or disable package registration (setting @code{pkg.register}). This screen is not shown in case the installer is unable to register a package.
@vindex PackageDirScreen
@item PackageDirScreen
This screen lets the user specify the locations for the data and binary directory (let the user set @code{pkg.destdir} and @code{pkg.bindir}).
@vindex SummaryScreen
@item SummaryScreen
This screen is usually put just after the @code{InstallScreen}. It will show the user some info about the installed software, which files are installed and how the software can be uninstalled.
@end table
Like any other installation screens, these screens should be placed inside the @code{install.screenlist} variable.

@subsubsection Retrieving the Data and Binary directories
@findex pkg.getdatadir
@findex pkg.getbindir
In some cases during installation, you may need to retrieve the real paths to the data or binary directory. For this the functions @code{pkg.getdatadir()} and @code{pkg.bindir()} exists. Both functions accept one optional (string) argument. The @code{pkg.getdatadir} function will simply combine this argument with the path of the data directory. The @code{pkg.getbindir} function use it's argument to return the path to the binary script used for the given binary (relative to the data directory). If no argument is given to one of these functions, @code{pkg.getdatadir} simply returns the path to the data directory and @code{pkg.getbindir} returns the path the binary directory.@*
@*
A good example for using these functions is for the creation and installation of desktop menu entries. This is best illustrated in an example:
@codeblock{function Init()
    @minus{}@minus{} ...
    install.menuentries["test"] = install.newdesktopentry(pkg.getbindir("bin/test"),
                                                          pkg.getdatadir("logo.png"),
                                                          "Utility")
    @minus{}@minus{} ...
end
@*
function Install()
    @minus{}@minus{} ...
    install.gendesktopentries(not os.writeperm(pkg.getdatadir()))
    @minus{}@minus{} ...
end}
At first, in the @code{Init()} function, a new desktop menu entry is created. The @code{pkg.getbindir} function is used to retrieve the location of the binary script that is used to launch @file{bin/test} inside the data directory. The @code{pkg.getdatadir} is used to retrieve the location of a logo inside the data directory.@*
After that @code{install.gendesktopentries} is called to install the desktop menu entry. To see if the entry needs to be installed globally, the write permissions of the data directory are checked. If the user cannot write to it, it is assumed the installation went with root access and therefore the package was not installed locally.

@subsubsection Permissions
It's important that installed files have the right permissions set. For most software it's common to follow these rules:
@starttable{.5,.5}
@addtableheaderrow{File type}
    @addtableheadercol{Owner permissions}
    @addtableheadercol{Group permissions}
    @addtableheadercol{Other permissions}
@endtablerow

@addtablerow{Directories}
    @addtablecol{Read, write and executable}
    @addtablecol{Read and executable}
    @addtablecol{Read and executable}
@endtablerow

@addtablerow{Executables (binaries, scripts etc)}
    @addtablecol{Read, write and executable}
    @addtablecol{Read and executable}
    @addtablecol{Read and executable}
@endtablerow

@addtablerow{Other files (eg. data files)}
    @addtablecol{Read and write}
    @addtablecol{Read}
    @addtablecol{Read}
@endtablerow

@endtable

You can either set the permissions before generating the installer or during installation; just make sure that they are set before calling @code{install.generatepkg}.@*
@*
@findex pkg.setpermissions
An easy way to set up permissions automatically during installation is to use the @code{pkg.setpermissions} function. This function will traverse the whole temporary package directory and set up permissions following the rules in the table previously shown.@*
@*
Note that when using tools such as @samp{automake} permissions may also be automatically set up when they are told to install files (eg. @command{make install}).

@subsubsection Miscellaneous
The @code{pkg.needroot()} function can be used to check if the @code{install.generatepkg} function needs root permissions. This is especially useful in combination with @ref{install.askrootpw} because the user can then be asked to enter the root password before the installation begins.


@subsection Using @samp{runtime files}
Any files that were put in the @file{extra_files/} directory can be accessed during or before the installation through the @ref{install.extrafilespath} function. This function returns a path to where you can find these files. The function accepts one optional argument containing a @ref{Strings, string} describing a filename. This filename is purely for convenience and is simply appended to the returned value. Example: assuming we put a file called @file{readme.txt} in the @file{extra_files/} directory, we can access it as follows:
@codeblock{readmefilepath = install.extrafilespath("readme.txt")}


@section Dependencies
Dependencies are configured through one Lua script. This script is called @file{config.lua}, not to be confused with the Lua script for the main installer configuration.

The structure of this script looks like this:
@codeblock{local dep = pkg.newdependency()
@minus{}@minus{} Set several dependency variables, such as a description, what libraries it provides etc.
return dep}

@findex pkg.newdependency
As you can see at first the @code{pkg.newdependency()} function is called. This function will create a new @code{table}, which is used to fill in the dependency information. This @code{table} is actually a @ref{Classes,,class} and will now be referred as the @emph{dependency class}. The @code{class} is assigned to a @code{local} variable simply to keep this information to the script file itself.

After the @code{class} is created, any @code{member variables} need to be filled in that are used to configure the dependency. These variables are (@code{dep} refers to the dependency class variable):

@defvr Variable dep:baseurl
In case this dependency is set as external, that is it's included in the @ref{pkg.externdeps} @code{table}, this field is used to specify the @emph{base URL} from where the installer must download all the relevant dependency files. These files are discussed in the next chapter. The URL should point to a directory (on the server) where these files can be found.
@end defvr
@defvr Variable deps
This is essentially the same as @ref{pkg.deps}, but used for dependencies of the dependency itself.
@end defvr
@defvr Variable description
Should contain a @code{string} with a short (max 1 line) description for this dependency.
@end defvr
@defvr Variable full
A @code{boolean} variable, that must be set to @code{true} in case this dependency is full (simple and full dependencies were discussed @ref{simplefulldeps,,here}). The default is @code{true}.
@end defvr
@defvr Variable libs
A @code{table} (array) containing all the @emph{file names} (so no (relative) paths) from the libraries this dependency provides.
@end defvr
@defvr Variable standalone
Should be set to @code{true} if this is a standalone dependency (only applies to full dependencies). Default is @code{true}.
@end defvr

Besides these variables, a few functions can be defined to control the behaviour of this dependency. These functions must be defined inside the dependency class. These functions are listed below (again, the @code{dep} variable refers to the dependency class):
@luafunc dep:caninstall ()
This function is called right before @code{dep:install()} (see below) is called. Return @code{false} in case the dependency cannot be installed for some reason, otherwise return @code{true}. When this function is not defined, one will be automatically created which will always return @code{true}.
@endluafunc
@luafunc dep:handlecompat (lib)
This function is called when a dependency if found to be incompatible (ie. one of the libraries are binary incompatible). The @code{lib} argument contains the file name of the incompatible library. You can use this function to handle these incompatibilities (eg. by compiling the dependency). When the incompatibility is resolved @code{true} should be returned, otherwise @code{false} must be returned. When this function is not defined, one will be automatically created which will always return @code{false}.
@endluafunc
@luafunc dep:install ()
This function will be called when the dependency has to be installed to the @emph{temporary package directory}. An easy way to copy all the dependency files is to call the @code{copyfiles()} function, which is a predefined @code{member function} inside the dependency table. If no @code{install()} function is defined, one will be automatically created which will look like this:
@codeblock{function dep:install()
    self:copyfiles() @minus{}@minus{} For @code{self}, @xref{Classes,,class}
end}
@endluafunc
@luafunc dep:required ()
This function is used to create your own way of detecting dependencies. Normally only dynamic libraries are used to find required dependencies. By returning @code{true} inside this function, the dependency will be marked as required. When this function is not defined, one will be automatically created which will always return @code{false}.@*
Example:
@codeblock{function dep:required()
    @minus{}@minus{} Mark this dependency as required when @file{somebin} is absent.
    return not os.fileexists("/usr/bin/somebin")
end}
@endluafunc


@section Translations
@emph{Any text} that is used by installation screens, widgets or functions indirectly using these (such as @ref{install.setstatus}) can be translated. This also includes option names from widgets such as radiobuttons or menus. Generally speaking: any text that is displayed, besides installation output, can be translated. As discussed before (@pxref{Translations}) the @file{strings} file is used to translate various strings. To translate text used from the @file{run.lua} file, simply add any strings to the @file{strings} file from the desired language in your project directory.

@subsubsection Configuration
Each translation is configured through a Lua script, called @file{config.lua} (not to be confused with the script used for installer configuration). These scripts are pretty small and only contain a few variable assignments. The structure looks like this:
@codeblock{return @{
    @minus{}@minus{} Variable assignments
@}}
In other words, this file return a table containing all the info for a language. The variables that this table can hold are described below.
@table @code
@item name
A @code{string} containing the actual name of this language. This name is usually written in the translated language itself. If not given, the name from the subdirectory of the translation (explained in the next chapter) will be used.
@item utf8
A @code{boolean} variable that should be set to @code{true} if UTF-8 is required. At this point Nixstaller only supports UTF-8 as character set, so this variable is usally @code{true} for anything except English. Default: @code{true}.
@item locales
A @code{table} (array) that holds one or more @code{strings} of relevant locale(s) for this translation. When @code{cfg.autolang} is enabled, this variable is used to see if any of the @code{strings} match the user's locale. Note that there is already a match when one of the @code{strings} are found @emph{somewhere} inside the user's locale @code{string}. This way it's possible to tell that a translation can be used by several locales.
@end table
Here is an example, showing the file that is used for the Dutch translations:
@codeblock{return @{
    name = "Nederlands",
    utf8 = true,
    locales = @{ "nl" @}
@}}
Note that the @code{locales} variable is not a full locale name. This way all locales that have @samp{nl} somewhere in the name (usually at the beginning), will be matched.

@anchor{Translate strings}
@subsubsection Translate strings
In most cases, the actual translation happens automaticly (assuming that the @file{strings} file is set up correctly). In some cases however, you need to do it manually. This is done through the @ref{tr} function. When calling this function with the English @code{string} as first argument, it will return the right translated @code{string} back. One of the reasons to use this function is with strings having @emph{modifiers} in them. These modifiers are presented as one or more @samp{%s} parts in a string. When the string is actually used, any modifiers will be replaced by something else, such as the software's name, an error message, etc. As Nixstaller cannot know which variables to use for this replacement, you will have to do so manually. This can be done by again using the @code{tr} function, however any variables that should be used to replace the modifiers must be given (in order) as following arguments to this function.

Here is an example used by the internal Lua source code:
@codeblock{gui.msgbox(tr("Installation of %s complete!", cfg.appname))}


@node Creating Installers
@chapter Creating Installers

@section Introduction
In this chapter the creation of an installer is discussed. The previous chapters discussed Nixstaller and Lua basics. In this chapter we will use these in practise.


@section Projects
A project for an installer is nothing more than a directory with a certain file layout. This layout generally looks like this:
@itemize @bullet
    @item @file{Project Directory/}
    @itemize @bullet
        @item @file{lang/}
        @itemize @bullet
            @item @file{<language name>/}
            @itemize @bullet
                @item @file{strings}
                @item @file{welcome}
                @item @file{license}
                @item @file{finish}
            @end itemize
        @end itemize
        
        @item @file{files_all/}
        @item @file{files_<os>_all/}
        @item @file{files_all_<arch>/}
        @item @file{files_<os>_<arch>/}
        @item @file{files_extra/}

        @item @file{welcome}
        @item @file{license}
        @item @file{finish}
        
        @item @file{config.lua}
        @item @file{run.lua}
    @end itemize
@end itemize
All these files and directories except @file{config.lua} are optional.


@section The @file{lang} Directory
This directory should contain a subdirectory for every language that you want to supply for translations used by the installer. Nixstaller comes with Dutch translations and English 'translations'. The English 'translations' are used to modify English strings in Nixstaller. You can find the languages in the @file{lang/} directory from the Nixstaller directory. Simply copy these directories to your @file{lang/} directory in your project directory to include them. @*
@*
The previous chapter explained what the @file{strings} file is. Translated version of the @file{welcome}, @file{license} and @code{finish} files can be put in each language-subdirectory.


@section The @file{files_} Directories
As mentioned in the file structure above, there are 4 "@file{files_}" directory types:
@table @strong
@item @file{files_all/}
In this directory you should put all the files to be installed. These will be extracted for any OS and CPU architecture.
@item @file{files_<os>_all/}
In this directory you can put files that will only be extracted if the user's system equals to @samp{<os>}. The @samp{<os>} part should be replaced by a lower cased version from the output of @command{uname} shell command. Some examples: @file{files_linux_all/}, @file{files_sunos_all/}.
@item @file{files_all_<arch>/}
Similar to the previous item, @file{files_<os>_all/}, this directory should contain all the files that need to be installed for a CPU architecture specified by @samp{<arch>}. The @code{<arch>} part should be replaced by either @samp{x86} for Intel 32 bit compatible systems, @samp{x86_64} for AMD 64 bit x86 compatible systems or replaced by the output from the shell command @command{uname -m}. Note that currently there are only @samp{x86} and for some operating systems @samp{x86_64} frontend binaries available.
@item @file{files_<os>_<arch>/}
A combination of the previous two. Examples: @file{files_linux_x86/}, @file{files_freebsd_x86/}.
@item @file{files_extra/}
This directory contains any files needed at runtime. Examples are graphics or text files to show. The files can be accessed with the @ref{install.extrafilespath} lua function.
@end table


@section The @file{welcome}, @file{license} and @file{finish} Files
These files were already discussed in the @ref{Basics,,basics chapter}. Simply put them in the root of your project directory.


@section The @file{config.lua}, @file{package.lua} and @file{run.lua} Files
Lua scripting files were discussed in the @ref{Lua Scripts,,previous chapter}. Simply put the files in the root of the project directory.

@anchor{genprojdir.sh}
@section Automatically Generating Project Directories
As of version 0.3, nixstaller ships a script called @file{genprojdir.sh}. This script is able to save you lot of copying by generating a project directory automatically. The script handles the following things:
@itemize @bullet
@item Creation of a basic directory layout.
@item Language copying.
@item Copy graphics used by the @code{cfg.intropic} and @code{cfg.logo} lua variables to the right place in the project directory.
@item Generating a @file{config.lua} file based on defaults and/or commandline arguments.
@item Generate a @file{run.lua} based on defaults and optionally containing some common code for Package Mode.
@item Generate a template @file{package.lua} file with most variables defined and explaining comments.
@end itemize
The script accepts the following commandline arguments:
@starttable{.5,.5}
@addtableheaderrow{Parameter}
    @addtableheadercol{Description}
@endtablerow

@addtablerownowrap{@minus{}@minus{}help, -h}
    @addtablecol{Displays usage}
@endtablerow

@addtablerownowrap{@minus{}@minus{}appname, -n <name>}
    @addtablecol{Sets @code{cfg.appname}. Default: MyApp}
@endtablerow

@addtablerownowrap{@minus{}@minus{}arch <arch1>[, <arch2>, ...]}
    @addtablecol{Sets @code{cfg.targetarch} to one or more following arguments (<arch1>, <arch2> etc). Default: current CPU arch.}
@endtablerow

@addtablerownowrap{@minus{}@minus{}archtype, -a <type>}
    @addtablecol{Sets @code{cfg.archivetype} to <type>. Default: lzma.}
@endtablerow

@addtablerownowrap{@minus{}@minus{}deflang, -d <lang>}
    @addtablecol{Sets @code{cfg.defaultlang} to <lang>. Default: english}
@endtablerow

@addtablerownowrap{@minus{}@minus{}deps}
    @addtablecol{Add specific dependency code to generated lua scripts. Needs @minus{}@minus{}pkg option.}
@endtablerow

@addtablerownowrap{@minus{}@minus{}frontends, -f <fr1>[, <fr2>, ...]}
    @addtablecol{Sets @code{cfg.frontends} to one or more following arguments (<fr1>, <fr2> etc). Default: gtk fltk ncurses.}
@endtablerow

@addtablerownowrap{@minus{}@minus{}intropic, -i <picture>}
    @addtablecol{Copies the file <picture> to the @file{extra_files/} directory and sets @code{cfg.intropic} accordingly. Default: none.}
@endtablerow

@addtablerownowrap{@minus{}@minus{}languages, -l <l1>[, <l2>, ...]}
    @addtablecol{Sets @code{cfg.languages} to one or more following arguments (<l1>, <l2> etc). Default: english dutch.}
@endtablerow

@addtablerownowrap{@minus{}@minus{}logo <file>}
    @addtablecol{Copies the file <logo> to the @file{extra_files/} directory and sets @code{cfg.logo} accordingly. Default: a default logo (shipped with Nixstaller).}
@endtablerow

@addtablerownowrap{@minus{}@minus{}mode, -m <mode>}
    @addtablecol{Sets the installer mode. Valid values: both, attended, unattended. Default: attended}
@endtablerow

@addtablerownowrap{@minus{}@minus{}no-autolang}
    @addtablecol{Disables automaticly choosing a language.}
@endtablerow

@addtablerownowrap{@minus{}@minus{}os, -o <os1>[, <os2>, ...]}
    @addtablecol{Sets @code{cfg.targetos} to one or more following arguments (<os1>, <os2> etc). Default: current OS.}
@endtablerow

@addtablerownowrap{@minus{}@minus{}overwrite}
    @addtablecol{Overwrite any existing files. Default is to ask.}
@endtablerow

@addtablerownowrap{@minus{}@minus{}pkg}
    @addtablecol{Specifically used for Package Mode. A template @file{package.lua} file will be created and common code for Package Mode will be added to @code{run.lua}.}
@endtablerow

@addtablerownowrap{@minus{}@minus{}rm-existing}
    @addtablecol{Removes any existing files. Default is to ask.}
@endtablerow

@endtable



@anchor{Creating the Installer}
@section Creating the Installer
After you have fully setup your project directory it's time to build the installer script.@*
@*
This is pretty easy and is done via a shell script. It's important to call this script from the main directory of Nixstaller. The script is called @command{geninstall.sh} and has one required argument and one optional argument. The first argument is the path to the project directory, the second is the name of the installer script. The default name is @samp{setup.sh}.@*
@*
Here is an example that shows the shell commands that need to be executed when the path to the Nixstaller directory is @file{/home/rick/nixstaller} and the project directory is at @file{/home/rick/code/setup}:
@codeblock{/home/rick/nixstaller/geninstall.sh /home/rick/code/setup}
The resulting script, @samp{setup.sh}, is placed in the current directory.


@section Examples
For examples of project directory layouts see the @samp{example/} directory in the main Nixstaller directory. The @ref{Tutorials, tutorials} will also present some examples step by step.


@node Tutorials
@chapter Tutorials
This chapter lists 4 tutorials which show some common installation types in practise.@*
@*
The @ref{first tutorial} explains how to create a very simple installer. The main focus of this tutorial is as an introduction to Nixstaller and how to perform most of the basics.@*
@*
The @ref{second tutorial} is more realistic, but still fairly simple. It expands on the basics and introduces the creation of new installation screens.@*
@*
The @ref{third tutorial} is pretty advanced. The main focus lies on how to create new installation screens and use their widgets to control the installation process.@*
@*
The @ref{fourth tutorial} focuses on Package Mode and inclusion of dependencies.


@anchor{first tutorial}
@section First Tutorial: A Simple Installer
This first tutorial describes the steps that need to be done to create a simple installer.@*
@*
We want to let the installer be able to do the following things:
@itemize @bullet
@item Let the user select a language.
@item Show a short introduction message.
@item Let the user select a destination directory (or in other words, let the user define the @code{install.destdir} variable).
@item Extract the installation files to the selected directory.
@end itemize

@subsection Project Directory
To set up a project directory we use @ref{genprojdir.sh}. This script will create the directory layout for us. Assuming our project directory is called @file{setup/}, call the script like this:
@codeblock{genprojdir.sh -n "My Software 1.0" setup/}
This creates the project directory, including dutch translations (default) and basic Lua script files. The generated Lua scripts already tell by default that the @code{SelectDirScreen} (@pxref{instscreens, this}) should be used and that the installation files need to be extracted to the destination directory. The only thing we have to do is create an introduction message and copy the files that should be installed.

@subsection Introduction Message
Create a text file called @file{welcome} and put a text of choice in it, for example:
@quotation
This will install random software, press next to continue.
@end quotation
The file is placed in the @file{setup/} directory.

@subsection Installation Files
For this installer we simply provide one text file called @file{README}. Create the @file{README} file (put some random text in it if you want) and save it to the @file{setup/files_all/} directory.

@subsection Creating the installer
If all went fine the directory structure should look like this:
@itemize @bullet
    @item @file{setup/}
    @itemize @bullet
        @item @file{lang/}
        @itemize @bullet
            @item @file{dutch/}
            @itemize @bullet
                @item @file{strings}
            @end itemize
            @item @file{english/}
            @itemize @bullet
                @item @file{strings}
            @end itemize
        @end itemize
        @itemize @bullet
            @item @file{files_all/}
            @itemize @bullet
                @item @file{README}
            @end itemize
        @end itemize
        @item @file{files_extra/}
        @item @file{welcome}
        @item @file{config.lua}
        @item @file{run.lua}
    @end itemize
@end itemize

Now call @file{geninstall.sh} and supply the project directory as first argument (@pxref{Creating the Installer}). This should supply you with an installer called @file{setup.sh}.

@anchor{second tutorial}
@section Second Tutorial: A More Advanced Installer: Cube
In this tutorial we'll be making a slightly more advanced installer for the game @uref{http://www.cubeengine.com/, Cube}. The installer has the following tasks:
@itemize @bullet
@item Run on Linux and FreeBSD systems.
@item Let the user select a language.
@item Show a short introduction message describing Cube.
@item Let the user select a destination directory.
@item Let the user choose to install a script to his or her home directory that will launch Cube.
@item Install the files and optionally create the launcher script.
@end itemize

@subsection Project Directory
Again we use @file{genprojdir.sh} to create an initial project directory. This time we will call it @samp{cube}. Here is the command: 
@codeblock{genprojdir.sh -o freebsd linux -n Cube cube/}
We've limited the supporting operating systems to Linux and FreeBSD, simply because there are only Cube binaries for these 2 systems.@*
@*
Next create the @file{welcome} file with the following contents:
@codeblock{This installer will install Cube to your computer.
Cube is an open source FPS (First Person Shooter) which supports both single play and networked games.
Another main feature is the easy ingame map editing (online too!).}

@subsection @file{run.lua}
This time we want to edit the @file{run.lua} file. A generated version was already created. Modifying this file to our needs, it will look like this:
@codeblock{function Init()
    screen = install.newscreen("Installation options")
    scriptbox = screen:addradiobutton("Install launcher script to your home directory that launches Cube?",
                                      @{ "Yes", "No" @})
@*
    install.screenlist = @{ WelcomeScreen, SelectDirScreen, screen, InstallScreen @}
end
@*
function Install()
    install.extractfiles()
@*
    if (scriptbox:get() == "Yes") then
        local filename = string.format("%s/cube.sh", os.getenv("HOME"))
        script = io.open(filename, "w")
@*
        if (not script) then
            install.print("Failed to create launcher script")
            return @minus{}@minus{} Exit from function
        end
@*
        script:write(string.format(
[[#!/bin/sh
cd %s/cube/
./cube_unix
]], install.destdir))
        script:close()
@*
        os.chmod(filename, 700)
    end
end}

The default comments in the file are omitted, you may keep them if you want. The generated version also sets the @code{install.destdir} variable. As this is set to a default value, we don't really need it and is therefore kept out. @*
@*
First we define an @code{Init()} function. This is called when the installer starts. In this function a new installer screen is created via @ref{install.newscreen}. Then a radiobutton widget is added to this screen through the @ref{screen:addradiobutton} function. At last we define the install screens that should be used by putting them in the @code{install.screenlist} variable. Since we don't want a license or finish message shown we left these screens out.@*
@*
The second function, @code{Install()}, is called when the Installation Screen is activated. When @ref{install.extractfiles} is executed all the installation files are extracted to the directory assigned to the @code{install.destdir} variable. After that we check what the user chose from the radiobutton from our install screen. If it's @samp{"Yes"} then the script will be made. First we create the filename and assigning it to the local variable @code{filename}. Then the file is opened (and created if it doesn't exist yet). If there were no errors the script is written to file and the file is closed. Note that the @code{[[]]} block threats the part between it as a string and that newlines are automatically included to this string (@pxref{Strings}). The @ref{os.chmod} function alters the permissions of the script file so that it can be executed.

@subsection Creating the Installer
Assuming that the project directory is called @file{cube/} the layout of this directory should look like this:

@itemize @bullet
    @item @file{cube/}
    @itemize @bullet
        @item @file{lang/}
        @itemize @bullet
            @item @file{dutch/}
            @itemize @bullet
                @item @file{strings}
            @end itemize
            @item @file{english/}
            @itemize @bullet
                @item @file{strings}
            @end itemize
        @end itemize
        @item @file{files_all/}
        @itemize @bullet
            @item @file{cube/}
            @itemize @bullet
                @item @emph{Cube files}
            @end itemize
        @end itemize
        @item @file{files_extra/}
        @item @file{welcome}
        @item @file{config.lua}
        @item @file{run.lua}
    @end itemize
@end itemize

The @file{cube/} subdirectory from the @file{files_all/} directory comes from the @file{cube_2005_08_29_unix.tar.gz} file. This file can be obtained through the @uref{http://www.cubeengine.com,Cube website}.@*
@*
Now call @file{geninstall.sh}, supply it with 2 arguments: the first should be the path to your project directory, the second @file{cube.sh}. After some waiting (the default lzma compression takes some time) you should now have an installer called @file{cube.sh}.

@anchor{third tutorial}
@section Third Tutorial: Installer for Vim
In this tutorial we make a fairly advanced installer for the advanced text editor @uref{http://www.vim.org, Vim}. The installer should have the following features:
@itemize @bullet
    @item Run on every OS that Nixstaller supports (linux, freebsd, netbsd, openbsd and sunos).
    @item Let the user select a language.
    @item Show a welcome screen with the Vim logo and a short message.
    @item Let the user configure several compilation settings:
    @itemize @bullet
        @item The prefix path that is used as a base to install the files to (defaults to @file{/usr}).
        @item Which script languages to support for Vim commands.
        @item Which toolkits should be checked to use for @samp{gvim} (graphical vim).
        @item Integration support for Sun Studio, NetBeans and Sniff.
        @item Edit several environment variables that affect compilation.
    @end itemize
    @item Extract the files to a temporary directory and configure, compile and install Vim.
    @item Show the README after installation.
@end itemize

@subsection Project Directory
Again we start with creating the project directory:
@codeblock{genprojdir.sh -i <pathtovimlogo>/vim48x48.png -o freebsd linux netbsd openbsd sunos -n "VIM 7.1" vim/}
The @samp{<pathtovimlogo>} part should be replaced to the path were the vim logo is located. The file can be found in the directory @file{vim70/runtime/} from the Vim 7 distribution.@*
@*
Next copy this text to the @file{welcome} file:
@codeblock{This installer will guide you through the installation of Vim.
After you have read the following text press the Next button to start the installation.
@*
What Is Vim?
@*
Vim is a highly configurable text editor built to enable efficient text editing. It is an improved version
of the vi editor distributed with most UNIX systems.
Vim is often called a "programmer's editor," and so useful for programming that many consider
it an entire IDE. It's not just for programmers, though. Vim is perfect for all kinds of text editing,
from composing email to editing configuration files.
@*
(From www.vim.org)}
@*
To show the README after installation we include the @samp{FinishScreen}. This screen will display the contents of a file called @file{finish} which should be placed in the project directory. Just copy the @file{README} file from the vim package to the project directory and rename it to @samp{finish}.


@subsection @file{run.lua}
Now we start with the advanced things. The file will be quite big compared to the previous tutorials. The biggest part comes from parsing the configuration options and translating them to install commands. The file will contain several functions, these are discussed one at a time.

@subsubsection Function @code{Init()}
The file starts with;
@codeblock{function Init()
    install.destdir = install.gettempdir()
@*
    screen = install.newscreen("Configuration options for Vim installation")
@*
    prefixfield = screen:adddirselector("Base destination directory for Vim. This directory will be " ..
                                           "used to populate subdirectories such as bin/ to store executables " ..
                                           "and etc/ for configuration files.", "/usr")
@*
    scriptbox = screen:addcheckbox("Vim can use several scripting languages for command interpreting. "..
                                      "Please note that the selected languages need to be installed in " ..
                                      "order to work.", @{ "MzScheme", "perl", "python", "ruby", "tcl" @})
@*
    guibox = screen:addcheckbox("Vim can use several different GUI frontends. You can specify here which " ..
                                   "toolkits can be used to find a suitable GUI. If the toolkit cannot be used " ..
                                   "it will be skipped and the next is checked.", @{ "GTK", "GTK2", "Gnome", "Motif", "Athena (XAW)", "nexTaw" @})
    guibox:set(1, 2, 3, 4, 5, 6, true)
@*
    idebox = screen:addcheckbox("Vim can be integrated in several Integrated Development Environments (IDEs). " ..
                                   "Here you can select for which you want to include support.",
                                   @{ "Sun Visual Workshop", "NetBeans", "Sniff Interface" @})
    idebox:set(2, true)
@*
    advmenu = screen:addcfgmenu("Advanced compiler options. If you don't know what these do just leave them blank.")
    advmenu:addstring("CC", "Used C compiler")
    advmenu:addstring("CFLAGS", "Custom compiler flags (eg. -O2)")
    advmenu:addstring("CPPFLAGS", "Custom preprocessor flags (eg. -I/usr/local/include)")
    advmenu:addstring("LDFLAGS", "Custom linker flags (eg. -L/usr/local/lib)")
@*
    install.screenlist = @{ WelcomeScreen, screen, InstallScreen, FinishScreen @}
end}
Thats already some text to read :-) We start with setting the @code{install.destdir} variable to a temporary directory.@*
@*
After that a new installation screen is created and assigned to the @code{screen} variable. Then the widgets are created through the @ref{screen:addcheckbox} and @ref{screen:addcfgmenu} functions. Note that the descriptions are splitted with the @code{..} operator. This operator concatenates 2 strings and we use it purely here to make the code lines shorter. The last widget acts like a configuration menu. In this menu the user can select several parameters and edit them.@*
@*
The last line defines the install screens we want to show.

@subsubsection Function @code{getprefixconf()}
We create a new function that will return a string that is used as an argument to the @code{configure} command, which is used in the @code{Install()} function. The argument is used to set the prefix directory. Here is the function:
@codeblock{function getprefixconf()
    return string.format("@minus{}@minus{}prefix=%s", prefixfield:get())
end}

@subsubsection Function @code{getscriptconf()}
As the previous function; returns a string that is used by the @code{configure} command. This function will return the arguments related to the configuration of embedded scripting languages:
@codeblock{function getscriptconf()
    local ret = "" @minus{}@minus{} Need to initialize variable as a string, otherwise concatting it won't work
@*
    if (scriptbox:get("MzScheme")) then
        ret = ret .. "@minus{}@minus{}enable-MzScheme "
    end
    if (scriptbox:get("perl")) then
        ret = ret .. "@minus{}@minus{}enable-perl "
    end
    if (scriptbox:get("python")) then
        ret = ret .. "@minus{}@minus{}enable-python "
    end
    if (scriptbox:get("ruby")) then
        ret = ret .. "@minus{}@minus{}enable-ruby "
    end
    if (scriptbox:get("tcl")) then
        ret = ret .. "@minus{}@minus{}enable-tcl "
    end
@*
    return ret
end}
The first line is important: Lua needs to know that a variable is used as a string, otherwise the concat operator(@code{..}) won't work. Simply assigning an empty string will do the job. Another important thing to notice is the trailing space from the concatenated strings: this makes it easier to construct one string from various function calls (which is done later).@*
@*
As an example, if the user enabled @samp{perl} and @samp{ruby} then the function would return this string: "@minus{}@minus{}enable-perl @minus{}@minus{}enable ruby ".

@subsubsection Function @code{getguiconf()}
This function is very similar to the previous function, but returns a string to be used for toolkit configuration that is used for @samp{gvim} (graphical vim). Here is the code:
@codeblock{function getguiconf()
    local ret = ""
@*
    if (not guibox:get("GTK")) then
        ret = ret .. "@minus{}@minus{}disable-gtk-check "
    end
    if (not guibox:get("GTK2")) then
        ret = ret .. "@minus{}@minus{}disable-gtk2-check "
    end
    if (not guibox:get("Gnome")) then
        ret = ret .. "@minus{}@minus{}disable-gnome-check "
    end
    if (not guibox:get("Athena (XAW)")) then
        ret = ret .. "@minus{}@minus{}disable-athena-check "
    end
    if (not guibox:get("nexTaw")) then
        ret = ret .. "@minus{}@minus{}disable-nextaw-check "
    end
@*
    return ret
end}
Note that we check if an option is disabled instead of enabled. This is because these options are enabled by default.

@subsubsection Function @code{getideconf()}
This function, similar to the previous 2, is used to get a string to be used for IDE integration:
@codeblock{function getideconf()
    local ret = ""
@*
    if (idebox:get("Sun Visual Workshop")) then
        ret = ret .. "@minus{}@minus{}enable-workshop "
    end
    if (not idebox:get("NetBeans")) then
        ret = ret .. "@minus{}@minus{}disable-netbeans "
    end
    if (idebox:get("Sniff Interface")) then
        ret = ret .. "@minus{}@minus{}enable-sniff "
    end
@*
    return ret
end}

@subsubsection Function @code{getconfigureopts()}
This function returns the string that should be given as a shell argument to the @code{configure} command. The function uses the previous three functions, separated by a space, to form the right string. This is the function:
@codeblock{function getconfigureopts()
    return getprefixconf() .. " " .. getscriptconf() .. " " .. getguiconf() .. " " .. getideconf()
end}

@subsubsection Function @code{handleadvmenu()}
This function will set several shell environment variables that can be configured through the @samp{Advanced compilation options} menu. Before a variable is set, it will be checked if the user didn't leave it blank. This is done because if the environment variable was already set (eg. because the user set it in the shell from where the installer was executed) it would be cleared otherwise. Here is the function code:
@codeblock{function handleadvmenu()
    if (#advmenu:get("CC") > 0) then
        os.setenv("CC", advmenu:get("CC"))
    end
    if (#advmenu:get("CFLAGS") > 0) then
        os.setenv("CFLAGS", advmenu:get("CFLAGS"))
    end
    if (#advmenu:get("CPPFLAGS") > 0) then
        os.setenv("CPPFLAGS", advmenu:get("CPPFLAGS"))
    end
    if (#advmenu:get("LDFLAGS") > 0) then
        os.setenv("LDFLAGS", advmenu:get("LDFLAGS"))
    end
end}
The length operator, @samp{#}, is used to get the string length from each variable. If it's more than zero than the string isn't blank and it is used to set the environment variable.

@subsubsection Function @code{Install()}
The last function will do the actual installation. Here is how it looks like:
@codeblock{function Install()
    local prefix = prefixfield:get()
    handleadvmenu()
@*
    @minus{}@minus{} 1: Extracting Files (Automatically set by install.extractfiles)
    @minus{}@minus{} 2: ./configure
    @minus{}@minus{} 3: make
    @minus{}@minus{} 4: make install
    install.setstepcount(4)
@*
    if (os.writeperm(prefix) == false) then
        install.askrootpw()
    end
@*
    install.extractfiles()
    os.chdir("vim70/")
@*
    install.setstatus("Configuring Vim for this system")
    install.execute(string.format("./configure %s", getconfigureopts()))
@*
    install.setstatus("Compiling Vim")
    install.execute("make")
@*
    install.setstatus("Installing files")
    if (os.writeperm(prefix) == false) then
        install.executeasroot("make install")
    else
        install.execute("make install")
    end
end}

At first the prefix directory is stored to the local @code{prefix} variable.@*
@*
After that the options from the @samp{Advanced compilation options} menu are processed.@*
@*
Then the stepcount is set. Each step is documented by the comments shown above the @ref{install.setstepcount} function.@*
@*
Then we check if we got write access to the prefix directory. If not we need root access later and we ask the password here.@*
@*
After the files are extracted through the @ref{install.extractfiles} function we change directory to the @file{vim70/} directory. The status message is changed so that the user knows whats going on and the @code{configure} command is executed with the right arguments.@*
@*
After configuration, @code{make} is called to start the compilation and the status message is changed again.@*
@*
After @code{make} is done the install process is started. If the prefix directory is write protected for the current user we call @code{make install} as root, otherwise it's executed as the current user.

@subsubsection Everything Put Together
The @file{run.lua} file is now completely discussed and should look like this:
@codeblock{function Init()
    install.destdir = install.gettempdir()
@*
    screen = install.newscreen("Configuration options for Vim installation")
@*
    prefixfield = screen:adddirselector("Base destination directory for Vim. This directory will be " ..
                                           "used to populate subdirectories such as bin/ to store executables " ..
                                           "and etc/ for configuration files.", "/usr")
@*
    scriptbox = screen:addcheckbox("Vim can use several scripting languages for command interpreting. "..
                                      "Please note that the selected languages need to be installed in " ..
                                      "order to work.", @{ "MzScheme", "perl", "python", "ruby", "tcl" @})
@*
    guibox = screen:addcheckbox("Vim can use several different GUI frontends. You can specify here which " ..
                                   "toolkits can be used to find a suitable GUI. If the toolkit cannot be used " ..
                                   "it will be skipped and the next is checked.", @{ "GTK", "GTK2", "Gnome", "Motif", "Athena (XAW)", "nexTaw" @})
    guibox:set(1, 2, 3, 4, 5, 6, true)
@*
    idebox = screen:addcheckbox("Vim can be integrated in several Integrated Development Environments (IDEs). " ..
                                   "Here you can select for which you want to include support.",
                                   @{ "Sun Visual Workshop", "NetBeans", "Sniff Interface" @})
    idebox:set(2, true)
@*
    advmenu = screen:addcfgmenu("Advanced compiler options. If you don't know what these do just leave them blank.")
    advmenu:addstring("CC", "Used C compiler")
    advmenu:addstring("CFLAGS", "Custom compiler flags (eg. -O2)")
    advmenu:addstring("CPPFLAGS", "Custom preprocessor flags (eg. -I/usr/local/include)")
    advmenu:addstring("LDFLAGS", "Custom linker flags (eg. -L/usr/local/lib)")
@*
    install.screenlist = @{ WelcomeScreen, screen, InstallScreen, FinishScreen @}
end
@*
function getprefixconf()
    return string.format("@minus{}@minus{}prefix=%s", prefixfield:get())
end
@*
function getscriptconf()
    local ret = "" @minus{}@minus{} Need to initialize variable as a string, otherwise concatting it won't work
@*
    if (scriptbox:get("MzScheme")) then
        ret = ret .. "@minus{}@minus{}enable-MzScheme "
    end
    if (scriptbox:get("perl")) then
        ret = ret .. "@minus{}@minus{}enable-perl "
    end
    if (scriptbox:get("python")) then
        ret = ret .. "@minus{}@minus{}enable-python "
    end
    if (scriptbox:get("ruby")) then
        ret = ret .. "@minus{}@minus{}enable-ruby "
    end
    if (scriptbox:get("tcl")) then
        ret = ret .. "@minus{}@minus{}enable-tcl "
    end
@*
    return ret
end
@*
function getguiconf()
    local ret = ""
@*
    if (not guibox:get("GTK")) then
        ret = ret .. "@minus{}@minus{}disable-gtk-check "
    end
    if (not guibox:get("GTK2")) then
        ret = ret .. "@minus{}@minus{}disable-gtk2-check "
    end
    if (not guibox:get("Gnome")) then
        ret = ret .. "@minus{}@minus{}disable-gnome-check "
    end
    if (not guibox:get("Athena (XAW)")) then
        ret = ret .. "@minus{}@minus{}disable-athena-check "
    end
    if (not guibox:get("nexTaw")) then
        ret = ret .. "@minus{}@minus{}disable-nextaw-check "
    end
@*
    return ret
end
@*
function getideconf()
    local ret = ""
@*
    if (idebox:get("Sun Visual Workshop")) then
        ret = ret .. "@minus{}@minus{}enable-workshop "
    end
    if (not idebox:get("NetBeans")) then
        ret = ret .. "@minus{}@minus{}disable-netbeans "
    end
    if (idebox:get("Sniff Interface")) then
        ret = ret .. "@minus{}@minus{}enable-sniff "
    end
@*
    return ret
end
@*
function getconfigureopts()
    return getprefixconf() .. " " .. getscriptconf() .. " " .. getguiconf() .. " " .. getideconf()
end
@*
function handleadvmenu()
    if (#advmenu:get("CC") > 0) then
        os.setenv("CC", advmenu:get("CC"))
    end
    if (#advmenu:get("CFLAGS") > 0) then
        os.setenv("CFLAGS", advmenu:get("CFLAGS"))
    end
    if (#advmenu:get("CPPFLAGS") > 0) then
        os.setenv("CPPFLAGS", advmenu:get("CPPFLAGS"))
    end
    if (#advmenu:get("LDFLAGS") > 0) then
        os.setenv("LDFLAGS", advmenu:get("LDFLAGS"))
    end
end
@*
function Install()
    local prefix = prefixfield:get()
    handleadvmenu()
@*
    @minus{}@minus{} 1: Extracting Files (Automatically set by install.extractfiles)
    @minus{}@minus{} 2: ./configure
    @minus{}@minus{} 3: make
    @minus{}@minus{} 4: make install
    install.setstepcount(4)
@*
    if (os.writeperm(prefix) == false) then
        install.askrootpw()
    end
@*
    install.extractfiles()
    os.chdir("vim70/")
@*
    install.setstatus("Configuring Vim for this system")
    install.execute(string.format("./configure %s", getconfigureopts()))
@*
    install.setstatus("Compiling Vim")
    install.execute("make")
@*
    install.setstatus("Installing files")
    if (os.writeperm(prefix) == false) then
        install.executeasroot("make install")
    else
        install.execute("make install")
    end
end}

@subsection Creating the Installer
The project directory should have the following structure:

@itemize @bullet
    @item @file{vim/}
    @itemize @bullet
        @item @file{lang/}
        @itemize @bullet
            @item @file{dutch/}
            @itemize @bullet
                @item @file{strings}
            @end itemize
            @item @file{english/}
            @itemize @bullet
                @item @file{strings}
            @end itemize
        @end itemize
        @item @file{files_all/}
        @itemize @bullet
            @item @file{vim70/}
            @itemize @bullet
                @item @emph{Vim files}
            @end itemize
        @end itemize
        @item @file{files_extra/}
        @itemize @bullet
            @item @file{vim48x48.png}
        @end itemize
        @item @file{welcome}
        @item @file{finish}
        @item @file{config.lua}
        @item @file{run.lua}
    @end itemize
@end itemize

Calling @file{geninstall.sh} with the path to project directory as first argument and @samp{vim71.sh} as second argument should produce the installer.

@anchor{fourth tutorial}
@section Fourth Tutorial: Installer for BZFlag
This tutorial introduces @ref{pkgmode,,Package Mode}, desktop menu generation and including dependencies. The installer will support the following things:
@itemize @bullet
@item Run on your current OS and CPU architecture (it's a binary installer and we will only focus on building on your current system).
@item Let the user select a language.
@item Show a welcome screen with BZFlag graphics and short (intro) message.
@item Let the user configure whether to enable package registration and setting the destination paths for the binary and data directories.
@item Install BZFlag to the user's system, including a few (less common) dependencies, via the @samp{Package Mode way}.
@item Create a desktop menu entry for BZFlag.
@end itemize

@subsection Project Directory
Again the @file{genprojdir.sh} script is used to generate a project directory:
@codeblock{genprojdir.sh -i <pathtobzflaglogo>/side.bmp -n "BZFlag" @minus{}@minus{}pkg bzflag/}
The @samp{<pathtobzflaglogo>} part should be replaced by the path where @file{side.bmp} can be found, in the BZFlag archive it is located inside the @file{bzflag-2.0.10/package/win32/nsis/} directory. Notice that this time the @samp{@minus{}@minus{}pkg} argument is also passed, this will set up a template @file{package.lua} file and adds some handy Package Mode code to @file{run.lua}.@*
@*
Next we create a @file{welcome} file with the following content:
@codeblock{BZFlag is a free online multiplayer cross-platform open source 3D tank
battle game. The name originates from "Battle Zone capture the Flag". It runs on
Irix, Linux, *BSD, Windows, Mac OS X, and many other platforms. It's one of the most
popular games ever on Silicon Graphics machines and continues to be developed and
improved to this day. It's one of the most popular open source games ever.
@*
(from bzflag.org)}

@subsection Compilation of BZFlag and Dependencies
Before we continue with the configuration of the installer, we first have to compile BZFlag and a few dependencies.@*
@*
To do this it's best to @samp{install} any files to a separate directory structure, this is easily accomplished by setting the @samp{@minus{}@minus{}prefix} flag when @command{configure} is called. This @samp{prefix directory} is furtherly referred as @emph{PREFIX}.@*
@*
Using the data in the table below, BZFlag and it's dependencies can now be build.
@starttable{.33, .33, .33}
@addtableheaderrow{}
    @addtableheadercol{Where to get it}
    @addtableheadercol{How to compile}
    @addtableheadercol{Comments}
@endtablerow

@addtablerow{SDL}
    @addtablecol{@uref{http://www.libsdl.org}}
    @addtablecol{@command{./configure @minus{}@minus{}prefix=PREFIX && make && make install}}
    @addtablecol{Make sure that you have X dev packages installed}
@endtablerow

@addtablerow{libCURL}
    @addtablecol{@uref{http://curl.haxx.se}}
    @addtablecol{@command{./configure @minus{}@minus{}prefix=PREFIX && make && make install}}
    @addtablecol{}
@endtablerow

@addtablerow{BZFlag}
    @addtablecol{@uref{http://bzflag.org}}
    @addtablecol{@command{CPPFLAGS="-IPREFIX/include" LDFLAGS="-LPREFIX/lib" ./configure @minus{}@minus{}prefix=PREFIX @minus{}@minus{}with-sdl-prefix=PREFIX @minus{}@minus{}with-libcurl="PREFIX/lib" && make && make install}}
    @addtablecol{}
@endtablerow

@endtable

After everything is build, the PREFIX directory should now contain the files we need (and some more). It's now time to place those files in the @file{files_all/} directory inside the project directory. The directory structure should look like this:
@itemize @bullet
    @item @file{bin/}
    @itemize @bullet
        @item @file{bzadmin}
        @item @file{bzflag}
        @item @file{bzfs}
    @end itemize
    @item @file{lib/}
    @itemize @bullet
        @item @file{libcurl.so.X}
        @item @file{libSDL-1.2.so.X}
    @end itemize
    @item @file{bzflag/}
    @itemize @bullet
        @item @emph{BZFlag data files}
    @end itemize
@end itemize

The binaries and libraries can be found in @file{PREFIX/bin} and @file{PREFIX/lib} respectively. The binaries are pretty big, you probably want to @samp{strip} them by running @command{strip -s <bins>}. Note that the libraries inside @file{PREFIX/lib} are suffixed with @samp{.so.X.Y.Z} (the other libs are just symlinks to these). The binaries however, expect the libraries to be suffixed with @samp{.so.X}. For this reason you have to rename the libraries after you copied them. Finally the data files can be found inside @file{PREFIX/share/bzflag}.


@subsection @file{package.lua}
Now we need to edit the @file{package.lua} file. The contents (comments and some defaults are stripped) are shown below.
@codeblock{pkg.enable = true
pkg.name = "bzflag"
pkg.version = "2.0.10"
pkg.release = "1"
pkg.summary ="Use your tank to shoot others and capture flags in a 3D multiplayer world."
pkg.description = [[
BZFlag is a free online multiplayer cross-platform open source 3D tank
battle game. The name originates from "Battle Zone capture the Flag".
]]
pkg.group = "Games"
pkg.license = "GPLv2"
pkg.maintainer = "Rick Helmus <rhelmus_AT_gmail>" @minus{}@minus{} You probably want to change this :-)
pkg.url = "bzflag.org"
pkg.bins = @{ "bin/bzfs" , "bin/bzflag", "bin/bzadmin" @}}

@subsection @file{run.lua}
Now it's time to focus on the @file{run.lua} file. Compared to the previous tutorial it's fairly simple. The contents (again with any generated comments stripped out) are shown below.
@codeblock{function Init()
    install.destdir = install.getpkgdir() @minus{}@minus{} Files can be installed right away
    install.screenlist = @{ WelcomeScreen, PackageToggleScreen, PackageDirScreen, InstallScreen, SummaryScreen @}
end
@*
function Install()
    install.setstepcount(2)
@*
    if pkg.needroot() then
        install.askrootpw()
    end
@*
    @minus{}@minus{} We need to let bzflag know where to find the data,
    @minus{}@minus{} this is accomplished by using the '-directory' commandline option
    pkg.addbinopts("bin/bzflag", string.format("-directory %s/bzflag", pkg.getdatadir()))
@*
    install.menuentries["bzflag"] = install.newdesktopentry(pkg.getbindir("bin/bzflag"), pkg.getdatadir("bzflag/blue_icon.png"), "Game;ActionGame")
@*
    install.extractfiles()
    install.gendesktopentries(pkg.needroot()) @minus{}@minus{} Assume global install if root access is necessary.
    install.generatepkg()
end}

@subsection Finishing Up
The project directory layout should now look like this:
@itemize @bullet
    @item @file{bzflag/}
    @itemize @bullet
        @item @file{lang/}
        @itemize @bullet
            @item @file{dutch/}
            @itemize @bullet
                @item @file{strings}
            @end itemize
            @item @file{english/}
            @itemize @bullet
                @item @file{strings}
            @end itemize
        @end itemize
        @item @file{files_all/}
        @itemize @bullet
            @item @emph{BZFlag files}
        @end itemize
        @item @file{files_extra/}
        @itemize @bullet
            @item @file{side.bmp}
        @end itemize
        @item @file{welcome}
        @item @file{config.lua}
        @item @file{package.lua}
        @item @file{run.lua}
    @end itemize
@end itemize

The installer can now be generated using @file{geninstall.sh}.

@node Compilation
@chapter Compilation

@section Introduction
This chapter is important for people who want to compile the frontends used by Nixstaller. Some reasons may be if you changed the source code or you're porting to a new platform for example. There are some things to watch out for, therefore if you really need to compile then read this chapter as a whole.

@section Libraries

@subsection Dynamic vs Static
Dynamic libraries are good because they reduce size from the executable and when they are updated it affects the executable aswell. Drawbacks are mainly conflicting version numbers. If the major library version changes the executable cannot use it anymore.@*
@*
For this reason most libraries are linked staticly. This will add size to the resulting binaries, but they can run on many different systems. There are however a few libraries linked dynamicly, because they cannot or it's unreasonable to link them staticly. The C library (@samp{libc}) and the C++ libraries are examples of dynamicly linked libraries.

@subsection Required Libraries
@starttable{.25, .25, .25, .25}
@addtableheaderrow{Library}
    @addtableheadercol{Where to get it}
    @addtableheadercol{Used by}
    @addtableheadercol{Dynamic or Static}
@endtablerow

@addtablerow{GTK2 (libgobject-2.0 libglib-2.0 libpango-1.0 libgdk-x11-2.0 libgdk_pixbuf-2.0 libgtk-x11-2.0)}
    @addtablecol{@uref{http://www.gtk.org/}}
    @addtablecol{GTK2 frontend}
    @addtablecol{Dynamic}
@endtablerow

@addtablerow{zlib (libz)}
    @addtablecol{@uref{http://www.zlib.net/}}
    @addtablecol{FLTK frontend}
    @addtablecol{Static}
@endtablerow

@addtablerow{png (libpng)}
    @addtablecol{@uref{http://www.libpng.org/pub/png/libpng.html}}
    @addtablecol{FLTK frontend}
    @addtablecol{Static}
@endtablerow

@addtablerow{jpeg (libjpeg)}
    @addtablecol{@uref{http://www.ijg.org/}}
    @addtablecol{FLTK frontend}
    @addtablecol{Static}
@endtablerow

@addtablerow{FLTK (libfltk, libfltk_images)}
    @addtablecol{@uref{http://www.fltk.org/}}
    @addtablecol{FLTK frontend}
    @addtablecol{Static}
@endtablerow

@addtablerow{X11 (libX11, libXext, libXft)}
    @addtablecol{Locally or @uref{http://www.x.org/}}
    @addtablecol{FLTK frontend}
    @addtablecol{Dynamic}
@endtablerow

@addtablerow{ncurses (libncurses, libncurses++)}
    @addtablecol{@uref{http://www.gnu.org/software/ncurses/ncurses.html}}
    @addtablecol{ncurses frontend}
    @addtablecol{Static}
@endtablerow

@addtablerow{Lua (liblua)}
    @addtablecol{@uref{http://www.lua.org/}}
    @addtablecol{Core}
    @addtablecol{Static}
@endtablerow

@addtablerow{GCC libs (libc, libstdc++, libm, libgcc, libutil)}
    @addtablecol{@uref{http://gcc.gnu.org/}}
    @addtablecol{Core}
    @addtablecol{libutil static, the rest dynamic}
@endtablerow

@endtable

All the static libraries with the exception from @file{libutil.a} needs to be copied to the @file{src/lib/[osname]/[archname]} directory. The @samp{[osname]} refers to the lower cased output from the command @command{uname}. @samp{archname} refers to either @samp{x86}, @samp{x86_64} or the output from @command{uname -m}. The main reason for putting the static libraries in a separate directory is that 'clean' versions can be compiled and used. 'clean' in the way that the libraries have no CPU specific optimizations.@*
@*
The search path to X11 libraries defaults to @file{/usr/X11R6/lib}. This can be changed by the @samp{xlibsdir} parameter passed to SCons, which is discussed later.@*
@*
The search path to GTK2 libraries defaults to @file{/usr/lib}. This can be changed by the @samp{gtklibsdir} parameter passed to SCons, which is also discussed later.@*

@subsection Headers
All the header files from the static libraries can be found in the @file{src/include/} directory. You normally don't have to bother with these. The path to the X11 headers can be specified with the @samp{xincdir} parameter passed to SCons (discussed later). The included GTK2 headers are from the older 2.4 version. This ensures that the frontend runs on systems with GTK+ 2.4 or later.

@subsection Notes
In the @file{src/libs/[osname]/[archname]/} directories you can find a @file{notes} file that contain several notes about which library versions are used and how they were compiled. It's recommended that the same library versions are used in case you want to compile your own.

@anchor{builddeps.sh}
@subsection @file{builddeps.sh}
This script is located inside the @code{src/} directory and is used to easily retrieve and compile most dependencies. Usually it's called inside the @file{src/} directory itself. The script needs either @command{wget} or @command{fetch} to retrieve the dependencies and @command{nano} is used to let you edit lua's Makefile (to use g++ and -Os, see the @file{notes} files). The files are stored inside @file{src/deps/files}, the dependencies are installed (after compilation) to @file{src/deps/usr}.@*
@*
The script can build one or more targets, by specifying them at the command line. These targets are:
@itemize @bullet
@item zlib
@item png
@item jpeg
@item fltk
@item lua
@item ncurses
@item lzma
@end itemize
If no targets are specified, all of them will be build.

@section Binaries
Besides libraries, Nixstaller also needs 2 binaries. These two are used for lzma encoding and decoding. They can easily be fetched and compiled by using @file{builddeps.sh} with the @samp{lzma} target (@pxref{builddeps.sh}).

@section SCons
@uref{http://www.scons.org/, SCons} is used as built system to compile Nixstaller. At least version @samp{0.96.91} is required. SCons depends on @uref{http://www.python.org, python} so make sure to install that aswell.@*
@*
To start the compilation simply execute @command{scons} from the @file{src/} directory.@*
@*
SCons has several options that will affect the compilation, to see these run @command{scons @minus{}@minus{}help} in the @file{src/} directory.@*
@*
There are also a few build targets:
@table @strong
@item stripbins
Strips all symbols from the binaries.
@item tardist
Creates a tar.gz file containing the full Nixstaller distribution. Note that new files need to be added to the @code{distfiles_user} variable at the beginning of the @file{SConstruct} file.
@item setupdist
Creates an installer for Nixstaller.
@end table

After compilation is done the binaries will be put in the @file{bin/} directory. The directory structure looks like this:
@itemize @bullet
    @item @emph{osname/}
    @itemize @bullet
        @item @emph{archname/}
        @itemize @bullet
            @item @emph{libc.so.X/}
            @itemize @bullet
                @item @emph{libstdc++.so.X/}
                @itemize @bullet
                    @item @file{lzma}
                    @item @file{fltk}
                    @item @file{gtk}
                    @item @file{ncurs}
                @end itemize
                @item @file{edelta}
                @item @file{lzma-decode}
            @end itemize
        @end itemize
    @end itemize
@end itemize

The binaries are each put on separate @samp{libc} and, in case of C++ binaries, in separate @samp{libstdc++} directories aswell. The reason for this is that they are linked dynamicly. To make sure that an installer works on many systems, different binaries with different linked library versions need to be included. For this reason it's important to compile on different versions of an Operating System. For example FreeBSD 5.X uses @file{libc.so.5} and @file{libstdc++.so.4} while FreeBSD 6.X is using @file{libc.so.6} and @file{libstdc++.so.5}. In order to let an installer run on both FreeBSD 5 and 6 the binaries are compiled on both systems and put in their own subdirectory inside @file{bin/}. When the installer is started (and obviously created when the binaries were in place) it will then choose the right binaries for the users system.@*
@*
Besides the frontends there are some other binaries. Here is an explanation for each of them:
@table @file
@item lzma
Binary used to @emph{encode} the install files using the lzma algorithm. This file is not included in the installer.
@item fltk
The FLTK frontend.
@item gtk
The GTK frontend.
@item ncurs
The ncurses frontend.
@item edelta
This binary is used to create @samp{deltas} or @samp{binary diffs} from frontend binaries. The @samp{diffs} are made from binaries for the same OS and CPU architecture but from different @file{libc} and/or @samp{libstdc++} versions. Note that this version differs from the @uref{http://www.diku.dk/~jacobg/edelta/, original version} because it's modified in such way that it doesn't use compression (which makes the binary smaller and allows us to use other compression methods than gzip).
@item lzma-decode
@emph{Decodes} lzma encoded files. This is a much smaller version of the normal @file{lzma} binary and is included in the installer.
@end table




@node Miscellaneous
@chapter Miscellaneous

@section Credits
@itemize @bullet
@item @uref{http://www.kdevelop.org/, KDevelop}: Great IDE which I use for programming.
@item @uref{http://www.scons.org, SCons}: Great alternative to GNU's autotools.
@item @uref{http://www.kde.org, KDESU}: Much of the code using @samp{su} is based on this KDE project.
@item @uref{http://www.megastep.org/makeself/, makeself}: Engine for the self-extracting installer.
@item @uref{http://quanta.kdewebdev.org/, Quanta+}: Good HTML editor used for the website.
@item @uref{http://www.texinfo.org, texinfo} and texi2html: Used to create this documentation.
@item @uref{http://www.berlios.de, BerliOS}: Project hosting.
@item @uref{http://www.diku.dk/~jacobg/edelta/, edelta}: Used to create @samp{binary diffs} to decrease the size of frontend binaries.
@item @uref{http://www.7-zip.org/sdk.html, lzma}: Very good compression algorithm.
@item @strong{InternetNightmare}: Suggestions, testing, feedback.
@item @strong{offer}: Suggestions, bug reporting, feedback.
@item @strong{Tomasz Sałaciński}: Suggestions, bug reporting, feedback.
@end itemize


@section Feedback
For suggestions, questions, bugs etc you can reach me through the following ways:
@itemize @bullet
@item E-Mail: rhelmus_AT_gmail.com
@item Use the @uref{http://nixstaller.berlios.de/forum/index.php, online forums}
@item Instant Message: rick_helmus8_AT_hotmail.com (MSN), 224332897 (ICQ) or rhelmus_AT_gmail.com (Google Talk).
@item For bugs: the @uref{http://developer.berlios.de/projects/nixstaller/, BerliOS project page}.
@end itemize




@node Lua Basics
@appendix Lua Basics

@section Introduction
Lua (@url{http://www.lua.org}) is used for configuring properties of the @emph{Install Package} and to control the installation process. Lua is a simple and easy to learn scripting language. In this appendix a brief guide is given about Lua. Another good resource is the @uref{http://www.lua.org/pil,Lua Book}. Note that the online version describes version @emph{5.0} while Nixstaller uses @emph{5.1}. Though not much has been changed, especially not the basics.


@section Lua Basics
@subsection Comments
Lua files can contain @emph{comments}. Comments are for example used to describe pieces of code or to quickly 'disable' some code.

Some examples:
@codeblock{@minus{}@minus{} This is a comment line, comment lines always start with @samp{@minus{}@minus{}}
a = b + 5     @minus{}@minus{} Comment can be after a code line aswell
@minus{}@minus{} b = b + 1   @minus{}@minus{} A 'disabled' line}

There can also be @emph{comment blocks}:
@codeblock{@minus{}@minus{}[
Text between the two square brackets is comment.
This is useful if you want to write a few lines or disable multiple code lines.
@minus{}@minus{}]}

@subsection Variables
To store data @emph{variables} are used. A variable name is a combination of letters, underscores and/or numbers. Note that the variable name cannot start with a number.
To create a variable you simply assign data to it. To remove a variable you assign @code{nil} to it.

@subsubsection Types
Variables are not bound to a single type(typeless, languages as C are typed). There are various types in the Lua environment:
@table @strong
@anchor{Numbers}
@item Numbers
Numbers can be both a decimal type or a integral type. Examples:
@codeblock{a = 15
b = 1.5}
@anchor{Strings}
@item Strings
Strings are used to store an array of characters. The text used for a string should be either enclosed by single quotes ('') or double quotes (""). Example:
@codeblock{text1 = "Hello"}
If you want to assign lots of text you can also use the @samp{[[} and @samp{]]} operators. These will add all the text between them, including newlines. Example:
@codeblock{longtext = [[Hello
this
is
a string
with newlines]]}
If you want to @samp{nest} these text blocks, add a equal sign between the two square brackets (so the first new level becomes @code{[=[ ... ]=]}).@*
@*
Special characters such as newlines and (double)quotes need to be 'escaped'. This means that you need to put a backslash (@samp{\}) and another character next to it, which will be replaced by another character. Here are some most used @samp{escape sequences}:
@table @samp
@item \n
Will be replaced by a newline.
@item \t
Will be replaced by a horizontal tab.
@item \v
Will be replaced by a vertical tab.
@item \\
Will be replaced by a backslash.
@item \'
Will be replaced by a single quote.
@item \"
Will be replaced by a double quote.
@end table
Note that escape sequences are ignored with the @code{[[} and @code{]]} operators.

@item Boolean
A Boolean is either @code{true} or @code{false}. They are used to enable/disable flags and test them in conditional lines. Example:
@codeblock{a = true
b = false}
@item Tables
Tables are a generic type and can be used in many different ways. @xref{Tables} for a detailed explanation.
@item Functions
Functions can also be stored in variables. @xref{Functions} for more info.
@item @samp{@strong{nil}}
As said before, @code{nil} is used to delete a variable. @code{nil} is also sometimes used to indicate @samp{Nothing}. Example:
@codeblock{a = nil    @minus{}@minus{} a will now be collected by Lua's garbage collector}
@end table

@subsubsection Operators
Operators are used to operate on variables. For example to multiply 2 numbers or to add (concat) 2 strings to each other. The following table lists every operator and its function. The items are shown in order of priority.
@starttable{.25,.25,.25,.25}
@addtableheaderrow{Operator}
    @addtableheadercol{Used on}
    @addtableheadercol{Effect}
@endtablerow

@addtablerow{@code{^}}
    @addtablecol{Numbers}
    @addtablecol{Calculates the power}
@endtablerow

@addtablerow{@code{not}, @code{-}, @code{#}}
    @addtablecol{Numbers}
    @addtablecol{@code{not} returns @code{true} when an expression is false (@pxref{Testing variables and values, this}).@*
The minus in this case is the operator used for negative values.@*
The @samp{#} is used to retrieve the number of entries in a @ref{Tables, table} or the length of a @ref{Strings, string}.}
@endtablerow

@addtablerow{@code{/}, @code{*}}
    @addtablecol{Numbers}
    @addtablecol{Arithmetic operations (@abbr{resp.} divide, multiply)}
@endtablerow

@addtablerow{@code{+}, @code{-}}
    @addtablecol{Numbers}
    @addtablecol{Arithmetic operations (@abbr{resp.} add, substract)}
@endtablerow

@addtablerow{..}
    @addtablecol{Strings}
    @addtablecol{Concats 2 strings}
@endtablerow

@addtablerow{@code{>}, @code{<}, @code{>=}, @code{<=}, @code{==}, @code{~=}}
    @addtablecol{Strings, Numbers, Tables}
    @addtablecol{Used to compare values @*
@xref{Testing variables and values}}
@endtablerow

@addtablerow{@code{and}}
    @addtablecol{Anything}
    @addtablecol{Checks if 2 expressions are @code{true} @*
@xref{Testing variables and values}}
@endtablerow

@addtablerow{@code{or}}
    @addtablecol{Anything}
    @addtablecol{Checks if 1 of 2 expressions is @code{true} @*
@xref{Testing variables and values}}
@endtablerow
@endtable

Parenthesis(@samp{()}) can be used to give an expression the highest priority.

Some examples:
@codeblock{a = 5 * 2       @minus{}@minus{} a = 10
b = 20 / 5      @minus{}@minus{} b = 4
c = (a + b) * 2 @minus{}@minus{} c = 28
d = 5^2         @minus{}@minus{} d = 25
txt1 = "Hello"
txt2 = "World"
txt = txt1 .. " ".. txt2    @minus{}@minus{} txt = "Hello World"}
Note that the @samp{..} operator can convert numbers to strings aswell:
@codeblock{n = 5
txt = "The number is: " .. n    @minus{}@minus{} txt = "The number is: 5"}

@anchor{Testing variables and values}
@subsection Testing variables and values

@subsubsection Operators for testing
In lua there are a few operators to test variables and values:
@table @strong
@item <
Less than
@item >
More than
@item ==
Equal to (@strong{a single @samp{=} does not compare, just assign})
@item ~=
Unequal to
@item <=
Less or equal to
@item >=
More or equal to
@item and
Tests if 2 expressions are @code{true}
@item or
Tests if one of 2 expressions is @code{true}
@item not
Tests if a expression is not @code{true}
@end table

All of these work on @code{numbers} and @code{strings}.The equal and not equal operators also work on @code{tables}.

When a test succeeds @code{true} will be returned, when it fails @code{false} will be returned. Except for @code{or} and @code{and}. @code{or} will return the first expression if its true, otherwise the second. @code{and} will return the first expression if its false, otherwise the second.

Here are some examples:
@codeblock{a = 55
b = 100
c = a > b    @minus{}@minus{} c = false
@*
text1 = "Apple"
text2 = "Orange"
c = text1 < text2   @minus{}@minus{} c = true (alphabetical comparison)
@*
c = 5 > 2 and "5" < "2"   @minus{}@minus{} false (second expression is false)}

@anchor{and or trick}
As mentioned, the @code{or} and @code{and} operators will return one of the expressions. With that knowledge a nice trick can be made:
@codeblock{a = 5
b = 2
c = 6
d = 12
n = (a > b) and c or d   @minus{}@minus{} n = d(12)}
This might look a bit odd. If you're a C (or C++) programmer you may recognize this: it's similar to @code{(expr) ? a : b}. If you're not, here is what happens:
@itemize @bullet
@item @code{(a > b)}: this is false,
@item @code{... and c}: this is ignored since the previous expression was false. The first expression is returned (@code{false}).
@item @code{... or d}: The previous expression was @code{false}, so @code{or} will return @code{d} (12).
@item @code{n = ...}: @samp{12} was returned, so @code{n} is now @samp{12}.
@end itemize

If you find this confusing, you can use @ref{If statements, if statements} instead. This little trick is mainly used as a shortcut.

@anchor{If statements}
@subsubsection If statements
@code{if statements} are used to test some expression and if @code{true} it will execute some other code.
The general syntax is like this:
@codeblock{if expr1 then
    @minus{}@minus{} Code here for when expr1 is true
elseif expr2 then
    @minus{}@minus{} Code here for when expr2 is true and expr2 isn't
else
    @minus{}@minus{} Code here for when expr1 and expr2 are not true
end}

The @code{elseif} and @code{else} part is optional. The keyword @code{end} is used to end the @samp{if-then block}.
An expression is false when the value is @code{false} or @code{nil}. In any other case it's @code{true}.

@strong{NOTE}: In some other (scripting) languages zero (@samp{0}) and an empty @code{string} are @code{false}, however this is not the case in Lua.

Here are some examples (with comments) to illustrate some usage of if statements.
@codeblock{n = false
if n then
    @minus{}@minus{} Impossible
else
    @minus{}@minus{} Do something here
end
@*
@minus{}@minus{} This is the same as the @ref{and or trick}
if (a > b) then
    n = c
else
    n = d
end
@*
if (msg == "yes") and (not flag) then
    flag = true
elseif (msg == "no") and (flag) then
    flag = false
end}

@strong{Note}: I used parenthesis(@samp{()}) around some expressions and will in later examples. This is merely for clarity in most cases. In above examples the parenthesis don't have any effect.

@subsection Loops
@emph{Loops} are used to execute some code lines more than once. In the following sections the different kind of loops available in Lua are explained.

@subsubsection @code{while} loops
The @code{while} loop looks like this:
@codeblock{while expr1 do
    @minus{}@minus{} Do some code
end}

As long as @samp{expr1} is not @code{false} it will execute the code in the @samp{while-do-end} block.
Here is a short example:
@codeblock{n = 1
while (n <= 10) do
    @minus{}@minus{} Some code
@*
    n = n + 1
end}
In this example the @code{while} loop repeats itself until @code{n} is more than @samp{10}.

@subsubsection @code{repeat} loops
Another loop is the @samp{repeat-until} loop. This will repeat the code block @emph{until} some expression is @code{true}.
Example:
@codeblock{n = 1
repeat
    @minus{}@minus{} Some code
@*
    n = n + 1
until n > 10}
This does exactly the same as the @code{while} example. So why choose @code{repeat} over @code{while}? A reason is when you want to execute the code in the block at least once. With a @code{while} loop the expression has to be @code{true} before the loop can even begin. With the @code{repeat} - @code{until} statement however it will check the expression at the end of the block and therefore execute the code at least once.

@subsubsection @code{for} loops
There are 2 kind of @code{for} loops: the @emph{numeric} and the @emph{generic}. We will discuss the first here, the @emph{generic} @code{for} loop will be explained @ref{Traversing Tables, here}.

The @emph{numeric} @code{for} loop looks like this:
@codeblock{for var=expr1,expr2,expr3 do
    @minus{}@minus{} Some code
end}

@table @emph
@item var=expr1
This will assign @emph{expr1} to the variable @code{var}. Note that this variable @strong{only} exists in the @code{for} loop.
@item expr2
As long as @emph{expr2} is unequal to @code{var} the loop repeats itself.
@item expr3
This is optional. @emph{expr3} is used to specify how much @code{var} should increment (or decrement in case a negative value is specified). If not specified it defaults to @samp{1}.
@end table

Now some examples:
@codeblock{for n=1,10 do
    @minus{}@minus{} Some code here that will be executed 10 times
end
@*
for n=2,20,2 do
    @minus{}@minus{} Some code that will be executed 10 times. (n = incremented by 2 each time)
end}

Here are some points to remember with @code{for} loops:
@itemize @bullet
@item As been said the variable used for the loop only exists inside the loop. If you need the value outside the loop you should copy it to another variable.
@item All the three expressions are evaluated just once. This is important to know when you use @anchor{Functions, functions} for an expression.
@item Do not modify the variable used by the @code{for} loop by hand.
@end itemize

@subsubsection @code{break}
To escape from a loop in Lua you can use @code{break} (or @ref{Return values, return}).
Here is an example:
@codeblock{n = 1
while (true)  @minus{}@minus{} Infinite loop
    if (n == 50) then
        break @minus{}@minus{} Not infinite after all
    end
    n = n + 1
end}
This will escape from the loop when n equals to @samp{50}.
Note that you can only use @code{break} at the end of a code block. In this case it was at the end of the @samp{if-then} block. If this wasn't the case Lua would throw an error.

@anchor{Functions}
@subsection Functions
@emph{Functions} are a way to create @samp{commands}. With functions a piece of code can be executed on all kinds of places.

@subsubsection Basics
Before a function can be used you have to @emph{declare} it:
@codeblock{function funcname(args)
    @minus{}@minus{} Code
end}
@table @emph
@item funcname
This is how the function will be called.
@item args
Which @emph{arguments} or @emph{parameters} this function expects.
@end table

@subsubsection Functions arguments
Some functions may need data from the caller. To pass this data @emph{function parameters} are used. These are variables which are @emph{local} (not exist outside the function) to this function. Here is an example to accomplish this:
@codeblock{counter = 0
@*
function increment(n) @minus{}@minus{} Function that increments @samp{counter} by @code{n}
    counter = counter + n
end
@*
@*
increment(5)
@minus{}@minus{} counter is now 5
increment(-2)
@minus{}@minus{} counter is now 3}
You can also specify multiple function arguments: just separate them with a comma (@samp{,}).@*
@*
If the user doesn't specify one or more parameters then they will be @code{nil}. With that info we can make it so that some arguments have default values in case they are not given by the caller. For example:
@codeblock{function increment(n)
    if (not n) then
        n = 1
    end
    counter = counter + n
end}
Now if @code{increment} isn't specified with any arguments (@samp{increment()}) it will increment @code{counter} by @samp{1}. We can also use a shorter syntax using the @code{or} operator:
@codeblock{function increment(n)
    n = n or 1
    counter = counter + n
end}
Operator @code{or} will return the second expression if the first is @code{false} or @code{nil}, thus defaults to @samp{1}.@*
@*
Functions can also have a variable number of arguments. @xref{Variadic Functions} for more info.

@anchor{Return values}
@subsubsection Return values
When a function is called it can also return data to the caller. Here is how it generally looks:
@codeblock{function func()
    @minus{}@minus{} Code here
    return arg1, arg2, arg3 @minus{}@minus{} etc
end}

Unlike some other language, lua has the feature to return multiple values. Here are some examples about returning values:
@codeblock{function sum(a, b)
    return a + b
end
@*
function f()
    return "Hello", " ", "World"
end
@*
@*
n1 = 5
n2 = 10
n3 = sum(n1, n2)    @minus{}@minus{} n3 = 15
@*
str1, str2, str3 = f() @minus{}@minus{} str1 = "Hello", str2 = " ", str3 = "World"}

@subsection Local variables
For now mostly @emph{global} variables were used. There is another type of variable: the @emph{local} variable. The variable used in a numeric @code{for} loop is local, so are the function arguments. Local variables only exist in a code block (and the underlying code blocks). To create local variables you have to @emph{define} them with the @code{local} keyword. Local variables are mostly used inside functions, so that they don't corrupt the global environment.
As usual, here are some examples:
@codeblock{function f()
    local a             @minus{}@minus{} a will only exist in this function
    local b, c          @minus{}@minus{} More variables can be defined at once
    local c, d = 5, 6   @minus{}@minus{} And can also be assigned: c = 5, d = 6
@*
    @minus{}@minus{} Some code
end
@*
count = 0    @minus{}@minus{} Global variable
@*
function g()
    local count     @minus{}@minus{} Override count
    count = 1       @minus{}@minus{} Modify our own count
end
@*
@minus{}@minus{} count is still 0 here}
As shown above @code{local} variables can have the same name as a existing global variable. In such cases @code{local} variables have a higher priority then underlying global variables.


@section Advanced Lua
In this section some of the more advanced features of Lua will be shown. At least the first 2 sections about tables are important. For less advanced installers these might be enough for now.

@subsection Functions As Variables
Functions are also a variable type. The way we did to create functions so far is actually a shortcut to assign a function to a (global) variable:
@codeblock{function f()
    @minus{}@minus{} ...
end}
Is essentially the same as:
@codeblock{f = function()
    @minus{}@minus{} ...
end}

With that knowledge some interesting things can be made. For example, a function can be passed to another function:
@codeblock{function sum(a, b)
    return a + b
end
@*
x = 0
@*
function modifyx(func, val1, val2)
    x = func(val1, val2)
end
@*
modifyx(sum, 1, 1)
@minus{}@minus{} x is now 2}

Another example is to use @emph{anonymous functions}. These are, as the name suggests, functions without a name. A good reason to use them is when you want to pass (a simple) function like we did above. Here is the anonymous version:
@codeblock{x = 0
@*
function modifyx(func, val1, val2)
    x = func(val1, val2)
end
@*
modifyx(function(a, b)
            return a + b
        end, 1, 1)
@minus{}@minus{} x is now 2}
This does essentially the same, just with an anonymous function.

@anchor{Tables}
@subsection Tables
Tables are generic types also called @emph{objects}. Tables can be used to create new datatypes, store blocks of data (arrays) and even for OOP(Object Orientated Programming). Not all features of tables are described. Just the few that are in the authors opinion important to know for now. A good reference for lua tables is the @uref{http://www.lua.org,Lua Book}.

@subsubsection Creating A @code{table}
Before we go in to details, lets start with how to create a table. Unlike other types, you have to @emph{construct} tables. The simplest way of doing this is like this:
@codeblock{t = @{ @}}
The 2 curly braces are the key to construct a new table. There are other ways to construct a table, these will be handled in the next sections.@*
@*
Another thing to remember is that variables can only @emph{point} to a table. The following example shows an error:
@codeblock{t = @{ @}   @minus{}@minus{} Construct a new table
t2 = t    @minus{}@minus{} Copy table (ERROR)}
In this example, @code{t2} will @strong{not} be a copy of @code{t}. Instead @code{t2} will @emph{point} to the same table as @code{t} does. @*
@*
When all references to a table are gone, for example by setting @code{t} and @code{t2} to @code{nil}, the table will be removed by Lua's garbage collector.

@anchor{arrays}
@subsubsection Tables Seen As An Array
As been said, tables can be used in many ways. Lets start with the @emph{array} like feature. You can see an array like a datablock. This block can expanded, indexed and traversed. Here are the usual examples:
@codeblock{
t = @{ @} @minus{}@minus{} Construct new table
@minus{}@minus{} Create 3 table entries
t[1] = 5
t[2] = 6
t[3] = 7}
In this example the table referenced by @code{t} has 3 entries. Each are @emph{indexed} by numbers: @code{t[1]} points to 5, @code{t[2]} to 6 and @code{t[3]} to 7.

@anchor{luamap}
Unlike languages such as C, the arrays from Lua can be indexed with any type (except @code{nil}). And as usual, the data can be from any type while @code{nil} is used to remove the data. Tables that are indexed by other types than numbers are sometimes called @emph{maps}. Some more examples:
@codeblock{t = @{ @}
t["Name"] = "Rick"
t["Phone"] = 123456789
t["Country"] = "The Netherlands"}
This time we used @code{string}s to index a table. Mixes of types can be used for indexing aswell.@*
@*
Usually though we use numbers only as indexes. Records (see below) are mainly used for strings. When you use numbers to index an array it's recommended to start with @samp{1} instead of @samp{0} like some other languages do. A reason for this is that most Lua functions that operate on tables (or arrays) expect that @samp{1} is the first index.

@anchor{records}
@subsubsection Table Seen As A Record
As explained in the previous section tables can be @emph{indexed}. Another way to assign data to a table is by using @emph{records}. This is the general syntax:
@codeblock{tablename.fieldname}
And an example:
@codeblock{t = @{ @}
t.Name = "Rick"
t.Phone = 123456789
t.Country = "The Netherlands"}
Looks familiar? It's in fact the same as the example shown with the array indexed by strings. In other words
@codeblock{t["field"] = 1}
is the same as
@codeblock{t.field = 1}
The reason for this alternative syntax is to have a shortcut specifically for records

@anchor{modules}
@subsubsection Table Seen As A Package
Another popular way is to use tables for @emph{packages} or @emph{modules}. A good example are the Lua libraries discussed later. 
A package is basically a record which is defined somewhere else. This record contains mostly functions and sometimes other variables. As said before,functions are a variable type. Using that knowledge we can create a package like this:
@codeblock{mypackage = @{ @}
mypackage.f = function()
                @minus{}@minus{} Some code
              end
mypackage.v = "Hello World"
@*
mypackage.f()    @minus{}@minus{} Call f() from mypackage}
For functions in packages Lua has a shortcut:
@codeblock{@minus{}@minus{} Same as above
function mypackage.f()
    @minus{}@minus{} Some code
end}

@anchor{Classes}
@subsubsection Table Seen As A Class
Tables can also be threaded as @emph{classes}. Simply put, these are data types much like records; they have their own variables, called @emph{members} and their own functions, called @emph{methods}. Each class has to be created, mostly through another function.@*
@*
In this guide we'll skip the details about defining new classes and terms such as inheritance. Instead the only thing that is discussed is how to use them, since a few functions from the Lua Library deal with classes.@*
@*
Usually calling function methods from a class is slightly different than that from packages: with packages you used the @samp{.} operator, with classes you use the @samp{:} operator instead.@*
@*
Here follows an example using the @code{io} package from the Lua library. @xref{io} where all the IO functionality is discussed.
@codeblock{@minus{}@minus{} The following line opens the file 'myfile.txt' for reading (specified by "r").
@minus{}@minus{} The io.open function returns a class that can be used to operate on the opened file.
file = io.open("myfile.txt", "r")
@*
@minus{}@minus{} One of the methods of the class is read(), using this function we can read everything from the file to a string:
text = file:read("*all")
@*
@minus{}@minus{} And when we're done, we use the close method to close the file and free the used resources:
file:close()}

@anchor{Traversing Tables}
@subsubsection Traversing Tables
To traverse a table we can use the @emph{generic} @code{for} loop combined with a @emph{iterator function}. The syntax looks like this:
@codeblock{for vars in expression do
    @minus{}@minus{} Code
end}
@table @emph
@item vars
These are 1 or more variables (depending on the used iterator). Multiple variables are as usual separated with a comma.
@item expression
Normally the iterator function
@end table
So what is an iterator function? To say it easy: when you call it, it will return the next entry of a table. It can do so because it will store its current state by each call. There are different kinds of iterators in Lua. We'll discuss 2 types here and some others are explained in the @ref{Lua Library Reference}.@*
@*
The first we discuss is the @code{pairs} function. This function, combined with a (generic) @code{for} loop, can traverse @emph{any} table. Here is a example:
@codeblock{t = @{ @}
t[1] = 55
t[2] = 105
t.name = "Rick"
@*
for i,v in pairs(t) do
    print("Table entry: " .. i)
    print("Contains: " .. v)
end}
You might be wondering where @code{print} comes from. It's a Lua function which prints text to the standard output (usually a terminal). This function is discussed further @ref{print, here} @*
@*
Running the program it produced the following output:
@codeblock{Table entry: 1
Contains: 55
Table entry: 2
Contains: 105
Table entry: name
Contains: Rick}
As you can see the first variable (@code{i}) is used to store the current index of the table. The second variable (@code{v}) is used to store the value of the current entry. @*
@*
The second iterator function is @code{ipairs}. This function is almost identical to @code{pairs}. The only difference is that it will @emph{only} list numeric indexes. This is useful for arrays. If we change the above example to use @code{ipairs} instead of @code{pairs} it will produce the following output:
@codeblock{Table entry: 1
Contains: 55
Table entry: 2
Contains: 105}
As you can see it omits the @code{"name"} index. Note that, as other Lua functions, @code{ipairs} expects that @samp{1} is used as the first index for an array.

@subsubsection Table Constructors
For now we only used one way to construct tables. Another way is to assign data right away when the table is constructed. For this you can use different ways to accomplish this. @*
@*
The first way is specifically for arrays indexed by numbers, example:
@codeblock{array = @{ 5, 10, "Hello World" @}}
This is equivalent to
@codeblock{array = @{ @}
array[1] = 5
array[2] = 10
array[3] = "Hello World"}
As you see, it starts with index @samp{1}.
@*
Another way is handy for records and such:
@codeblock{record = @{ Name="Rick", Country="The Netherlands" @}
@minus{}@minus{} or like this:
record2 = @{ "Name"="Rick", "Country"="The Netherlands" @}}
which would be equivalent to
@codeblock{record = @{ @}
record.Name = "Rick"
record.Country = "The Netherlands"
@minus{}@minus{} or like this:
record2["Name"] = "Rick"
record2["Country"] = "The Netherlands"}
@*
Table constructors can be nested, like this:
@codeblock{table = @{ @{5, 10@}, @{15, 20@} @}
print(table[1][1], table[1][2])   @minus{}@minus{} prints @samp{5     10}
print(table[2][1], table[2][2])   @minus{}@minus{} prints @samp{15    20}}

@subsubsection The @samp{#} operator
There is one special operator for Lua tables: the @samp{#} operator. This operator return the number of entries with a numeric index in a table. It stops counting if the next index has no value (@code{nil}).@*
@*
Example:
@codeblock{t = @{ 5, 10, 15 @}
print("t got " .. #t .. " elements")    @minus{}@minus{} Prints "t got 3 elements"
t[5] = 25
print("t got " .. #t .. " elements")    @minus{}@minus{} Prints "t got 3 elements", because index 4 is nil}

@anchor{Variadic Functions}
@subsection Variadic Functions
@emph{Variadic functions} are functions with a @emph{variable} number of arguments. Here is a example that displays how to use them:
@codeblock{function f(...)
    for i, v in pairs(arg) do
        print("Arg " .. i .. " contains " .. v)
    end
end
@*
f("Hello", " ", "World")}
When executed, the following output is produced:
@codeblock{Arg 1 contains Hello
Arg 2 contains
Arg 3 contains World
Arg n contains 3}
@table @emph
@item @samp{...}
This is a way to say to Lua that you don't know which arguments are to be expected.
@item arg
In variadic functions this variable is an array with all passed arguments.
@item n
As you may have noticed from the output there is also an entry called @samp{n}. This holds the total number of arguments in the array.
@end table
@*
You can also pass the arguments to another function:
@codeblock{function f(...)
    @minus{}@minus{} Do some stuff
    @*
    print(...)    @minus{}@minus{} The print function is also variadic
end}




@node Lua Library Reference
@appendix Lua Library Reference

In the previous appendix we discussed the basics of Lua. In this chapter we start with the Lua library. The Lua library contains many different functions. Most are inside @ref{modules}. A special note for people who already know Lua: Nixstaller has lots of additional functions added to existing modules, so this section is handy to read for everyone.@*
@*
For each function a definition will be given with a description beneath it. In the definition the expected arguments for this function are given aswell. Optional arguments are between square brackets, three dots (@samp{...}) means that it is a variadic function. If an argument has a default value it will be shown with @samp{=val} right next to the argument.


@section String Functions
In this section we will discuss functions that can modify strings, get info from strings, format strings, search strings etc. All these functions are in the @code{string} package. @*
@*
Note that a string itself is @emph{immutable}. This means that once a string is created, you cannot modify it (well you can delete it by reassigning the variable to @code{nil}). For this reason every function that will operate on strings will return a new (sub)string. Some functions use @emph{string indexes}. A string starts always at index @samp{1}. A negative index is used to start counting backwards, meaning that @samp{-1} equals to the string length, @samp{-2} equals to the string length-1 etc.

@subsection Basic String Functions
We start with the more easy and common functions.

@luafunc string.byte (s [, i=1 [, j=i]])
This will return the byte codes (such as ASCII values) used from string @code{s} starting with index @code{i} till @code{j}. Byte codes can differ from platform to platform.
@endluafunc

@luafunc string.char (...)
Expects numeric arguments which are byte values (for example returned from @code{string.byte}). It will return a string consisting of each argument converted to the corresponding character. @*
Example:
@codeblock{print (string.char(string.byte("Hello World", 1, -1)))   @minus{}@minus{} Prints Hello World}
@endluafunc

@luafunc string.len (s)
Returns the length of the string @code{s}. The @samp{#} operator does the same.
@endluafunc

@luafunc string.lower (s)
Returns a lower cased version of string @code{s}. Characters that don't have a lower cased version are untouched.
@endluafunc

@luafunc string.upper (s)
Returns a uppercased version of string @code{s}. Characters that don't have an uppercased version are untouched.@*
Example:
@codeblock{s = "Hello World!"
print(string.lower(s))    @minus{}@minus{} Prints hello world!
print(string.upper(s))    @minus{}@minus{} Prints HELLO WORLD!}
@endluafunc

@luafunc string.rep (s, n)
Returns a string that is a copy of string @code{s} replicated @code{n} times.@*
Example:
@codeblock{print(string.rep("A", 5))    @minus{}@minus{} Prints AAAAA}
@endluafunc

@luafunc string.reverse (s)
Returns a reversed version of string @code{s}.
@endluafunc

@luafunc string.sub (s, i [, j=-1])
Returns a @emph{substring} from string @code{s} starting at index @code{i} till index @code{j}. When @code{i} is negative it will start at the end.@*
Examples:
@codeblock{s = "Hello World"
print(string.sub(s, 2))    @minus{}@minus{} Prints ello World
print(string.sub(s, 1, 2)) @minus{}@minus{} Prints He
print(string.sub(s, -5))   @minus{}@minus{} Prints World}
@endluafunc

@luafunc string.format (s, ...)
This function returns a string that is formatted according to rules similar to the C functions from the @code{printf} family. The first argument should be a string which can be formatted according to some rules. These rules are specified in the form of @emph{modifiers}. These modifiers have the following syntax:
@codeblock{%[flags][width][.precision]type}

@table @samp
@item %
The first token should always be a percent sign (@samp{%}).
@item [flags]
Optional. For numeric types only. Can be one of these:
@table @samp
@item +
Used to force the usage of the @samp{+} or @samp{-} character in numbers.
@item -
When a width is given (see below) uses left alignment instead of right alignment.
@item #
Alternate form. In the authors opinion not really important. See the man pages of @code{printf} if you're interested.
@item 0
(as in zero) If a width is given (see below), it will use zeros instead of blanks for padding.
@end table
@item [width]
Optional. If a number is given it will make the converted text at least @samp{n} wide by filling it with spaces if necessary.
@item [.precision]
Optional. Should be a number. The meaning depends on the type and is given below for each one.
@item type
This specifies what the control modifier should do and can be one of the following:
@table @samp
@item %s
Will be replaced by a string. If a precision is given it will use that as a max string length.
@item %d
@item %i
@item %u
Will be replaced by a round number. If a precision is given it will use that as a minimum digit count (adding zeros if necessary).
@item %o
Will be replaced with an octal number. If a precision is given it will use that as a minimum digit count (adding zeros if necessary).
@item %x
@item %X
Will be replaced with a hexadecimal number. Use @samp{%X} for capital characters. If a precision is given it will use that as a minimum digit count (adding zeros if necessary).
@item %e
@item %E
Will be replaced with a number with scientific notation. @samp{%E} is for a capital exponent character (@samp{E}). If a precision is specified it will use as a maximum of numbers to appear after the decimal point.
@item %f
Will be replaced by a @emph{floating point} or @emph{real} number. That is simply said a number which can contain a decimal point. If a precision is specified it will use as a maximum of numbers to appear after the decimal point.
@item %g
@item %G
The same as @samp{%e} and @samp{%E} or @samp{%f}. This depends on the given precision, which is 6 by default. If the exponent of the number is below -4 or above the precision @samp{%e} (or @samp{%E}) is used. Otherwise @samp{%f} will be used.
@item %q
Will produce a string that is @samp{safe} for Lua. This means that special characters such as newlines, quotes, backslashes etc are properly escaped.
@end table
@end table
The returned string from @code{string.format} will contain all the result(s) from the control modifier(s), at the place where the control modifier(s) originally were placed. Each control modifier will use the next given function argument.@*
@*
To clear things up, here are some examples:
@codeblock{name = "Rick"
age = 21
print(string.format("Hello you are %s and %d years old.", name, age))    @minus{}@minus{} Prints "Hello you are Rick and 21 years old."
f = 12.25/5.55
@minus{}@minus{} The first %f will be replaced with @samp{2.207207}, the second with @samp{2.21})
print(string.format("The result of 12.25 / 5.55 = %f or shortened: %.2f", f, f))
print(string.format("An aligned number: %3d", 5))    @minus{}@minus{} Prints "An aligned number:   5"}

@endluafunc

@subsection Advanced String Functions
Lua has a few advanced functions to find and replace (sub)strings. For now I will skip these and just point you to the right sections: @uref{http://www.lua.org/pil/20.html,This chapter in the Lua book} and parts of the @uref{http://www.lua.org/manual/5.1/,Lua Manual}.


@section Table Functions
Lua has a few functions to help you when working with tables. These functions are all in the @emph{table} module.

@luafunc table.concat (t, [, sep=""[, i=1[, j=#t]]])
Returns a string that has all elements of table @code{t} next to eachother. Each entry can be separated by the string @code{sep}. The @code{i} and @code{j} variables are used to indicate a starting and ending index.
Examples:
@codeblock{t = @{ "Hello", "World", "!" @}
t2 = @{ 5, 10, 15 @}
s = table.concat(t)    @minus{}@minus{} s = "HelloWorld!"
s2 = table.concat(t, " ")    @minus{}@minus{} s2 = "Hello World !"
s3 = table.concat(t2, ", ", 2)    @minus{}@minus{} s3 = "10, 15"}
@endluafunc

@luafunc table.insert (t[, p], x)
This function only works with arrays with numeric indexes. The function will insert variable @code{x} into table @code{t} at position @code{p}. When only 2 function arguments are given the second will be used as value to insert and the position will be at the end of the table.
Examples:
@codeblock{t = @{ "Apples", "Oranges" @}
table.insert(t, 1, "Bananas")    @minus{}@minus{} t = @{ "Bananas", "Apples", "Oranges" @}
table.insert(t, "Melons")        @minus{}@minus{} t = @{ "Bananas", "Apples", "Oranges", "Melons" @}}
@endluafunc

@luafunc table.maxn (t)
This function only works with arrays that have numeric indexes. The function loops through the whole table to find the highest used index.
@endluafunc

@luafunc table.remove (t[, p=#t])
Removes the entry from table @code{t} at position @code{p}. The entry that is removed is used as return value.
Example:
@codeblock{t = @{ 5, 10, 15 @}
table.remove(t, 1)    @minus{}@minus{} t = @{ 10, 15 @}
table.remove(t)       @minus{}@minus{} t = @{ 10 @}}
@endluafunc

@luafunc table.sort (t[, c])
Only works with arrays with numeric indexes. This function will sort all the entries from the table @code{t}. The optional argument @code{c} can be used to specify a function that is a replacement of the @samp{<} operator. This function is called to check if one table entry is smaller than another. The function receives 2 arguments, the first and second entry, and should return @code{true} if the first entry is less than the second.
Examples:
@codeblock{fruits = @{ "Lemon", "Apple", "Orange" @}
table.sort(fruits)    @minus{}@minus{} fruits = @{ "Apple", "Lemon", "Orange" @}
@*
function comp(e1, e2)
    return e1 > e2    @minus{}@minus{} Reversed sorting
end
@*
table.sort(fruits, comp)    @minus{}@minus{} fruits = @{ "Orange", "Lemon", "Apple" @}}
@endluafunc


@section Math Functions
Lua supports many different math related functions through the @code{math} module. Since not many of these functions are important for Nixstaller only a few are discussed.

@luafunc math.abs (n)
Returns the absolute value of @code{n}
@endluafunc

@luafunc math.fmod (x, y)
Returns the modulus (remainder) of x and y.
@endluafunc

@luafunc math.max (n, ...)
Returns the biggest value from the given arguments.
@endluafunc

@luafunc math.min (n, ...)
Returns the smallest value from the given arguments.
@endluafunc

@luafunc math.random ([l[, h]])
If no arguments are given returns a @samp{random} number between 0 and 1. If @code{l} is given it will return a random number (rounded) between 1 and @code{l}. If both @code{l} and @code{h} are given it will return a random number between these values.
@endluafunc

@luafunc math.randomseed (n)
Sets the @samp{seed} for the @code{math.random} function. For each seed an unique series of numbers will be returned by the @code{math.random} function. So if the seed is always the same (ie. not changed) @code{math.random} will always return the same values. To get @samp{real} random numbers a way is to set the seed to the system time when the Lua script is started. The system time can be retrieved by the @ref{os.time} function.
@endluafunc


@anchor{os}
@section Functions That Interact With The OS
In the @code{os} package you can find functions that will handle OS specific things. Nixstaller has included some extra functions to this module.@*
@*
On failure (eg. a file doesn't exist), some functions will return 2 things: @code{nil} and a string containing an error message. On success these functions will return @code{true}. With this you can easily handle errors like so:
@codeblock{@minus{}@minus{} Function taken from internal Nixstaller code
@minus{}@minus{} (ThrowError is just a function that cleans some stuff up and calls error())
function RequiredCopy(src, dest)
    local stat, msg = os.copy(src, dest)
    if (not stat) then
        ThrowError("Error could not copy required file %s to %s: %s", src, dest, msg or "(No error message)")
    end
end}

@defvr Variable os.arch
This is a string containing the name of the current CPU architecture, such as x86 or x86_64.
@end defvr

@defvr Variable os.osname
This is a string containing the name of the current Operating System.
@end defvr

@luafunc os.chdir (d)
Tries to change the current directory to directory @code{d}. On failure it will return @code{nil} and the error message, on success it will return @code{true}.
@endluafunc

@anchor{os.chmod}
@luafunc os.chmod (f, p)
Changes the permissions from file or directory @code{f} using the unix like permission bits taken from string @code{p}. On failure it will return @code{nil} and a string containing the error message, on success it will return @code{true}.
Example:
@codeblock{os.chmod("mydir/", "777")    @minus{}@minus{} The directory 'mydir' has now full access for everyone}
@endluafunc

@luafunc os.clock ()
Returns the time used by the CPU in seconds.
@endluafunc

@luafunc os.copy (f[, ...], d)
Copies the file @code{f} to destination @code{d}. If @code{d} is a directory it will copy the file to that directory, if @code{d} is a file it will overwrite the contents of that file with the contents of @code{f}. You can also specify 3 or more arguments: in this case the last argument, @code{d}, should be a directory and all the previous arguments files that should be copied to this directory.
examples:
@codeblock{os.copy("file1", os.getenv("HOME"))         @minus{}@minus{} Copies 'file1' to the users home directory
os.copy("file1", "file2")                   @minus{}@minus{} Replaces 'file2' with 'fil1'
os.copy("file1", "file2", "file3", "/tmp")  @minus{}@minus{} Copies 'file1', 'file2' and 'file3' to /tmp}
@strong{Note}: The source and destination files/directories should exist or else Lua will throw an error and abort the program.
For (other) copy failures @code{nil} and the error message will be returned. On success @code{true} is returned.
@endluafunc

@luafunc os.difftime (t2, t1)
Returns the difference in seconds from @code{t2} and @code{t1}. Mostly this is the same as @code{t2 - t1}.
@endluafunc

@anchor{os.execute}
@luafunc os.execute (c)
Executes the shell command @code{c}. This function returns the exit code from the executed command, though to be able use it you should use the @ref{os.exitstatus} function. In most cases it's recommended to use @ref{install.execute} instead of this function.
@endluafunc

@anchor{os.exit}
@luafunc os.exit ()
Terminates the program.
@endluafunc

@anchor{os.exitstatus}
@luafunc os.exitstatus (s)
This function is usually used in combination with @ref{os.execute}. The argument @code{s} should be the return value from the @code{os.execute} function. This function translates this value to the real exit status and returns it.
@endluafunc

@luafunc os.fileexists (f)
Returns @code{true} if the file or directory @code{f} exists.
@endluafunc

@luafunc os.filesize (f)
Returns the filesize in bytes of file @code{f} or @code{nil} plus the error message on failure.
@endluafunc

@luafunc os.getcwd ()
Returns a string containing the current directory. On failure it will return @code{nil} and the error message.
@endluafunc

@luafunc os.getenv (v)
Returns a string containing the value of the shell variable @code{v}. If this variable does not exists, @code{nil} will be returned.
@endluafunc

@luafunc os.isdir (f)
Returns @code{true} if @code{f} is a directory.
@endluafunc

@luafunc os.log (s, ...)
Logs the text from string @code{s} and all the function arguments after that, using @code{syslog}. You can use this function to debug for example.
@endluafunc

@luafunc os.mkdir (d[, m="0777"[, b])
Tries to create the directory @code{d}. If @code{m} is given it should be a string with the unix style permission bits. If @code{b} is @code{true} the @samp{umask} of the current system will be ignored. See the manual page of @code{umask} for details. The function will return @code{nil} and an error message on failure, on success it will return @code{true}.
Example:
@codeblock{@minus{}@minus{} Creates directory in the users home directory with rwx access for the user only.
os.mkdir(os.getenv("HOME") .. "/.myconfig", "700")}
@endluafunc

@luafunc os.mkdirrec (d[, m="0777"[, b])
Tries to create directory @code{d} and its parent directories if non existant. @code{m} and @code{b} have the same function as with @code{os.mkdir}. Returns @code{nil} and an error message on failure, on success it will return @code{true}.
@endluafunc

@luafunc os.readperm (f)
Returns @code{true} if the file or directory @code{f} can be read.
@endluafunc

@luafunc os.remove (f)
Removes the file or directory @code{f}. Directories needs to be empty to be removed. On error it returns @code{nil} and a string containing the error message. On success @code{true} will be returned.
@endluafunc

@luafunc os.rename (f, f2)
Renames the file or directory @code{f} to @code{f2}. On error it will return @code{nil} and a string containing the error message, on success @code{true}.
@endluafunc

@luafunc os.setenv (e, v[, o=true])
This function is used to change or add a shell environment variable. The name of this variable is specified by the argument @code{e}. The value should be a string and is specified by @code{v}. The optional argument, @code{o}, is used to specify if the value should be overwritten in case the variable already exists.
@endluafunc

@anchor{os.time}
@luafunc os.time ()
Returns the current system time. This can for example be used as an argument for @code{math.randomseed}. There is also a second version which will put information in a table, such as the current day and month. For this see the @uref{http://www.lua.org/manual/5.1/,Lua Manual}.
@endluafunc

@luafunc os.tmpname ()
Returns a random file name which can be used for files in the @code{/tmp} directory. This only returns a filename; you still have to create it (see the io package) and remove it manually.
@endluafunc

@luafunc os.writeperm (f)
Returns @code{true} if the file or directory @code{f} has write access for the current user.
@endluafunc


@anchor{io}
@section I/O Functions
The @code{io} package provides several Input/Output functions. As with some functions from the @code{os} package, some functions return @code{nil} and a string containing an error message on failure and @code{true} on success.@*
@*
At first some functions of the @code{io} package will be discussed. After that the @code{file} class will be explained. Instead of adding examples for most functions, this section ends with a few bigger examples. This is because most functions need eachother.

@luafunc io.dir (d)
This function is a function iterator (@pxref{Traversing Tables}) that is used to scan directory @code{d}. On success the function will return a string containing the next file or directory name. On failure (eg. the directory does not exist) it will return @code{nil} and a string containing the error message.@*
Example:
@codeblock{@minus{}@minus{} This will list every file and directory in the current directory
for d in io.dir(".") do
    print(d)
end}
@endluafunc

@luafunc io.md5 (f)
This function calculates the MD5 sum for the given file @code{f}. MD5 sums are usually used to check for changed files. If the file could not be opened, @code{nil} is returned.
@endluafunc

@anchor{io.open}
@luafunc io.open (f[, m="r"])
Tries to open the file @code{f}. The optional argument @code{m} defines how to open the file. This should be a string containing one of these:
@table @code
@item "r"
Opens the file in read mode. All reads start from the beginning of the file. Fails if the file doesn't exist.
@item "w"
Opens the file in write mode. If the file exists all the previous contents will be removed first. The file will be created if the file doesn't exist.
@item "r+"
Opens the file for reading and writing. The previous contents will be kept and reading/writing will start at the beginning. Fails if the file doesn't exist.
@item "w+"
Opens the file for writing and reading. The file will be cleared if it exists or created if it doesn't exist. Writing/Reading starts from the beginning.
@item "a"
Opens the file in append mode. If a file exists it the contents will be kept and writing starts from the end of the file. If the file doesn't exist it will be created.
@item "a+"
Opens the file in append and read mode. This is the same as the "a" option except that a file can be read aswell (reading also starts at the end of the file).
@end table
A @samp{b} can be appended to the mode string indicating that it's a binary file. This isn't necessary on most UNIX like systems though because binary and text files are threaded equally.@*
@*
On success, this function will return a @emph{file handle}. This is a @ref{Classes, class} with member functions to operate on the file. File handles are discussed @ref{File Handles, here}. When the file could not be opened, @code{nil} and an error message is returned.
@endluafunc

@luafunc io.popen (c[, m="r"])
This will execute the shell command @code{c} in a separate process. The function returns a @emph{file handle} like @code{io.open} does. More on file handles @ref{File Handles, here}.@*
@*
If @code{m} is "r" all data from the command that is written to the standard output can be read. If "w" is specified the standard input from the file is linked to the data provided from writes.
@endluafunc

@luafunc io.tmpfile ()
Creates a temporary file and returns a @emph{file handle}. This file has a random name and is opened as "r+b" (@pxref{io.open}). On exit the file is removed automatically.
@endluafunc

@luafunc io.type (t)
This function checks the file handle @code{f}. If the file is opened it will return the string "file", if it's closed "closed file" or @code{nil} if @code{t} is not a file handle.
@endluafunc

@anchor{File Handles}
@subsection File Handles
File handles are @ref{Classes, classes} that can operate on files, such as reading or writing. They are returned from @code{io.open}, @code{io.popen} and @code{io.tmpfile}. The file handle class is referred with the name @code{file} each time below.

@luafunc file:close ()
Closes the file. When a file is closed you cannot read or write from/to it anymore. Note that each file eventually is closed automatically.
@endluafunc

@luafunc file:flush ()
Normally writes are @emph{buffered}. This function forces to write and clean the buffer.
@endluafunc

@luafunc file:lines ()
This is an iterator function (@pxref{Traversing Tables}) that can be used in a generic @code{for} loop to get each line from the file. Note that the trailing newlines are deleted from the output.
@endluafunc

@luafunc file:read (...)
This file is used to read from the file. The used arguments should be one of the following formats:
@table @strong
@item "*n"
Reads a number and will return it.
@item "*a"
Reads the whole file and returns it as a string.
@item "*l"
Reads and returns (the rest of) a line, without a trailing newline.
@item A number
Reads the specified amount of bytes and returns it as a string.
@end table
If no function arguments are used, the @samp{*l} option is used. This function is variadic, so multiple formats can be specified in one call. On error @code{nil} is returned.
@endluafunc

@luafunc file:seek ([b="cur"[, o=0]])
This function can be used to set/get the current file position. This position is used to start reading or writing. The parameter @code{b} is used to specify a base location and @code{o} is a number which specifies the offset from that. @code{b} can be any of these strings:
@table @strong
@item "set"
The base is at the beginning of the file.
@item "cur"
The base starts from the current location.
@item "end"
The base starts from the end of the file.
@end table
The return value is the position after the change has been applied. So @code{file:seek("set")} will return @samp{0}, @code{file:seek("cur")} returns the current position and @code{file:seek("end")} the end position. Note that this function does not work with file handles gained from the @code{io.popen} function.
@endluafunc

@luafunc file:setvbuf (m[, s=?])
Writing to a file is @emph{buffered}. This is to gain performance. The first parameter, @code{m}, is a string which defines how to buffer:
@table @strong
@item "no"
Writes are unbuffered, meaning the data will be written immediately.
@item "full"
Writes are fully buffered, this is the default. Data will only be written when the buffer is full, @code{file:flush} is called or when the file is closed.
@item "line"
Like "full", but the data is also written after each newline.
@end table
The optional @code{s} argument specifies the buffer size in bytes. By default this is a value which suites the system the most.
@endluafunc

@luafunc file:write (...)
Writes each function argument to the file. Numbers and strings are valid argument types.
@endluafunc

@subsection Examples
Here follow a few examples of the IO related functions that were discussed.@*
@*
@codeblock{@minus{}@minus{} This code will open a file, read and display its contents and close it
f, msg = io.fopen("test.txt", "r")    @minus{}@minus{} f will contain the file handle, msg an error message on failure
@*
@minus{}@minus{} File could not be opened? (eg. doesn't exists)
if (not f) then
    print("Could not open file: " .. msg)
    os.exit()    @minus{}@minus{} @xref{os.exit}
end
@*
print(f:read("*a"))
@*
f:close()
}
@*
Here is another example showing how to copy a file; it reads one line and writes it to a second file
@codeblock{@minus{}@minus{} Function that copies the contents of file src to file dest
function copy(src, dest)
    local f_src = io.open(src, "r")
    local f_dest = io.open(dest, "w")
@*
    if (not f_src or not f_dest) then
        print("Error opening files")
        return
    end
@*
    for line in f_src:lines() do
        f_dest:write(line)
@*
        @minus{}@minus{} lines() will not return the trailing newline, so we have to add it manually
        f_dest:write("\\n")
    end
@*
    f_src:close()
    f_dest:close()
end}
@*
The last example is about @code{io.popen}:
@codeblock{@minus{}@minus{} This code will execute @samp{ls -a} and print its output
cmd = io.popen("ls -a", "r")
@*
if (cmd) then
    local line = cmd:read()
    while (line) do
        print(line)
        line = cmd:read()
    end
    cmd:close()
else
    print("Could not execute command")
end
@*
This will 'open' the unix command @samp{cat} and feed it some data:
cmd = io.popen("cat", "w")
@*
if (cmd) then
    for i=1,10 do
        cmd:write("Line " .. i .. "\\n")
    end
else
    print("Could not execute command")
end}


@section Install Package
This section describes all the install related functions and variables. They are obviously Lua extensions so you won't find them in any other Lua manual. It's recommended that you read @ref{Creating Installers} first.

@subsection The @code{install} Module

@defvr Variable install.destdir
Variable that is used to set the destination directory for the @ref{install.extractfiles} function.
@end defvr

@defvr Variable install.menuentries
This variable is used to store all the desktop menu entry tables. The variable itself is a table which is indexed by the filename for the assigned desktop menu entry. More info on usage can be found @ref{deskentrieslua,,here}.
@end defvr

@defvr Variable install.screenlist
Variable that should be used to specify the installation screens to be used. Can contain classes created by the @ref{install.newscreen} function and one of these predefined variables:
@itemize @bullet
@item WelcomeScreen
@item LicenseScreen
@item SelectDirScreen
@item InstallScreen
@item FinishScreen
@item PackageToggleScreen (Package Mode only)
@item PackageDirScreen (Package Mode only)
@item SummaryScreen (Package Mode only)
@end itemize
By default @code{install.screenlist} is set like this:
@codeblock{install.screenlist = @{ WelcomeScreen, LicenseScreen, SelectDirScreen, InstallScreen, FinishScreen @}}
@end defvr

@anchor{install.extrafilespath}
@luafunc install.extrafilespath ([f])
This function returns a path to where the files are located which were placed in the @file{extra_files/} directory from the project directory. The optional string argument @code{f} is used for convenience and is simply appended to the returned path.@*
For example, if a file called @file{README} was placed in the @file{extra_files/} directory before the installer was created, we can access it as follows:
@codeblock{readmefile = install.extrafilespath("README")}
@endluafunc

@luafunc install.getlang ()
The function returns a string with the currently loaded language.
@endluafunc

@luafunc install.getpkgdir (f)
This function returns the @emph{temporary package directory}. This is the directory that is used to place files that will be installed when using Package Mode. It's optional argument, @code{f}, should be a filename that will simply be appended to the returned path.
@endluafunc

@anchor{install.gettempdir}
@luafunc install.gettempdir ()
This function is used to assign a temporary directory the the @code{install.destdir} variable. Setting @code{install.destdir} to a temporary directory is useful for installers that need to do additional tasks with the installation files such as compilation.
@endluafunc

@luafunc install.update ()
This function will update the frontend (drawing, handling input etc.). Usually this is done automatically, however in rare cases this needs to be done manually. A good example would be a loop (for loop, while loop etc) with many cycles.
@endluafunc

@subsubsection Functions used in the @code{Init} function
Following functions should only be used within the @code{Init} function.

@anchor{install.newscreen}
@luafunc install.newscreen ([t])
This function will return a class for a new @emph{installation screen}. The members of this class are described @ref{screen,,here}. The optional argument, @code{t}, specifies a (short) title for this screen.
@endluafunc

@subsubsection Functions used in the @code{Install} function
Following functions should only be used within the @code{Install} function.

@anchor{install.askrootpw}
@luafunc install.askrootpw ()
This function will ask the user to type the systems root password. This is done automatically if,
@itemize @bullet
@item @code{install.executeasroot()} is called,
@item when @code{install.destdir} is set to a directory which cannot be written to by the user,
@item in case @code{install.generatepkg} needs root (@code{pkg.needroot} is @code{true}),
@item in case @code{install.gendesktopentries} is used to install any desktop menu entries globally.
@end itemize
A good reason to call this functions is when you're sure the script will execute one or more commands as root @emph{after} @code{install.extractfiles()} is called. This way the user can abort if he or she doesn't want to or cannot type the root password before the installation begins.@*
@*
When this function is called more than once it won't do anything (the password is cached).
@endluafunc

@anchor{install.execute}
@luafunc install.execute (c[, r=true[, p=os.getenv("PATH")]])
This function will execute the shell command defined by string @code{s}. The optional boolean argument, @code{r}, tells that the installation should be aborted when the command fails to execute. With the optional argument @code{p} you can specify a value which is used to change the @code{PATH} shell variable before the command is executed. For longer shell commands it might be handy to use the @code{[[} and @code{]]} operators (@pxref{Strings}).@*
@*
This function writes all the output from the command to a status window so the user can see whats happening. Because of this it's better to use this command instead of @code{os.execute}. Another reason is that @code{os.execute} will block all user input when it's called, so that for example the user cannot abort the installation without manually killing it.@*
@*
Note that when @code{install.destdir} is unwritable for the current user and the user agreed to continue as root, @code{install.execute} will run the shell command as root.@*
@*
The function returns the exit status code from the command that was executed.
@endluafunc

@anchor{install.executecmd}
@luafunc install.executecmd (c, f[, r=true[, p=os.getenv("PATH")])
This function is the base for @ref{install.execute} and in most cases you want to use that function. Except for the @code{f} argument, all the arguments are the same as those from @code{install.execute}. The @code{f} argument should hold a Lua function that is used to handle (eg. display) any output that the executed command produced. The given function will be called with one argument, that holds a @code{string} containing the command output. Note that this function may be called more than once untill the command is finished.@*
Example:
@codeblock{install.executecmd("ls -a", function (s) print(s) end) @minus{}@minus{} Print all output to console.}
The function returns the exit status code from the command that was executed.
@endluafunc

@anchor{install.executeasroot}
@luafunc install.executeasroot (c[, r=true[, p=os.getenv("PATH")]])
This function does essentially the same as @code{install.execute}, but using the @code{su} command to execute it as root. When the root password is not given yet it will ask the user to do so. The function returns the exit status code from the command that was executed.
@endluafunc

@luafunc install.executecmdasroot (c, f[, r=true[, p=os.getenv("PATH")]])
This function is the base for @ref{install.executeasroot} and usually that function is used instead. The @code{f} argument is used for the same purpose as the @ref{install.executecmd} uses it. The other arguments are the same as those from the @code{install.executeasroot()} function. Like the other functions, the function returns the exit status code from the executed command.
@endluafunc

@luafunc install.extract (f)
This function is the base for @ref{install.extractfiles} and usually that function is used instead. This function will extract all the installation files to the path specified by the @code{install.destdir} variable. The argument @code{f} must contain a Lua function that will be called to update the extraction process. The given function is called after a file was extracted and gets 2 arguments; the first contains the filename and the second the current progress (in percent).@*
Example:
@codeblock{@minus{}@minus{} Extracts all files and prints the filenames with progress to the console.
install.extract(function(f, p) print(string.format("%s (%d%%)", s, p)) end}
@endluafunc

@anchor{install.extractfiles}
@luafunc install.extractfiles ()
This function will extract all installation files to the directory that was specified by the global variable @code{install.destdir}. This function will automatically call @code{install.setstatus()} to notify the user that the files are extracted. Each file which was extracted is printed on the screen, and the progress bar is updated properly.
@endluafunc

@anchor{install.gendesktopentries}
@luafunc install.gendesktopentries (g)
This function will install any previously created desktop menu entries. The argument @code{g} is a @code{boolean} that is used to tell if the entries should be installed globally (@code{true}) or locally (@code{false}). When Package Mode is used, this function should always be called before @ref{install.generatepkg}.
@endluafunc

@anchor{install.generatepkg}
@luafunc install.generatepkg ()
When using Package Mode, this function is used to create and install the software package. Like @ref{install.extractfiles}, this function will call @code{install.setstatus}. Note that this function should always be called after @code{install.gendesktopentries}.
@endluafunc

@anchor{install.lockscreen}
@luafunc install.lockscreen (c, b, n)
This function will lock or unlock the Cancel, Back and Next button. If @code{c} is @code{true} the Cancel button is locked, when @code{b} is @code{true} the Back button is locked and when @code{n} is @code{true} the Next button is locked. When @code{false} is given a button is unlocked.
@endluafunc

@anchor{install.print}
@luafunc install.print (s)
Prints the message specified by argument @code{s} on the status window from the install screen.
@endluafunc

@luafunc install.newdesktopentry (b, l, c)
This function is used to create new desktop menu entry tables. The first argument, @code{b}, should be a full path to the executable. The second argument, @code{l}, should either be a path to an image that is used as icon for the entry or @code{nil} for none. The third argument, @code{c}, should be one or more valid categories.@*
@*
This function automatically sets the @code{Name} field to @code{cfg.appname}, the @code{Type} field to @code{"Application"} and the Encoding field to @code{"UTF-8"}.@*
@*
More info on usage can be found @ref{deskentrieslua,,here}.
@endluafunc

@anchor{install.setstatus}
@luafunc install.setstatus (s)
You can use this function to specify a (short) message of the current status of the installation. This way the user can see what the installer is doing. @*
Example:
@codeblock{@minus{}@minus{} Somewhere inside the Install() function
@minus{}@minus{} ...
install.setstatus("Copying files")
os.copy(file1, file2, "/usr/local/share")}
@endluafunc

@anchor{install.setstepcount}
@luafunc install.setstepcount (n)
This function is used to specify how many @emph{steps} the installation has, specified by parameter @code{n}. This is used to divide the progress bar and to put a text in the form of (x/X) on the screen, where @samp{x} is the current step and @samp{X} the total count of steps. On each @code{install.setstatus} call the current step will be incremented by one. By default the step count is 1.@*
@*
Note that @code{install.extractfiles} and @code{install.generatepkg} both will call this function when they are executed, so you most likely want to increment @code{n} by one or two.
@endluafunc

@anchor{screen}
@subsection The @code{screen} class
The class described here is returned after a call to @code{install.newscreen}. The function definitions below use @samp{screen} as classname, though you should replace that name with the name of the variable that contains the class.

@anchor{screen:addcfgmenu}
@luafunc screen:addcfgmenu ([t])
Creates a new @samp{config menu}. The string parameter @code{t} sets a title. The menu is used to let the user configure certain parameters. These parameters can be paths (configured through a file manager), strings, boolean flags (can be enabled or disabled) or a list with options. The function will return a class containing function methods to add parameters. These are described @ref{cfgmenu, here}.
@endluafunc

@anchor{screen:addcheckbox}
@luafunc screen:addcheckbox (t, o[, e])
Adds a checkbox widget to the install screen. The argument @code{t} can be used to set a title (simply use "" for no title). The second argument, @code{o}, should be an array containing strings which specify the name for each option. The last optional argument @code{e} should be an array with all the option numbers to enable. The function will return a class with the following members (chkbox is just a name that should be replaced by the variable containing the class):
@luafunc chkbox:add (o[, p])
Adds option @code{o} at position @code{p}. When @code{p} is not given, the option will be added to the end.
@endluafunc
@luafunc chkbox:clear ()
Removes all previously added options.
@endluafunc
@luafunc chkbox:del (o)
Deletes option @code{o}. @code{o} can be a string containing the option name or can be an option number.
@endluafunc
@luafunc chkbox:get (o)
Returns @code{true} if the option @code{o} is enabled or @code{false} when disabled. @code{o} can be a string containing the option name or can be an option number.
@endluafunc
@luafunc chkbox:set (o, ..., e)
This variadic function enables or disables one or more options. The first argument, @code{o}, and the rest before argument @code{e} are the option numbers or strings containing the option names to enable or disable. If @code{e} is @code{true} the option(s) are enabled, if @code{false} they will be disabled.@*
@*
Example:
@codeblock{mybox:set(1, 3, true) @minus{}@minus{} Enable first and third option
mybox:set("Option", false) @minus{}@minus{} Disables the option @emph{Option}}
@endluafunc

@endluafunc

@anchor{screen:adddirselector}
@luafunc screen:adddirselector ([t[, d=os.getenv("HOME")]])
This function will add an inputfield which holds the current selected directory name and a button next to it which will launch a file dialog. This way the user can either select a directory by typing it or by browsing. Argument @code{t} sets an optional title and argument @code{d} sets an initial directory, defaulting to the user's home directory. The function will return a class with the following methods (where dirsel should be replaced by the actual variable name):
@luafunc dirsel:get ()
Returns a string containing the current selected directory.
@endluafunc
@luafunc dirsel:set (d)
Sets the directory to string @code{d}.
@endluafunc
@endluafunc

@anchor{screen:addgroup}
@luafunc screen:addgroup ()
Creates a new @samp{group widget}. This widget is used to position widgets horizontally next to eachother. To add a widget to the group you simple have to create a widget via the group's member functions. These member functions are equal to the widget creation functions from the @code{screen} class itself.@*
Example:
@codeblock{group = myscreen:addgroup()
img = group:addimage("graphics.jpeg")
text = group:addlabel("Thanks for downloading my software!")}
@endluafunc

@anchor{screen:addimage}
@luafunc screen:addimage (f)
This widget displays an image loaded from file @code{f}. The image is scaled down in case it's larger than 300x200 px. Valid formats are: png, jpeg, gif and bmp.
@endluafunc

@anchor{screen:addinput}
@luafunc screen:addinput ([l[, t[, m=1024[, v[, tp="string"]]]])
This will add an input field to the install screen. The parameter @code{l} is used to specify a label (text which is put in front of the input field). The parameter @code{t} specifies a title (set to "" for none). @code{m} specifies the max character count that can be typed. @code{v} specifies an initial value. The last parameter, @code{tp}, specifies the type of the inputfield and can be one of these:
@table @strong
@item "string"
The user can type any (alphanumeric) character as input.
@item "number"
The user can type any number but not fractions.
@item "float"
The user can type any number including fractions.
@end table
The function will return a class with the following method functions (input should be replaced with the actual variable name which points to this class):
@anchor{input:get}
@luafunc input:get ()
Returns the current value hold by the input field.
@endluafunc
@luafunc input:set (s)
Sets the current value to the string @code{s}.
@endluafunc
@anchor{input:setlabelwidth}
@luafunc input:setlabelwidth (w)
This function sets the label width to @code{w} units wide. A usable value for @code{w} is frontend and font specific, therefore always use the @ref{gui.textwidth} function to get a reasonable width. This function is typically used to let multiple inputfields start at the same horizontal position, by setting their label width to the same value. The default value is to have space for about 15 @samp{A} characters.
@endluafunc
@endluafunc

@anchor{screen:addlabel}
@luafunc screen:addlabel (l)
This widget displays a simple text label with the text specified by argument @code{l}. The function returns a class with the following method (replace label with the actual variable name):
@luafunc label:set (l)
Sets the label text to string @code{l}.@*
@strong{Note}: This function is now @emph{deprecated} and should not be used in new code. Use the @ref{widget:setlabel} function instead.
@endluafunc
@endluafunc

@anchor{screen:addmenu}
@luafunc screen:addmenu (t, o[, e])
This function will add a menu (or listbox) widget to the install screen. The parameter @code{t} specifies a title (set to "" for none). The parameter @code{o} should be an array containing string entries with the options that can be selected. The optional argument @code{e} should be an option number to enable beforehand. Note that depending on the frontend the given options may be sorted when presented to the user. The function returns a class with the following methods (menu should be replaced by the variable that is pointing to the class):
@luafunc menu:add (o)
Adds option @code{o} to the menu.
@endluafunc
@luafunc menu:clear ()
Removes all previously added options.
@endluafunc
@luafunc menu:del (o)
Deletes option @code{o}. @code{o} can be a string containing the option name or can be an option number.
@endluafunc
@luafunc menu:get ()
Returns the name of the option that is enabled.
@endluafunc
@luafunc menu:set (o)
Selects the option @code{o}, which can be an array index or string with the option name.
@endluafunc
@endluafunc

@anchor{screen:addprogressbar}
@luafunc screen:addprogressbar ([t])
This function adds a progressbar to the install screen. The optional string argument @code{t} is used for a title. The function returns a class with the following method (replace progbar with the actual variable name):
@luafunc progbar:set (v)
The argument @code{v} should be a number between 0 and 100. This number tells how many percent of the bar should be filled (0: empty, 100: full).
@endluafunc
@endluafunc

@anchor{screen:addradiobutton}
@luafunc screen:addradiobutton (t, o[, e])
This function will add a radio button widget to the install screen. The argument @code{t} specifies a title (set to "" for none). The parameter @code{o} should be an array containing string entries with the options that can be selected. The optional argument @code{e} should be an option number to enable beforehand. This function will return a class with the following methods (radio should be replaced by the variable that is pointing to the class):
@luafunc radio:add (o)
Adds option @code{o} at position @code{p}. When @code{p} is not given, the option will be added to the end.
@endluafunc
@luafunc radio:clear ()
Removes all previously added options.
@endluafunc
@luafunc radio:del (o)
Deletes option @code{o}. @code{o} can be a string containing the option name or can be an option number.
@endluafunc
@luafunc radio:get ()
Returns the name of the option that is enabled.
@endluafunc
@luafunc radio:set (o)
Enables the option @code{o}, which can be an array index or string with the option name.
@endluafunc
@endluafunc

@anchor{screen:addtextfield}
@luafunc screen:addtextfield ([t=""[, w=false[, s="medium"]])
This widget is used to display multiple lines of text. When necessary, the user can scroll through the text lines. The optional argument @code{t} sets a title. Optional argument @code{w} enables or disables word wrapping. The optional argument @code{s} specifies the size of the widget and must be "small", "medium" or "big". The function returns a class with the following methods (replace textfield with the actual variable name):
@luafunc textfield:add (s)
Adds the text from the string argument @code{s}.
@endluafunc
@luafunc textfield:load (f)
Loads a file and appends its content. The filename is specified by string argument @code{f}.
@endluafunc
@luafunc textfield:clear ()
Clears all the text.
@endluafunc
@luafunc textfield:follow (f)
If argument @code{f} is @code{true} @samp{follow mode} is enabled, when @code{f} is @code{false} it's disabled. When follow mode is enabled, the widget will always display the last text lines. 
@endluafunc
@endluafunc

@luafunc screen:addscreenend ()
After this function is called any new widgets are created in a new subscreen (whether they would fit on the current subscreen or not).
@endluafunc

@subsection The generic @code{widget} class
Each widget @emph{inherits} all member functions from the generic @code{widget} class. So each widget will always have the functions described below. Replace the @code{widget} part with the actual variable pointing the to the widget.
@luafunc widget:enable (e)
When @code{e} is @code{true} this widget will be enabled, when @code{e} is @code{false} it will be disabled.
@endluafunc
@anchor{widget:setlabel}
@luafunc widget:setlabel (l)
Sets the widget's label (or title) to the @code{string} @code{s}. Note that not all widgets have labels (ie. the image widget).
@endluafunc
@luafunc widget:setlabelattr (a[, s])
Modifies the @emph{text attribute} of the widget's label. The @code{string} argument @code{a} tells what attribute to change:
@table
@item "bold"
Makes the text bold.
@item "italic"
Makes the text italic.
@item "size"
Modifies the text size. The @code{s} argument is used to specify the size and must be one of the following:
@itemize @bullet
@item "small"
@item "normal"
@item "big"
@end itemize
The default text size is "normal"
@end table
@endluafunc


@anchor{cfgmenu}
@subsection The @code{config menu} Class
This (sub)section describes the @code{config menu} class, which is created by @ref{screen:addcfgmenu}. This menu is used to let the user configure various parameters through a menu. A type for these parameters is specified so that the user can change them in a logic way; file paths with a file manager, parameters with predefined options through a listbox etc.
The class contains the following methods (replace cfgmenu with the variable name pointing to the class):

@luafunc cfgmenu:addbool (p, d[, v=false])
This function will add a parameter that can be enabled or disabled by the user. Argument @code{p} should be a @code{string} containing the name of the parameter. Argument @code{d} should be a @code{string} with a description. The optional argument @code{v} is a @code{boolean} telling the initial value: @code{true} if enabled, @code{false} when disabled.
@endluafunc

@luafunc cfgmenu:adddir (p, d[, v])
This function adds a parameter that will contain a @code{string} that holds a directory path. The user can modify this through a file browser. Argument @code{p} should be a string containing the parameter name, @code{d} a string with a description and @code{v} a string with an initial path.
@endluafunc

@luafunc cfgmenu:addlist (p, d, l[, v])
This function adds a parameter which the user can edit with a predefined list of options. @code{p} specifies the variable name, @code{d} a description and @code{l} should be an array with strings for each option name. The optional variable @code{v} is a string with the initial value.
@endluafunc

@luafunc cfgmenu:addstring (p, d[, v])
This function adds a parameter that can the user can modify through an input field. Argument @code{p} sets the parameter name, @code{d} the description and @code{v} should be a string with the initial value.
@endluafunc

@luafunc cfgmenu:del (p)
Deletes parameter @code{p}.
@endluafunc

@luafunc cfgmenu:get (p)
Returns the value from parameter @code{p}. If the type of @code{p} is a boolean, @code{true} will be returned when the parameter is enabled and @code{false} if disabled. In all other cases a @code{string} will be returned.
@endluafunc

@luafunc cfgmenu:set (p, v)
This function will set parameter @code{p} to value @code{v}.
@endluafunc


@section GUI Functions
There are several functions available through the @code{gui} package which interact with the user. Like the @code{install} package, all of these functions should only be called in the @code{Install} function (@pxref{Creating the Installer}).

@luafunc gui.choicebox (m, b1, b2[, b3])
Creates a window that will show the message identified by function argument @code{m}. @code{b1}, @code{b2} and (optionally) @code{b3} is each a string used for a button name (so the window can have 2 or 3 buttons). On failure the function will return the number of the last button (@samp{3}). On success the number of the clicked button is returned.
Examples:
@codeblock{@minus{}@minus{} somewhere in the Install() function
gui.choicebox("Could not copy file, what should I do?", "Abort", "Retry", "Ignore") @minus{}@minus{} 3 buttons
@*
@minus{}@minus{} ....
gui.choicebox("Could not execute command, what do you want?", "Ignore", "Abort") @minus{}@minus{} 2 buttons}
@endluafunc

@luafunc gui.msgbox (m, ...)
Will display a dialog with the text specified by argument @code{m}. The variadic arguments can be used to concat other texts to this message.@*
Example:
@codeblock {gui.msgbox("Thank you for downloading myapp 0.1! For updates please check www.myapp.org")}
@endluafunc

@anchor{gui.textwidth}
@luafunc gui.textwidth (s)
Returns the space needed to display @code{string} @code{s}. This function is usally used in combination with @ref{input:setlabelwidth}.
@endluafunc

@luafunc gui.warnbox (m, ...)
The same as @code{gui.msgbox}, but used to alert the user. For example in ncurses the dialog has another color (red) and with the FLTK frontend a warning sign will be shown.
@endluafunc

@luafunc gui.yesnobox (m, ...)
This function will show a dialog with a message used from parameter @code{m} and arguments after that if available (will concat text). The dialog has a yes and a no button. If the user presses "No" @code{false} will be returned, if "Yes" @code{true} is returned.
Example:
@codeblock{@minus{}@minus{} Somewhere in Install() 
if (gui.yesnobox("Do you want to install some add-ons?")) then
    @minus{}@minus{} Copy some files
end}
@endluafunc


@section Utilities
Several utility functions exist in the @code{utils} package, these are described here.

@luafunc utils.basename (p)
This function will strip the directory part of a given path (string argument @code{p}) and returns the remaining filename.
@endluafunc

@luafunc utils.copyrec (s, d)
Copies all files and directories recursively from source directory @code{d} to destination @code{d}.
@endluafunc

@luafunc utils.dirname (p)
This function does the opposite of @code{utils.basename}: it strips out the filename at the end of the given path @code{p} and returns the remaining directory part.
@endluafunc

@luafunc utils.emptystring (s)
Returns @code{true} when @code{string} @code{s} is @code{nil} or empty (@samp{""}).
@endluafunc

@luafunc utils.emptytable (t)
Returns @code{true} if table @code{t} is empty.
@endluafunc

@luafunc utils.mapsize (t)
Returns the size of @ref{luamap,, map} @code{t}.
@endluafunc

@luafunc utils.mkdirperm (d)
Returns @code{true} if the installer has permission to create directory @code{d}.
@endluafunc

@luafunc utils.moverec (s, d)
This function will move all the files from source directory @code{s} to the destination directory @code{d}. The function returns the exit status from the @command{mv} command. Note that this function can only be called during installation (in the @code{Install()} function).
@endluafunc

@luafunc utils.opendoc (f)
This function can be used to open a document. Argument @code{f} should contain the filename. The function tries to find a suitable application and opens the given file with this application.
@endluafunc

@luafunc utils.patch (f, p, n)
This function will @samp{patch} file @code{f}. It will substitute all instances @code{p} with the new @code{string} @code{n}. Note that argument @code{p} may be a @uref{http://www.lua.org/pil/20.2.html,string pattern}.
@endluafunc

@luafunc utils.recursivedir (p, f)
This function will recursively traverse a directory, specified by the argument @code{p}, and call the given function @code{f} on every file inside this or any subdirectory. The given function @code{f} should accept two arguments: the first argument is used to pass the full path to the file, the second argument is used to pass the relative path seen from the starting directory to the file.@*
Example:
@codeblock{@minus{}@minus{} Prints every file, subdirectory and files in any subdirectories from @file{/usr/share} (similar to ls -R)
utils.recursivedir("/usr/share", function (path, relpath) print(path .. "\n") end)}
@endluafunc

@luafunc utils.removerec (d)
Removes all files and directories recursively inside directory @code{d}.
@endluafunc

@luafunc utils.tableappend (t1, t2)
Appends all the values from table @code{t2} to table @code{t1}. Note that this function only works on @ref{arrays}.
@endluafunc

@luafunc utils.tablefind (t, v)
This function finds value @code{v} inside array @code{t} and returns the numeric index from where the value was found.@*
Example:
@codeblock{t = @{ "first", "second", "third" @}
print(utils.tablefind(t, "second")) @minus{}@minus{} Prints @samp{2}}
@endluafunc

@luafunc utils.tablemerge (t1, t2)
Merges all values from table @code{t2} in to table @code{t1}.@*
Example:
@codeblock{t1 = @{ @}
t1[1] = "first"
t1[3] = "third"
t2 = @{ @}
t2[2] = "second"
utils.tablemerge(t1, t2)
@minus{}@minus{} t1 now looks like this: @{ "first", "second", "third" @}}
@endluafunc


@section Other Functions and Variables
The last few functions and variables are not in any package but are global.

@defvr Variable version
This variable contains a string used to identify the current Nixstaller version. The current value is "0.4".
@end defvr

@luafunc assert (f[, ...[, m="Assert failed!"]])
This function is mainly used to debug Lua scripts. If @code{r} is @code{false} or @code{nil} this function will call @code{error} with @code{m} as argument. If @code{r} is another value the function will return @code{r} and the variadic arguments between @code{f} and @code{m} (if existant). This is mostly used in combination with functions that will return @code{nil} on error (many functions from the @code{os} package do this for example).@*
Example:
@codeblock{assert(os.rename("file1", "file2"))    @minus{}@minus{} If this function fails the script will be aborted}
@endluafunc

@luafunc dofile (f)
Executes the Lua script specified by argument @code{f}. You can use this if you want to split script files for example.@*
Example:
@codeblock{if (os.osname == "linux") then
    dofile("linux.lua")
elseif (os.osname == "sunos") then
    dofile("solaris.lua")
else
    dofile("generic.lua")
end}
@endluafunc

@luafunc error (m[, l=1])
This function will abort the install and display an error specified by string @code{m} prefixed with the script name and line number. The optional argument, @code{l}, is used to specify the function level which is used when displaying the error: if it's @samp{0} no line number will be displayed, @samp{1} is used for the current line number (default), @samp{2} for the line number of the function that called the current function etc. @*
Example:
@codeblock{if (not os.copy("file.txt", "somedir/")) then
    error("Could not copy file")
end}
@endluafunc

@luafunc ipairs (t)
Iterator function that can be used to traverse an array with numeric indexes. Returns 2 values: the first is the current array index and the second is the current entry at that array index. When the next entry is @code{nil}, the function will return @code{nil}. This way it will terminate a generic for loop. Argument @code{t} specifies the table to use.@*
Example:
@codeblock{t = @{ 5, 10, 15, 20 @}
for i, e in ipairs(t) do
    print(string.format("t[%d] = %d", i, e))
end}
Results in
@codeblock{t[1] = 5
t[2] = 10
t[3] = 15
t[4] = 20}
@endluafunc

@luafunc pairs (t)
As the above function (well mostly, see the @uref{http://www.lua.org/manual/5.1, Lua manual for details}). This function also accepts other key index types than numbers.@*
Example:
@codeblock{t = @{ @}
t.name = "Rick"
t.age = 21
t.country = "The Netherlands"
for i, e in pairs(t) do
    print(string.format("t.%s = %s", i, e))
end}
Results in
@codeblock{t.name = Rick
t.age = 21
t.country = The Netherlands}
@endluafunc

@anchor{print}
@luafunc print (s[, ...])
This function will print all the given arguments to the standard output (usually the terminal). Since the ncurses frontend already uses the terminal it will call @code{os.log} instead. This function is mainly only used for debugging, since the user probably won't notice the output.
@endluafunc

@luafunc unpack (t[, i=1[, j=#t]])
Returns each entry from table @code{t}. This table should be an array with numeric indexes. @code{i} and @code{j} specify the range to use.@*
Example:
@codeblock{t = @{ "Hello", " ", "World" @}
print(unpack(t))    @minus{}@minus{} Prints "Hello World"}
@endluafunc

@anchor{tr}
@luafunc tr(s[, ...])
This function will return the translated text from @code{string} @code{s}. If @code{s} contains one or more @emph{modifiers}, they will be replaced (in order) by any of the following arguments after @code{s}. For more information see @ref{Translate strings}.
@endluafunc



@node License
@appendix License
Nixstaller is licensed under the GPLv2 license:

@quotation
Copyright (C) 2006 - 2009 Rick Helmus (rhelmus_AT_gmail.com)

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any later
version. 

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details. 

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 51 Franklin
St, Fifth Floor, Boston, MA 02110-1301 USA
@end quotation



@node Index
@unnumbered Index

@comment @unnumberedsec General
@comment @printindex cp


@unnumberedsec Nixstaller Variables
@printindex vr


@unnumberedsec Nixstaller Functions
@printindex fn

@bye
